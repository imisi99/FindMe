This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
core/
  cache.go
  conf.go
  cron.go
  database.go
  email.go
  emb.go
  msg.go
  rec.go
database/
  database.go
  redis.go
docs/
  docs.go
  swagger.json
  swagger.yaml
emb/
  emb_grpc.pb.go
  emb.pb.go
handlers/
  conf.go
  github.go
  handler.go
  health.go
  msg.go
  post.go
  realtime.go
  transc.go
  user.go
model/
  msg.go
  post.go
  skills.go
  transc.go
  user.go
nginx/
  conf.d/
    app.conf
    cert.conf
  nginx.conf
proto/
  emb.proto
  rec.proto
rec/
  rec_grpc.pb.go
  rec.pb.go
schema/
  doc.go
  msg.go
  post.go
  rec.go
  transc.go
  user.go
test/
  unit/
    main_test.go
    mock_test.go
    msg_test.go
    post_test.go
    schemas_test.go
    transc_test.go
    user_test.go
.gitignore
docker-compose.yml
Dockerfile
generate.sh
go.mod
LICENSE
main.go
README.md
```

# Files

## File: core/cron.go
```go
package core

import (
	"log"
	"time"

	"findme/model"

	"github.com/robfig/cron/v3"
)

type CronWorker interface {
	TrialEndingReminders() error
}

type Cron struct {
	DB    DB
	Email Email
	Cron  *cron.Cron
}

func NewCron(db DB, email Email, cron *cron.Cron) *Cron {
	return &Cron{db, email, cron}
}

func (c *Cron) TrialEndingReminders() error {
	_, err := c.Cron.AddFunc("0 9 * * *", func() {
		log.Println("[CRON] Running trial ending reminders...")
		twoDays := time.Now().Add(time.Hour * 24 * 2)
		today := time.Now()

		var users []model.User
		if err := c.DB.FetchTrialEndingUsers(&users, twoDays, today); err != nil {
			return
		}

		if len(users) == 0 {
			return
		}

		ids := make([]string, len(users))

		for i, user := range users {
			ids[i] = user.ID
			c.Email.QueueNotifyFreeTrialEnding(user.UserName, user.FreeTrial.Format("January 2, 2006"), "", user.Email)
		}

		if err := c.DB.UpdateSentReminder(ids); err != nil {
			return
		}
	})

	return err
}
```

## File: emb/emb_grpc.pb.go
```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.12.4
// source: emb.proto

package emb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserEmbeddingService_CreateUserEmbedding_FullMethodName = "/emb.UserEmbeddingService/CreateUserEmbedding"
	UserEmbeddingService_UpdateUserEmbedding_FullMethodName = "/emb.UserEmbeddingService/UpdateUserEmbedding"
	UserEmbeddingService_UpdateUserStatus_FullMethodName    = "/emb.UserEmbeddingService/UpdateUserStatus"
	UserEmbeddingService_DeleteUserEmbedding_FullMethodName = "/emb.UserEmbeddingService/DeleteUserEmbedding"
)

// UserEmbeddingServiceClient is the client API for UserEmbeddingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserEmbeddingServiceClient interface {
	CreateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateUserStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	DeleteUserEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
}

type userEmbeddingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserEmbeddingServiceClient(cc grpc.ClientConnInterface) UserEmbeddingServiceClient {
	return &userEmbeddingServiceClient{cc}
}

func (c *userEmbeddingServiceClient) CreateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_CreateUserEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmbeddingServiceClient) UpdateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_UpdateUserEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmbeddingServiceClient) UpdateUserStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_UpdateUserStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmbeddingServiceClient) DeleteUserEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_DeleteUserEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserEmbeddingServiceServer is the server API for UserEmbeddingService service.
// All implementations must embed UnimplementedUserEmbeddingServiceServer
// for forward compatibility.
type UserEmbeddingServiceServer interface {
	CreateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateUserStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error)
	DeleteUserEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error)
	mustEmbedUnimplementedUserEmbeddingServiceServer()
}

// UnimplementedUserEmbeddingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserEmbeddingServiceServer struct{}

func (UnimplementedUserEmbeddingServiceServer) CreateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateUserEmbedding not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) UpdateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserEmbedding not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) UpdateUserStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserStatus not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) DeleteUserEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteUserEmbedding not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) mustEmbedUnimplementedUserEmbeddingServiceServer() {}
func (UnimplementedUserEmbeddingServiceServer) testEmbeddedByValue()                              {}

// UnsafeUserEmbeddingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserEmbeddingServiceServer will
// result in compilation errors.
type UnsafeUserEmbeddingServiceServer interface {
	mustEmbedUnimplementedUserEmbeddingServiceServer()
}

func RegisterUserEmbeddingServiceServer(s grpc.ServiceRegistrar, srv UserEmbeddingServiceServer) {
	// If the following call panics, it indicates UnimplementedUserEmbeddingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserEmbeddingService_ServiceDesc, srv)
}

func _UserEmbeddingService_CreateUserEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).CreateUserEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_CreateUserEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).CreateUserEmbedding(ctx, req.(*UserEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmbeddingService_UpdateUserEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).UpdateUserEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_UpdateUserEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).UpdateUserEmbedding(ctx, req.(*UserEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmbeddingService_UpdateUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).UpdateUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_UpdateUserStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).UpdateUserStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmbeddingService_DeleteUserEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).DeleteUserEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_DeleteUserEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).DeleteUserEmbedding(ctx, req.(*DeleteEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserEmbeddingService_ServiceDesc is the grpc.ServiceDesc for UserEmbeddingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserEmbeddingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emb.UserEmbeddingService",
	HandlerType: (*UserEmbeddingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUserEmbedding",
			Handler:    _UserEmbeddingService_CreateUserEmbedding_Handler,
		},
		{
			MethodName: "UpdateUserEmbedding",
			Handler:    _UserEmbeddingService_UpdateUserEmbedding_Handler,
		},
		{
			MethodName: "UpdateUserStatus",
			Handler:    _UserEmbeddingService_UpdateUserStatus_Handler,
		},
		{
			MethodName: "DeleteUserEmbedding",
			Handler:    _UserEmbeddingService_DeleteUserEmbedding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "emb.proto",
}

const (
	ProjectEmbeddingService_CreateProjectEmbedding_FullMethodName = "/emb.ProjectEmbeddingService/CreateProjectEmbedding"
	ProjectEmbeddingService_UpdateProjectEmbedding_FullMethodName = "/emb.ProjectEmbeddingService/UpdateProjectEmbedding"
	ProjectEmbeddingService_UpdateProjectStatus_FullMethodName    = "/emb.ProjectEmbeddingService/UpdateProjectStatus"
	ProjectEmbeddingService_DeleteProjectEmbedding_FullMethodName = "/emb.ProjectEmbeddingService/DeleteProjectEmbedding"
)

// ProjectEmbeddingServiceClient is the client API for ProjectEmbeddingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectEmbeddingServiceClient interface {
	CreateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateProjectStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	DeleteProjectEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
}

type projectEmbeddingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectEmbeddingServiceClient(cc grpc.ClientConnInterface) ProjectEmbeddingServiceClient {
	return &projectEmbeddingServiceClient{cc}
}

func (c *projectEmbeddingServiceClient) CreateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_CreateProjectEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectEmbeddingServiceClient) UpdateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_UpdateProjectEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectEmbeddingServiceClient) UpdateProjectStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_UpdateProjectStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectEmbeddingServiceClient) DeleteProjectEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_DeleteProjectEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectEmbeddingServiceServer is the server API for ProjectEmbeddingService service.
// All implementations must embed UnimplementedProjectEmbeddingServiceServer
// for forward compatibility.
type ProjectEmbeddingServiceServer interface {
	CreateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateProjectStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error)
	DeleteProjectEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error)
	mustEmbedUnimplementedProjectEmbeddingServiceServer()
}

// UnimplementedProjectEmbeddingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProjectEmbeddingServiceServer struct{}

func (UnimplementedProjectEmbeddingServiceServer) CreateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateProjectEmbedding not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) UpdateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProjectEmbedding not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) UpdateProjectStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProjectStatus not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) DeleteProjectEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProjectEmbedding not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) mustEmbedUnimplementedProjectEmbeddingServiceServer() {
}
func (UnimplementedProjectEmbeddingServiceServer) testEmbeddedByValue() {}

// UnsafeProjectEmbeddingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectEmbeddingServiceServer will
// result in compilation errors.
type UnsafeProjectEmbeddingServiceServer interface {
	mustEmbedUnimplementedProjectEmbeddingServiceServer()
}

func RegisterProjectEmbeddingServiceServer(s grpc.ServiceRegistrar, srv ProjectEmbeddingServiceServer) {
	// If the following call panics, it indicates UnimplementedProjectEmbeddingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProjectEmbeddingService_ServiceDesc, srv)
}

func _ProjectEmbeddingService_CreateProjectEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).CreateProjectEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_CreateProjectEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).CreateProjectEmbedding(ctx, req.(*ProjectEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectEmbeddingService_UpdateProjectEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_UpdateProjectEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectEmbedding(ctx, req.(*ProjectEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectEmbeddingService_UpdateProjectStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_UpdateProjectStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectEmbeddingService_DeleteProjectEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).DeleteProjectEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_DeleteProjectEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).DeleteProjectEmbedding(ctx, req.(*DeleteEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectEmbeddingService_ServiceDesc is the grpc.ServiceDesc for ProjectEmbeddingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectEmbeddingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emb.ProjectEmbeddingService",
	HandlerType: (*ProjectEmbeddingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProjectEmbedding",
			Handler:    _ProjectEmbeddingService_CreateProjectEmbedding_Handler,
		},
		{
			MethodName: "UpdateProjectEmbedding",
			Handler:    _ProjectEmbeddingService_UpdateProjectEmbedding_Handler,
		},
		{
			MethodName: "UpdateProjectStatus",
			Handler:    _ProjectEmbeddingService_UpdateProjectStatus_Handler,
		},
		{
			MethodName: "DeleteProjectEmbedding",
			Handler:    _ProjectEmbeddingService_DeleteProjectEmbedding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "emb.proto",
}
```

## File: handlers/health.go
```go
package handlers

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// DetailedHealth godoc
// @Summary Checks the health of the services running
// @Description This gives a detailed health status of the running services
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} map[string]any "Service Healthy"
// @Failure 503 {object} map[string]any "Service Degraded"
// @Router /health/detailed [get]
func (s *Service) DetailedHealth(ctx *gin.Context) {
	health := gin.H{
		"status":    "ok",
		"timestamp": time.Now().Unix(),
		"checks":    gin.H{},
	}

	overallHealthy := true

	// Check Database
	if err := s.DB.CheckHealth(); err != nil {
		health["checks"].(gin.H)["database"] = gin.H{
			"status": "unhealthy",
			"error":  err.Error(),
		}
		overallHealthy = false
	} else {
		health["checks"].(gin.H)["database"] = gin.H{
			"status": "healthy",
		}
	}

	// Check Redis
	if err := s.RDB.CheckHealth(); err != nil {
		health["checks"].(gin.H)["cache"] = gin.H{
			"status": "unhealthy",
			"error":  err.Error(),
		}
		overallHealthy = false
	} else {
		health["checks"].(gin.H)["cache"] = gin.H{
			"status": "healthy",
		}
	}

	if !overallHealthy {
		health["status"] = "degraded"
		ctx.JSON(http.StatusServiceUnavailable, health)
		return
	}

	ctx.JSON(http.StatusOK, health)
}
```

## File: nginx/conf.d/cert.conf
```
server {
  listen 80;
  server_name findmeapi.duckdns.org;
  
  location /.well-known/acme-challenge/ {
    root /var/www/certbot/;
    try_files $uri =404;
  }

  location / {
    return 301 https://$host$request_uri;
  }
}

server {
  listen 443 ssl http2;
  server_name findmeapi.duckdns.org;

  ssl_certificate /etc/letsencrypt/live/findmeapi.duckdns.org/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/findmeapi.duckdns.org/privkey.pem;

  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
  ssl_prefer_server_ciphers off;

  add_header Strict-Transport-Security "max-age=31536000" always;

  location /health {
    proxy_pass http://app/health;
    access_log off;
  }

  location /api/ {
    limit_req zone=api_limit burst=20 nodelay;

    proxy_pass http://app;
    proxy_http_version 1.1;
    
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
  }

  location / {
    proxy_pass http://app;
    proxy_http_version 1.1;
    
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
  }
}
```

## File: rec/rec_grpc.pb.go
```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.12.4
// source: rec.proto

package rec

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RecommendationService_ProjectRecommendation_FullMethodName = "/rec.RecommendationService/ProjectRecommendation"
	RecommendationService_UserRecommendation_FullMethodName    = "/rec.RecommendationService/UserRecommendation"
)

// RecommendationServiceClient is the client API for RecommendationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RecommendationServiceClient interface {
	ProjectRecommendation(ctx context.Context, in *RecommendationRequest, opts ...grpc.CallOption) (*RecommendationResponse, error)
	UserRecommendation(ctx context.Context, in *RecommendationRequest, opts ...grpc.CallOption) (*RecommendationResponse, error)
}

type recommendationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRecommendationServiceClient(cc grpc.ClientConnInterface) RecommendationServiceClient {
	return &recommendationServiceClient{cc}
}

func (c *recommendationServiceClient) ProjectRecommendation(ctx context.Context, in *RecommendationRequest, opts ...grpc.CallOption) (*RecommendationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecommendationResponse)
	err := c.cc.Invoke(ctx, RecommendationService_ProjectRecommendation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *recommendationServiceClient) UserRecommendation(ctx context.Context, in *RecommendationRequest, opts ...grpc.CallOption) (*RecommendationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecommendationResponse)
	err := c.cc.Invoke(ctx, RecommendationService_UserRecommendation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RecommendationServiceServer is the server API for RecommendationService service.
// All implementations must embed UnimplementedRecommendationServiceServer
// for forward compatibility.
type RecommendationServiceServer interface {
	ProjectRecommendation(context.Context, *RecommendationRequest) (*RecommendationResponse, error)
	UserRecommendation(context.Context, *RecommendationRequest) (*RecommendationResponse, error)
	mustEmbedUnimplementedRecommendationServiceServer()
}

// UnimplementedRecommendationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRecommendationServiceServer struct{}

func (UnimplementedRecommendationServiceServer) ProjectRecommendation(context.Context, *RecommendationRequest) (*RecommendationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ProjectRecommendation not implemented")
}
func (UnimplementedRecommendationServiceServer) UserRecommendation(context.Context, *RecommendationRequest) (*RecommendationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UserRecommendation not implemented")
}
func (UnimplementedRecommendationServiceServer) mustEmbedUnimplementedRecommendationServiceServer() {}
func (UnimplementedRecommendationServiceServer) testEmbeddedByValue()                               {}

// UnsafeRecommendationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RecommendationServiceServer will
// result in compilation errors.
type UnsafeRecommendationServiceServer interface {
	mustEmbedUnimplementedRecommendationServiceServer()
}

func RegisterRecommendationServiceServer(s grpc.ServiceRegistrar, srv RecommendationServiceServer) {
	// If the following call panics, it indicates UnimplementedRecommendationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RecommendationService_ServiceDesc, srv)
}

func _RecommendationService_ProjectRecommendation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecommendationServiceServer).ProjectRecommendation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RecommendationService_ProjectRecommendation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecommendationServiceServer).ProjectRecommendation(ctx, req.(*RecommendationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RecommendationService_UserRecommendation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecommendationServiceServer).UserRecommendation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RecommendationService_UserRecommendation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecommendationServiceServer).UserRecommendation(ctx, req.(*RecommendationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RecommendationService_ServiceDesc is the grpc.ServiceDesc for RecommendationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RecommendationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rec.RecommendationService",
	HandlerType: (*RecommendationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProjectRecommendation",
			Handler:    _RecommendationService_ProjectRecommendation_Handler,
		},
		{
			MethodName: "UserRecommendation",
			Handler:    _RecommendationService_UserRecommendation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rec.proto",
}
```

## File: generate.sh
```bash
#!/bin/bash

set -e

protoc \
  --proto_path=proto \
  --go_out=. \
  --go-grpc_out=. \
  proto/emb.proto

protoc \
  --proto_path=proto \
  --go_out=. \
  --go-grpc_out=. \
  proto/rec.proto

echo "Proto files generated successfully"
```

## File: emb/emb.pb.go
```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.12.4
// source: emb.proto

package emb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UserEmbeddingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Bio           string                 `protobuf:"bytes,2,opt,name=bio,proto3" json:"bio,omitempty"`
	Skills        []string               `protobuf:"bytes,3,rep,name=skills,proto3" json:"skills,omitempty"`
	Interests     []string               `protobuf:"bytes,4,rep,name=interests,proto3" json:"interests,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserEmbeddingRequest) Reset() {
	*x = UserEmbeddingRequest{}
	mi := &file_emb_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserEmbeddingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserEmbeddingRequest) ProtoMessage() {}

func (x *UserEmbeddingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_emb_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserEmbeddingRequest.ProtoReflect.Descriptor instead.
func (*UserEmbeddingRequest) Descriptor() ([]byte, []int) {
	return file_emb_proto_rawDescGZIP(), []int{0}
}

func (x *UserEmbeddingRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *UserEmbeddingRequest) GetBio() string {
	if x != nil {
		return x.Bio
	}
	return ""
}

func (x *UserEmbeddingRequest) GetSkills() []string {
	if x != nil {
		return x.Skills
	}
	return nil
}

func (x *UserEmbeddingRequest) GetInterests() []string {
	if x != nil {
		return x.Interests
	}
	return nil
}

type ProjectEmbeddingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProjectId     string                 `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	Title         string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	UserId        string                 `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Skills        []string               `protobuf:"bytes,5,rep,name=skills,proto3" json:"skills,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectEmbeddingRequest) Reset() {
	*x = ProjectEmbeddingRequest{}
	mi := &file_emb_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectEmbeddingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectEmbeddingRequest) ProtoMessage() {}

func (x *ProjectEmbeddingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_emb_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectEmbeddingRequest.ProtoReflect.Descriptor instead.
func (*ProjectEmbeddingRequest) Descriptor() ([]byte, []int) {
	return file_emb_proto_rawDescGZIP(), []int{1}
}

func (x *ProjectEmbeddingRequest) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *ProjectEmbeddingRequest) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *ProjectEmbeddingRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ProjectEmbeddingRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ProjectEmbeddingRequest) GetSkills() []string {
	if x != nil {
		return x.Skills
	}
	return nil
}

type UpdateStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Status        bool                   `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateStatusRequest) Reset() {
	*x = UpdateStatusRequest{}
	mi := &file_emb_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateStatusRequest) ProtoMessage() {}

func (x *UpdateStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_emb_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateStatusRequest.ProtoReflect.Descriptor instead.
func (*UpdateStatusRequest) Descriptor() ([]byte, []int) {
	return file_emb_proto_rawDescGZIP(), []int{2}
}

func (x *UpdateStatusRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *UpdateStatusRequest) GetStatus() bool {
	if x != nil {
		return x.Status
	}
	return false
}

type DeleteEmbeddingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteEmbeddingRequest) Reset() {
	*x = DeleteEmbeddingRequest{}
	mi := &file_emb_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteEmbeddingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteEmbeddingRequest) ProtoMessage() {}

func (x *DeleteEmbeddingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_emb_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteEmbeddingRequest.ProtoReflect.Descriptor instead.
func (*DeleteEmbeddingRequest) Descriptor() ([]byte, []int) {
	return file_emb_proto_rawDescGZIP(), []int{3}
}

func (x *DeleteEmbeddingRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type EmbeddingResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Msg           string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmbeddingResponse) Reset() {
	*x = EmbeddingResponse{}
	mi := &file_emb_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmbeddingResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmbeddingResponse) ProtoMessage() {}

func (x *EmbeddingResponse) ProtoReflect() protoreflect.Message {
	mi := &file_emb_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmbeddingResponse.ProtoReflect.Descriptor instead.
func (*EmbeddingResponse) Descriptor() ([]byte, []int) {
	return file_emb_proto_rawDescGZIP(), []int{4}
}

func (x *EmbeddingResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *EmbeddingResponse) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

var File_emb_proto protoreflect.FileDescriptor

const file_emb_proto_rawDesc = "" +
	"\n" +
	"\temb.proto\x12\x03emb\"w\n" +
	"\x14UserEmbeddingRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x10\n" +
	"\x03bio\x18\x02 \x01(\tR\x03bio\x12\x16\n" +
	"\x06skills\x18\x03 \x03(\tR\x06skills\x12\x1c\n" +
	"\tinterests\x18\x04 \x03(\tR\tinterests\"\xa1\x01\n" +
	"\x17ProjectEmbeddingRequest\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\tR\x06userId\x12\x16\n" +
	"\x06skills\x18\x05 \x03(\tR\x06skills\"=\n" +
	"\x13UpdateStatusRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06status\x18\x02 \x01(\bR\x06status\"(\n" +
	"\x16DeleteEmbeddingRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"?\n" +
	"\x11EmbeddingResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x10\n" +
	"\x03msg\x18\x02 \x01(\tR\x03msg2\xbc\x02\n" +
	"\x14UserEmbeddingService\x12H\n" +
	"\x13CreateUserEmbedding\x12\x19.emb.UserEmbeddingRequest\x1a\x16.emb.EmbeddingResponse\x12H\n" +
	"\x13UpdateUserEmbedding\x12\x19.emb.UserEmbeddingRequest\x1a\x16.emb.EmbeddingResponse\x12D\n" +
	"\x10UpdateUserStatus\x12\x18.emb.UpdateStatusRequest\x1a\x16.emb.EmbeddingResponse\x12J\n" +
	"\x13DeleteUserEmbedding\x12\x1b.emb.DeleteEmbeddingRequest\x1a\x16.emb.EmbeddingResponse2\xd1\x02\n" +
	"\x17ProjectEmbeddingService\x12N\n" +
	"\x16CreateProjectEmbedding\x12\x1c.emb.ProjectEmbeddingRequest\x1a\x16.emb.EmbeddingResponse\x12N\n" +
	"\x16UpdateProjectEmbedding\x12\x1c.emb.ProjectEmbeddingRequest\x1a\x16.emb.EmbeddingResponse\x12G\n" +
	"\x13UpdateProjectStatus\x12\x18.emb.UpdateStatusRequest\x1a\x16.emb.EmbeddingResponse\x12M\n" +
	"\x16DeleteProjectEmbedding\x12\x1b.emb.DeleteEmbeddingRequest\x1a\x16.emb.EmbeddingResponseB\aZ\x05./embb\x06proto3"

var (
	file_emb_proto_rawDescOnce sync.Once
	file_emb_proto_rawDescData []byte
)

func file_emb_proto_rawDescGZIP() []byte {
	file_emb_proto_rawDescOnce.Do(func() {
		file_emb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_emb_proto_rawDesc), len(file_emb_proto_rawDesc)))
	})
	return file_emb_proto_rawDescData
}

var file_emb_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_emb_proto_goTypes = []any{
	(*UserEmbeddingRequest)(nil),    // 0: emb.UserEmbeddingRequest
	(*ProjectEmbeddingRequest)(nil), // 1: emb.ProjectEmbeddingRequest
	(*UpdateStatusRequest)(nil),     // 2: emb.UpdateStatusRequest
	(*DeleteEmbeddingRequest)(nil),  // 3: emb.DeleteEmbeddingRequest
	(*EmbeddingResponse)(nil),       // 4: emb.EmbeddingResponse
}
var file_emb_proto_depIdxs = []int32{
	0, // 0: emb.UserEmbeddingService.CreateUserEmbedding:input_type -> emb.UserEmbeddingRequest
	0, // 1: emb.UserEmbeddingService.UpdateUserEmbedding:input_type -> emb.UserEmbeddingRequest
	2, // 2: emb.UserEmbeddingService.UpdateUserStatus:input_type -> emb.UpdateStatusRequest
	3, // 3: emb.UserEmbeddingService.DeleteUserEmbedding:input_type -> emb.DeleteEmbeddingRequest
	1, // 4: emb.ProjectEmbeddingService.CreateProjectEmbedding:input_type -> emb.ProjectEmbeddingRequest
	1, // 5: emb.ProjectEmbeddingService.UpdateProjectEmbedding:input_type -> emb.ProjectEmbeddingRequest
	2, // 6: emb.ProjectEmbeddingService.UpdateProjectStatus:input_type -> emb.UpdateStatusRequest
	3, // 7: emb.ProjectEmbeddingService.DeleteProjectEmbedding:input_type -> emb.DeleteEmbeddingRequest
	4, // 8: emb.UserEmbeddingService.CreateUserEmbedding:output_type -> emb.EmbeddingResponse
	4, // 9: emb.UserEmbeddingService.UpdateUserEmbedding:output_type -> emb.EmbeddingResponse
	4, // 10: emb.UserEmbeddingService.UpdateUserStatus:output_type -> emb.EmbeddingResponse
	4, // 11: emb.UserEmbeddingService.DeleteUserEmbedding:output_type -> emb.EmbeddingResponse
	4, // 12: emb.ProjectEmbeddingService.CreateProjectEmbedding:output_type -> emb.EmbeddingResponse
	4, // 13: emb.ProjectEmbeddingService.UpdateProjectEmbedding:output_type -> emb.EmbeddingResponse
	4, // 14: emb.ProjectEmbeddingService.UpdateProjectStatus:output_type -> emb.EmbeddingResponse
	4, // 15: emb.ProjectEmbeddingService.DeleteProjectEmbedding:output_type -> emb.EmbeddingResponse
	8, // [8:16] is the sub-list for method output_type
	0, // [0:8] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_emb_proto_init() }
func file_emb_proto_init() {
	if File_emb_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_emb_proto_rawDesc), len(file_emb_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   2,
		},
		GoTypes:           file_emb_proto_goTypes,
		DependencyIndexes: file_emb_proto_depIdxs,
		MessageInfos:      file_emb_proto_msgTypes,
	}.Build()
	File_emb_proto = out.File
	file_emb_proto_goTypes = nil
	file_emb_proto_depIdxs = nil
}
```

## File: proto/emb.proto
```protobuf
syntax = "proto3";

package emb;

option go_package = "./emb";

service UserEmbeddingService {
  rpc CreateUserEmbedding(UserEmbeddingRequest) returns (EmbeddingResponse);
  rpc UpdateUserEmbedding(UserEmbeddingRequest) returns (EmbeddingResponse);
  rpc UpdateUserStatus(UpdateStatusRequest) returns (EmbeddingResponse);
  rpc DeleteUserEmbedding(DeleteEmbeddingRequest) returns (EmbeddingResponse);
}

service ProjectEmbeddingService {
  rpc CreateProjectEmbedding(ProjectEmbeddingRequest) returns (EmbeddingResponse);
  rpc UpdateProjectEmbedding(ProjectEmbeddingRequest) returns (EmbeddingResponse);
  rpc UpdateProjectStatus(UpdateStatusRequest) returns (EmbeddingResponse);
  rpc DeleteProjectEmbedding(DeleteEmbeddingRequest) returns (EmbeddingResponse);
}

message UserEmbeddingRequest {
  string user_id = 1;
  string bio = 2;
  repeated string skills = 3;
  repeated string interests = 4;
}

message ProjectEmbeddingRequest {
  string project_id = 1;
  string title = 2;
  string description = 3;
  string user_id = 4;
  repeated string skills = 5;
}

message UpdateStatusRequest {
  string id = 1;
  bool status = 2;
}

message DeleteEmbeddingRequest {
  string id = 1;
}

message EmbeddingResponse {
  bool success = 1;
  string msg = 2;
}
```

## File: proto/rec.proto
```protobuf
syntax="proto3";

package rec;

option go_package = "./rec";

service RecommendationService {
  rpc ProjectRecommendation(RecommendationRequest) returns (RecommendationResponse);
  rpc UserRecommendation(RecommendationRequest) returns (RecommendationResponse);
}

message RecommendationRequest {
  string id = 1;
}

message RecommendationResponse {
  bool success = 1;
  map<string, float> res = 2;
}
```

## File: rec/rec.pb.go
```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.12.4
// source: rec.proto

package rec

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RecommendationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecommendationRequest) Reset() {
	*x = RecommendationRequest{}
	mi := &file_rec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecommendationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecommendationRequest) ProtoMessage() {}

func (x *RecommendationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_rec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecommendationRequest.ProtoReflect.Descriptor instead.
func (*RecommendationRequest) Descriptor() ([]byte, []int) {
	return file_rec_proto_rawDescGZIP(), []int{0}
}

func (x *RecommendationRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type RecommendationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Res           map[string]float32     `protobuf:"bytes,2,rep,name=res,proto3" json:"res,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed32,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecommendationResponse) Reset() {
	*x = RecommendationResponse{}
	mi := &file_rec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecommendationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecommendationResponse) ProtoMessage() {}

func (x *RecommendationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_rec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecommendationResponse.ProtoReflect.Descriptor instead.
func (*RecommendationResponse) Descriptor() ([]byte, []int) {
	return file_rec_proto_rawDescGZIP(), []int{1}
}

func (x *RecommendationResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RecommendationResponse) GetRes() map[string]float32 {
	if x != nil {
		return x.Res
	}
	return nil
}

var File_rec_proto protoreflect.FileDescriptor

const file_rec_proto_rawDesc = "" +
	"\n" +
	"\trec.proto\x12\x03rec\"'\n" +
	"\x15RecommendationRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\xa2\x01\n" +
	"\x16RecommendationResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x126\n" +
	"\x03res\x18\x02 \x03(\v2$.rec.RecommendationResponse.ResEntryR\x03res\x1a6\n" +
	"\bResEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x02R\x05value:\x028\x012\xb8\x01\n" +
	"\x15RecommendationService\x12P\n" +
	"\x15ProjectRecommendation\x12\x1a.rec.RecommendationRequest\x1a\x1b.rec.RecommendationResponse\x12M\n" +
	"\x12UserRecommendation\x12\x1a.rec.RecommendationRequest\x1a\x1b.rec.RecommendationResponseB\aZ\x05./recb\x06proto3"

var (
	file_rec_proto_rawDescOnce sync.Once
	file_rec_proto_rawDescData []byte
)

func file_rec_proto_rawDescGZIP() []byte {
	file_rec_proto_rawDescOnce.Do(func() {
		file_rec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_rec_proto_rawDesc), len(file_rec_proto_rawDesc)))
	})
	return file_rec_proto_rawDescData
}

var file_rec_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_rec_proto_goTypes = []any{
	(*RecommendationRequest)(nil),  // 0: rec.RecommendationRequest
	(*RecommendationResponse)(nil), // 1: rec.RecommendationResponse
	nil,                            // 2: rec.RecommendationResponse.ResEntry
}
var file_rec_proto_depIdxs = []int32{
	2, // 0: rec.RecommendationResponse.res:type_name -> rec.RecommendationResponse.ResEntry
	0, // 1: rec.RecommendationService.ProjectRecommendation:input_type -> rec.RecommendationRequest
	0, // 2: rec.RecommendationService.UserRecommendation:input_type -> rec.RecommendationRequest
	1, // 3: rec.RecommendationService.ProjectRecommendation:output_type -> rec.RecommendationResponse
	1, // 4: rec.RecommendationService.UserRecommendation:output_type -> rec.RecommendationResponse
	3, // [3:5] is the sub-list for method output_type
	1, // [1:3] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_rec_proto_init() }
func file_rec_proto_init() {
	if File_rec_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_rec_proto_rawDesc), len(file_rec_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_rec_proto_goTypes,
		DependencyIndexes: file_rec_proto_depIdxs,
		MessageInfos:      file_rec_proto_msgTypes,
	}.Build()
	File_rec_proto = out.File
	file_rec_proto_goTypes = nil
	file_rec_proto_depIdxs = nil
}
```

## File: schema/rec.go
```go
package schema

type RecResponse struct {
	Res map[string]float32
}

type RecProjectResponse struct {
	Project ProjectResponse
	Score   float32
}

type RecProfileResponse struct {
	User  UserProfileResponse
	Score float32
}
```

## File: README.md
```markdown
****FINDME****
An app for developers to work on a contributive project
The app is live here
```

## File: core/conf.go
```go
package core

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	norm "math/rand"

	"golang.org/x/crypto/bcrypt"
)

const (
	charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-+_?,."
	otpset  = "1234567890"
)

type CustomMessage struct {
	Code    int
	Message string
}

func (cm *CustomMessage) Error() string {
	return fmt.Sprintf(" [CM] An error occured -> %s", cm.Message)
}

// HashPassword -> hash the password provided
func HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(hashedPassword), err
}

// VerifyHashedPassword -> Verifies a password with it's hash
func VerifyHashedPassword(password, hashedPassword string) error {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	return err
}

// GenerateState -> Generate state (Github signup)
func GenerateState() (string, error) {
	b := make([]byte, 16)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(b), nil
}

// GenerateOTP -> Generate OTP
func GenerateOTP() string {
	b := make([]byte, 6)
	for i := range b {
		b[i] = otpset[norm.Intn(len(otpset))]
	}
	return string(b)
}

// GenerateUsername -> Generates a new username from existing one
func GenerateUsername(username string) string {
	b := make([]byte, 9)
	for i := range b {
		b[i] = charset[norm.Intn(len(charset))]
	}
	return username + "_" + string(b)
}
```

## File: core/msg.go
```go
package core

import (
	"log"

	"findme/schema"

	"github.com/gorilla/websocket"
)

type Client struct {
	Conn     *websocket.Conn
	UserID   string
	ChatID   string
	SendChan chan *schema.ViewMessage
}

type BroadcastMessage struct {
	ChatID string
	Data   *schema.ViewMessage
}

type ChatHub struct {
	Room       map[string]map[*Client]bool
	Register   chan *Client
	UnRegister chan *Client
	Broadcast  chan *BroadcastMessage
}

func NewClient(conn *websocket.Conn, uid, cid string, data chan *schema.ViewMessage) *Client {
	return &Client{
		Conn:     conn,
		UserID:   uid,
		ChatID:   cid,
		SendChan: data,
	}
}

func NewChatHub(buffersize int) *ChatHub {
	return &ChatHub{
		Room:       make(map[string]map[*Client]bool),
		Register:   make(chan *Client),
		UnRegister: make(chan *Client),
		Broadcast:  make(chan *BroadcastMessage, buffersize),
	}
}

func (c *Client) ReadPump(hub *ChatHub) {
	defer func() {
		hub.UnRegister <- c
		_ = c.Conn.Close()
	}()

	var msg schema.ViewMessage
	for {
		if err := c.Conn.ReadJSON(&msg); err != nil {
			break
		}

		hub.Broadcast <- &BroadcastMessage{
			Data:   &msg,
			ChatID: c.ChatID,
		}
	}
}

func (c *Client) WritePump() {
	defer c.Conn.Close()

	for msg := range c.SendChan {
		if err := c.Conn.WriteJSON(msg); err != nil {
			break
		}
	}
}

func (h *ChatHub) Run() {
	log.Println("[Chat HUB] THe Chat HUB is up and running")
	for {
		select {
		case c := <-h.Register:
			if h.Room[c.ChatID] == nil {
				h.Room[c.ChatID] = make(map[*Client]bool)
			}
			h.Room[c.ChatID][c] = true
		case c := <-h.UnRegister:
			if room := h.Room[c.ChatID]; room != nil {
				delete(room, c)
				close(c.SendChan)
			}
		case msg := <-h.Broadcast:
			room := h.Room[msg.ChatID]
			for c := range room {
				select {
				case c.SendChan <- msg.Data:
				default:
					close(c.SendChan)
					delete(room, c)
				}
			}
		}
	}
}
```

## File: core/rec.go
```go
package core

import (
	"context"
	"log"
	"time"

	"findme/rec"
	"findme/schema"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type Recommendation interface {
	QueueUserRecommendation(ID string)
	QueueProjectRecommendation(ID string)
	GetRecommendation(ID string, jobType RecommendationJobType) (*schema.RecResponse, error)
}

type RecommendationJobType int

const (
	UserRecommendation RecommendationJobType = iota
	ProjectRecommendation
)

type RecommendationJob struct {
	Type        RecommendationJobType
	ID          string
	Attempts    int
	MaxAttempts int
}

type RecommendationHub struct {
	Jobs     chan *RecommendationJob
	Quit     chan bool
	Workers  int
	GPRCAddr string
}

func NewRecommendationHub(workers, queuesize int, addr string) *RecommendationHub {
	return &RecommendationHub{
		Jobs:     make(chan *RecommendationJob, queuesize),
		Quit:     make(chan bool),
		Workers:  workers,
		GPRCAddr: addr,
	}
}

func (r *RecommendationHub) Run() {
	for range r.Workers {
		go r.WorkerPool()
	}
	log.Println("[gRPC Recommendation] The Recommendation Hub is up and running")
}

func (r *RecommendationHub) WorkerPool() {
	conn, err := grpc.NewClient(r.GPRCAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Println("[gRPC Recommendation] Failed to connect to grpc with address -> ", r.GPRCAddr)
	}

	defer conn.Close()

	client := rec.NewRecommendationServiceClient(conn)

	for {
		select {
		case job := <-r.Jobs:
			_, err := r.ProcessJob(job, client)
			if err != nil {
				job.Attempts++
				if job.Attempts <= job.MaxAttempts {
					waitTime := time.Duration(job.Attempts*3) * time.Second
					go func(job *RecommendationJob, delay time.Duration) {
						time.Sleep(delay)
						r.Jobs <- job
					}(job, waitTime)
				}
			}
		case <-r.Quit:
			return
		}
	}
}

func (r *RecommendationHub) ProcessJob(job *RecommendationJob, client rec.RecommendationServiceClient) (*schema.RecResponse, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*30)
	defer cancel()

	var err error
	res := &schema.RecResponse{}
	recRes := &rec.RecommendationResponse{}

	switch job.Type {
	case UserRecommendation:
		recRes, err = client.UserRecommendation(ctx, &rec.RecommendationRequest{
			Id: job.ID,
		})
	case ProjectRecommendation:
		recRes, err = client.ProjectRecommendation(ctx, &rec.RecommendationRequest{
			Id: job.ID,
		})
	}

	if recRes != nil {
		res.Res = recRes.Res
	}

	return res, err
}

func (r *RecommendationHub) QueueUserRecommendation(projectID string) {
	r.Jobs <- &RecommendationJob{
		Type:        UserRecommendation,
		ID:          projectID,
		MaxAttempts: 3,
	}
}

func (r *RecommendationHub) QueueProjectRecommendation(userID string) {
	r.Jobs <- &RecommendationJob{
		Type:        ProjectRecommendation,
		ID:          userID,
		MaxAttempts: 3,
	}
}

func (r *RecommendationHub) GetRecommendation(ID string, jobType RecommendationJobType) (*schema.RecResponse, error) {
	conn, err := grpc.NewClient(r.GPRCAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Println("[gRPC Recommendation] Failed to connect to grpc with address -> ", r.GPRCAddr)
	}

	defer conn.Close()

	client := rec.NewRecommendationServiceClient(conn)

	job := &RecommendationJob{
		Type:        jobType,
		ID:          ID,
		MaxAttempts: 1,
	}

	res, err := r.ProcessJob(job, client)
	if err != nil {
		return nil, err
	}
	return res, nil
}
```

## File: model/transc.go
```go
package model

import (
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type Subscriptions struct {
	GormModel
	UserID        string
	TransactionID string
	Status        string
	PlanName      string
	StartDate     time.Time
	EndDate       time.Time

	User        *User         `gorm:"foreignKey:UserID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Transaction *Transactions `gorm:"foreignKey:TransactionID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type Transactions struct {
	GormModel
	UserID      string
	Amount      int64
	Curency     string `gorm:"default:'NGN'"`
	PaystackRef string `gorm:"column:paystackref;uniqueIndex"`
	Status      string `gorm:"default:'pending'"`
	Channel     string
	PaidAt      *time.Time

	User *User `gorm:"foreignKey:UserID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type Plan struct {
	GormModel
	PayStackRef string `gorm:"column:paystackref;uniqueIndex"`
}

const (
	PaystackChargeSuccess        = "charge.success"
	PaystackInvoiceUpdate        = "invoice.update"
	PaystackSubscriptionCreate   = "subscription.create"
	PaystackSubscriptionNotRenew = "subscription.not_renew"
)

func (s *Subscriptions) BeforeCreate(tx *gorm.DB) (err error) {
	if s.ID == "" {
		s.ID = uuid.NewString()
	}

	return err
}

func (t *Transactions) BeforeCreate(tx *gorm.DB) (err error) {
	if t.ID == "" {
		t.ID = uuid.NewString()
	}

	return err
}
```

## File: nginx/conf.d/app.conf
```
server {
  listen 80;
  # server_name findmeapi.duckdns.org;
  server_name _;

  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
    try_files $uri =404;
  }

  location /health {
    proxy_pass http://app/health;
    access_log off;
  }

  location /api/ {
    limit_req zone=api_limit burst=20 nodelay;

    proxy_pass http://app;
    proxy_http_version 1.1;
    
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
  }

  location / {
    proxy_pass http://app;
    proxy_http_version 1.1;
    
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
  }
}
```

## File: Dockerfile
```dockerfile
FROM golang:1.24-alpine as builder

RUN apk add --no-cache git

WORKDIR /app

COPY go.mod  .

COPY go.sum .

RUN go mod download

COPY . .

RUN GOMAXPROCS=1 GOMEMLIMIT=450MiB go build -o findme .


FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /app

COPY --from=builder /app/findme .

EXPOSE 8080

CMD [ "./findme" ]
```

## File: core/emb.go
```go
package core

import (
	"context"
	"log"
	"time"

	"findme/emb"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type Embedding interface {
	QueueUserCreate(id, bio string, skills, interests []string)
	QueueUserUpdate(id, bio string, skills, interest []string)
	QueueUserUpdateStatus(id string, status bool)
	QueueUserDelete(id string)
	QueueProjectCreate(id, title, description, uid string, skills []string)
	QueueProjectUpdate(id, title, description string, skills []string)
	QueueProjectUpdateStatus(id string, status bool)
	QueueProjectDelete(id string)
}

type EmbeddingJobType int

const (
	CreateUserEmbedding EmbeddingJobType = iota
	UpdateUserEmbedding
	UpdateUserStatus
	DeleteUserEmbedding
	CreateProjectEmbedding
	UpdateProjectEmbedding
	UpdateProjectStatus
	DeleteProjectEmbedding
)

type UserEmbedding struct {
	ID        string
	Bio       string
	Status    bool
	Skills    []string
	Interests []string
}

type ProjectEmbedding struct {
	ID          string
	Title       string
	Description string
	Status      bool
	Skills      []string
}

type EmbeddingJob struct {
	Type        EmbeddingJobType
	Attempts    int
	MaxAttempts int

	// User fields
	User *UserEmbedding

	// Project fields
	Project *ProjectEmbedding
}

type EmbeddingHub struct {
	Jobs       chan *EmbeddingJob
	Quit       chan bool
	WorkerPool int
	GRPCADDR   string
}

func NewEmbeddingHub(queueSize, workers int, addr string) *EmbeddingHub {
	return &EmbeddingHub{
		Jobs:       make(chan *EmbeddingJob, queueSize),
		Quit:       make(chan bool),
		WorkerPool: workers,
		GRPCADDR:   addr,
	}
}

func (e *EmbeddingHub) Run() {
	for range e.WorkerPool {
		go e.Worker()
	}
	log.Println("[EmbeddingHub] The Embedding hub is up and running")
}

func (e *EmbeddingHub) Worker() {
	conn, err := grpc.NewClient(e.GRPCADDR, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Printf("[EmbeddingHub] Failed to connect to ML service -> %v", err.Error())
		return
	}

	defer conn.Close()

	userClient := emb.NewUserEmbeddingServiceClient(conn)
	projectClient := emb.NewProjectEmbeddingServiceClient(conn)

	for {
		select {
		case job := <-e.Jobs:
			err := e.ProcessJob(job, userClient, projectClient)
			if err != nil {
				job.Attempts++
				if job.Attempts <= job.MaxAttempts {
					waitTime := time.Duration(job.Attempts*3) * time.Second
					log.Printf("[EmbeddingJob] Failed, err -> %v retrying in %v", err, waitTime)

					go func(j *EmbeddingJob, delay time.Duration) {
						time.Sleep(delay)
						e.Jobs <- j
					}(job, waitTime)
				}
			}
		case <-e.Quit:
			return
		}
	}
}

func (e *EmbeddingHub) ProcessJob(job *EmbeddingJob, userClient emb.UserEmbeddingServiceClient, projectClient emb.ProjectEmbeddingServiceClient) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	var err error

	switch job.Type {
	case CreateUserEmbedding:
		_, err = userClient.CreateUserEmbedding(ctx, &emb.UserEmbeddingRequest{
			UserId:    job.User.ID,
			Bio:       job.User.Bio,
			Skills:    job.User.Skills,
			Interests: job.User.Interests,
		})
	case UpdateUserEmbedding:
		_, err = userClient.UpdateUserEmbedding(ctx, &emb.UserEmbeddingRequest{
			UserId:    job.User.ID,
			Bio:       job.User.Bio,
			Skills:    job.User.Skills,
			Interests: job.User.Interests,
		})
	case UpdateUserStatus:
		_, err = userClient.UpdateUserStatus(ctx, &emb.UpdateStatusRequest{
			Id:     job.User.ID,
			Status: job.User.Status,
		})
	case DeleteUserEmbedding:
		_, err = userClient.DeleteUserEmbedding(ctx, &emb.DeleteEmbeddingRequest{
			Id: job.User.ID,
		})
	case CreateProjectEmbedding:
		_, err = projectClient.CreateProjectEmbedding(ctx, &emb.ProjectEmbeddingRequest{
			ProjectId:   job.Project.ID,
			Title:       job.Project.Title,
			Description: job.Project.Description,
			Skills:      job.Project.Skills,
			UserId:      job.User.ID,
		})
	case UpdateProjectEmbedding:
		_, err = projectClient.UpdateProjectEmbedding(ctx, &emb.ProjectEmbeddingRequest{
			ProjectId:   job.Project.ID,
			Title:       job.Project.Title,
			Description: job.Project.Description,
			Skills:      job.Project.Skills,
		})
	case UpdateProjectStatus:
		_, err = projectClient.UpdateProjectStatus(ctx, &emb.UpdateStatusRequest{
			Id:     job.Project.ID,
			Status: job.Project.Status,
		})
	case DeleteProjectEmbedding:
		_, err = projectClient.DeleteProjectEmbedding(ctx, &emb.DeleteEmbeddingRequest{
			Id: job.Project.ID,
		})
	}
	return err
}

func (e *EmbeddingHub) QueueUserCreate(id, bio string, skills, interests []string) {
	e.Jobs <- &EmbeddingJob{
		Type:        CreateUserEmbedding,
		MaxAttempts: 3,
		User: &UserEmbedding{
			ID:        id,
			Bio:       bio,
			Skills:    skills,
			Interests: interests,
		},
	}
}

func (e *EmbeddingHub) QueueUserUpdate(id, bio string, skills, interest []string) {
	e.Jobs <- &EmbeddingJob{
		Type:        UpdateUserEmbedding,
		MaxAttempts: 3,
		User: &UserEmbedding{
			ID:        id,
			Bio:       bio,
			Skills:    skills,
			Interests: interest,
		},
	}
}

func (e *EmbeddingHub) QueueUserUpdateStatus(id string, status bool) {
	e.Jobs <- &EmbeddingJob{
		Type:        UpdateUserStatus,
		MaxAttempts: 2,
		User: &UserEmbedding{
			ID:     id,
			Status: status,
		},
	}
}

func (e *EmbeddingHub) QueueUserDelete(id string) {
	e.Jobs <- &EmbeddingJob{
		Type:        DeleteUserEmbedding,
		MaxAttempts: 3,
		User: &UserEmbedding{
			ID: id,
		},
	}
}

func (e *EmbeddingHub) QueueProjectCreate(id, title, description, uid string, skills []string) {
	e.Jobs <- &EmbeddingJob{
		Type:        CreateProjectEmbedding,
		MaxAttempts: 3,
		Project: &ProjectEmbedding{
			ID:          id,
			Title:       title,
			Description: description,
			Skills:      skills,
		},
		User: &UserEmbedding{
			ID: uid,
		},
	}
}

func (e *EmbeddingHub) QueueProjectUpdate(id, title, description string, skills []string) {
	e.Jobs <- &EmbeddingJob{
		Type:        UpdateProjectEmbedding,
		MaxAttempts: 3,
		Project: &ProjectEmbedding{
			ID:          id,
			Title:       title,
			Description: description,
			Skills:      skills,
		},
	}
}

func (e *EmbeddingHub) QueueProjectUpdateStatus(id string, status bool) {
	e.Jobs <- &EmbeddingJob{
		Type:        UpdateProjectStatus,
		MaxAttempts: 2,
		Project: &ProjectEmbedding{
			ID:     id,
			Status: status,
		},
	}
}

func (e *EmbeddingHub) QueueProjectDelete(id string) {
	e.Jobs <- &EmbeddingJob{
		Type:        DeleteProjectEmbedding,
		MaxAttempts: 3,
		Project: &ProjectEmbedding{
			ID: id,
		},
	}
}
```

## File: test/unit/schemas_test.go
```go
package unit

import "findme/schema"

type ProjectResponse struct {
	Message                string `json:"msg"`
	schema.ProjectResponse `json:"project"`
}

type ProjectApplicationResponse struct {
	schema.ViewProjectApplication `json:"project_req"`
}

type ViewMsg struct {
	schema.ViewMessage `json:"msg"`
}

type ViewChats struct {
	schema.ViewChat `json:"msg"`
}

type Token struct {
	Token string `json:"token"`
}

type ViewFriendReq struct {
	schema.FriendReqStatus `json:"req"`
}

type ViewAllFriendReq struct {
	SentReq []schema.FriendReqStatus `json:"sent_req"`
	RecReq  []schema.FriendReqStatus `json:"rec_req"`
}

type GetChatID struct {
	Msg    string `json:"msg"`
	ChatID string `json:"chat_id"`
}
```

## File: test/unit/transc_test.go
```go
package unit

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
)

// MOCK tests for the transaction service

func TestGetTransactions(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/transc/view", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestInitializeTransactions(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/transc/initialize", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestVerifyTranscWebhook(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPost, "/api/transc/webhook", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestUpdateSubscriptionCard(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/transc/update-card", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestCancelSubscription(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/transc/cancel-sub", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestEnableSubscription(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/transc/enable-sub", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestViewPlans(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/transc/view/plans", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}
```

## File: database/redis.go
```go
package database

import (
	"context"
	"log"
	"os"
	"time"

	"github.com/redis/go-redis/v9"
)

// ConnectRedis -> Connection to redis
func ConnectRedis() *redis.Client {
	redisClient := redis.NewClient(
		&redis.Options{
			Addr:     os.Getenv("REDIS_ADDR"),
			Password: os.Getenv("REDIS_PASS"),
			DB:       0,
		},
	)

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if _, err := redisClient.Ping(ctx).Result(); err != nil {
		log.Fatalf("[ERROR] [RDB] Could not connect to redis -> %v", err)
	}

	log.Println("[INFO] [RDB] Connected to the redis client successfully.")
	return redisClient
}
```

## File: nginx/nginx.conf
```
worker_processes 1;
pid /var/run/nginx.pid;

events {
  worker_connections 1024;
  use epoll;
}

http {

  # Basic Settings
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;

  # MIME types
  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  # Logging
  log_format main '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';
  access_log /var/log/nginx/access.log main;
  error_log /var/log/nginx/error.log warn;

  # Gzip compression
  gzip on;
  gzip_vary on;
  gzip_proxied any;
  gzip_comp_level 6;
  gzip_http_version 1.1;
  gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;


  # Rate Limiting 
  limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
  limit_req_status 429;

  upstream app {
    server app:8080;
    keepalive 32;
  }

  # include /etc/nginx/conf.d/app.conf;
  include /etc/nginx/conf.d/cert.conf;

}
```

## File: handlers/realtime.go
```go
package handlers

import (
	"net/http"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

// WSChat godoc
// @Summary  A websocket message hub for real-time chatting
// @Description An endpoint that upgrades client to a websocket connection for real-time chatting experience
// @Tags Msg
// @Accept json
// @Produce json
// @Param id query string true "Chat ID"
// @Security BearerAuth
// @Success 101 {string} string "Switching Protocols"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/msg/ws/chat [get]
func (s *Service) WSChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	cid := ctx.Query("id")
	if !model.IsValidUUID(cid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid chat id."})
		return
	}

	conn, err := upgrade.Upgrade(ctx.Writer, ctx.Request, nil)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to create a websocket connection."})
		return
	}

	client := &core.Client{
		Conn:     conn,
		UserID:   uid,
		ChatID:   cid,
		SendChan: make(chan *schema.ViewMessage),
	}

	s.Chat.Register <- client

	go client.ReadPump(s.Chat)
	go client.WritePump()
}
```

## File: model/skills.go
```go
package model

import (
	"strings"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type Skill struct {
	GormModel
	Name string `gorm:"unique;not null"`
}

func (s *Skill) BeforeCreate(tx *gorm.DB) (err error) {
	s.Name = strings.ToLower(s.Name)
	if s.ID == "" {
		s.ID = uuid.NewString()
	}

	return err
}
```

## File: schema/transc.go
```go
package schema

import (
	"time"
)

type TransactionResponse struct {
	ID      string
	Amount  int64
	Channel string
	Status  string
	PaidAt  time.Time
}

type InitTransaction struct {
	Status bool `json:"status" binding:"required"`
	Data   struct {
		AuthorizationURL string `json:"authorization_url" binding:"omitempty"`
		AccessCode       string `json:"access_code" binding:"omitempty"`
		Reference        string `json:"reference" binding:"omitempty"`
	} `json:"data" binding:"required"`
}

type PaystackEvent struct {
	Event string `json:"event"`
	Data  struct {
		Status        string    `json:"status"`
		Reference     string    `json:"reference"`
		Channel       string    `json:"channel"`
		Currency      string    `json:"currency"`
		Amount        int64     `json:"amount"`
		SubCode       string    `json:"subscription_code"`
		EmailToken    string    `json:"email_token"`
		PaidAt        time.Time `json:"paid_at"`
		Paid          int       `json:"paid"`
		Authorization struct {
			AuthCode string `json:"authorization_code"`
			Last4    string `json:"last4"`
			Brand    string `json:"brand"`
			ExpMonth string `json:"exp_month"`
			ExpYear  string `json:"exp_year"`
		} `json:"authorization"`
		Customer struct {
			CusCode string `json:"customer_code"`
			Email   string `json:"email"`
		} `json:"customer"`
		Transaction struct {
			Reference string `json:"reference"`
		} `json:"transaction"`
		Subscription struct {
			Status          string    `json:"status"`
			SubCode         string    `json:"subscription_code"`
			EmailToken      string    `json:"email_token"`
			NextPaymentDate time.Time `json:"next_payment_date"`
		} `json:"subscription"`
		Plan struct {
			Name string
		} `json:"plan"`
		Metadata any `json:"metadata"`
	} `json:"data"`
}

type PaystackUpdateCard struct {
	Status  bool   `json:"status" binding:"required"`
	Message string `json:"message" binding:"required"`
	Data    struct {
		Link string `json:"link" binding:"omitempty"`
	} `json:"data" binding:"omitempty"`
}

type PaystackViewSub struct {
	Status bool `json:"status" binding:"required"`
	Data   struct {
		EmailToken string `json:"email_token" binding:"omitempty"`
	} `json:"data" binding:"omitempty"`
}

type PaystackSubResp struct {
	Status  bool   `json:"status" binding:"required"`
	Message string `json:"message" binding:"required"`
}

type PaystackViewPlans struct {
	Status  bool   `json:"status" binding:"required"`
	Message string `json:"message" binding:"required"`
	Data    []struct {
		Name     string `json:"name" binding:"required"`
		Interval string `json:"Interval" binding:"required"`
		PlanCode string `json:"plan_code" binding:"omitempty"`
		Currency string `json:"currency" binding:"required"`
		Amount   int64  `json:"amount" binding:"required"`
	} `json:"data" binding:"omitempty"`
}

type ViewPlansResp struct {
	ID       string
	Name     string
	Amount   int64
	Interval string
	Currency string
}

type PaymentInfo struct {
	Last4           string
	Month           string
	Year            string
	Card            string
	NextPaymentDate time.Time
}

type AuthCharge struct {
	Status  bool   `json:"status"`
	Message string `json:"message"`
	Data    struct {
		Status string `json:"status"`
	} `json:"data"`
}

type SubscriptionDetails struct {
	Status  bool   `json:"status"`
	Message string `json:"message"`
	Data    struct {
		Status          string    `json:"status"`
		NextPaymentDate time.Time `json:"next_payment_date"`
	}
}
```

## File: schema/msg.go
```go
// Package schema -> Schema for the app
package schema

import "time"

type NewMessage struct {
	Message string `json:"msg" binding:"required"`
	ChatID  string `json:"chat_id" binding:"required"`
}

type EditMessage struct {
	ID      string `json:"msg_id" binding:"required"`
	Message string `json:"msg" binding:"required"`
}

type ViewMessage struct {
	ID      string    `json:"id"`
	Message string    `json:"msg"`
	UserID  string    `json:"uid"`
	Sent    time.Time `json:"sent"`
	Edited  time.Time `json:"edited"`
}

type ViewChat struct {
	Name    string
	CID     string
	Message []ViewMessage
	Group   bool
}

type AddUserChat struct {
	ChatID string `json:"chat_id" binding:"required"`
	UserID string `json:"user_id" binding:"required"`
}

type RenameChat struct {
	ChatID string `json:"chat_id" binding:"required"`
	Name   string `json:"name" binding:"required"`
}
```

## File: handlers/transc.go
```go
package handlers

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha512"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

// TODO:
// Initiate Subscription
// Handle Automatic Subscription
// Handle Failed Subscription
// Cancel Subscription
// Enable Subscription
// Add a Sub Create email for notifying new sub users
// Maintain a correct card info on user updating card

type Transc interface {
	GetTransactions(ctx *gin.Context)
	InitializeTransaction(ctx *gin.Context)
	UpdateSubscriptionCard(ctx *gin.Context)
	CancelSubscription(ctx *gin.Context)
	EnableSubscription(ctx *gin.Context)
	ViewPlans(ctx *gin.Context)
	VerifyTranscWebhook(ctx *gin.Context)
	RetryFailedPayment(ctx *gin.Context)
}

type TranscService struct {
	Email     core.Email
	DB        core.DB
	RDB       core.Cache
	SecretKey string
	Client    *http.Client
}

func NewTranscService(db core.DB, rdb core.Cache, email core.Email, secret string, client *http.Client) *TranscService {
	return &TranscService{DB: db, RDB: rdb, Email: email, SecretKey: secret, Client: client}
}

// GetTransactions godoc
// @Summary   Retrieves the transactions for a user
// @Description An endpoint that retrieves all the transactions of the current user
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocTranscResposne "Transactions retrieved"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/transc/view [get]
func (t *TranscService) GetTransactions(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := t.DB.FetchUserPreloadT(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var response []schema.TransactionResponse

	for _, transc := range user.Transactions {
		response = append(response, schema.TransactionResponse{
			ID:      transc.ID,
			Amount:  transc.Amount,
			Channel: transc.Channel,
			Status:  transc.Status,
			PaidAt:  *transc.PaidAt,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"transactions": response})
}

// InitializeTransaction godoc
// @Summary An endpoint for initializing a transaction on paystack
// @Description An endpoint for initializing a transaction on paystack to receive a checkout url for payment
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param amount query string true "amount"
// @Param plan query string true "plan"
// @Success 200 {object} schema.DocInitTranscResponse "Success"
// @Failure 400 {object} schema.DocNormalResponse "Bad Query"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "Bad Gateway"
// @Router /api/transc/initialize [get]
func (t *TranscService) InitializeTransaction(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	amount, plan := ctx.Query("amount"), ctx.Query("plan")
	if amount == "" || plan == "" {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Transaction amount or plan not in query."})
		return
	}

	var user model.User
	if err := t.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	payload := map[string]any{
		"email":  user.Email,
		"amount": amount,
		"plan":   plan,
		// "channels": []string{"card"},
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "https://api.paystack.co/transaction/initialize", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+t.SecretKey)
	req.Header.Set("Content-Type", "application/json")

	resp, err := t.Client.Do(req)
	if err != nil || resp.StatusCode != http.StatusOK {
		log.Println("[TRANSACTION] Failed to initialize paystack transaction, err -> ", err)
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Failed to initialize paystack transaction"})
		return
	}

	defer resp.Body.Close()

	var paystack schema.InitTransaction

	data, _ := io.ReadAll(resp.Body)

	if err := json.Unmarshal(data, &paystack); err != nil {
		log.Println("[TRANSACTION] Failed to unmarshal the response of the paystack init transaction, err -> ", err)
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse paystack response"})
	}

	if !paystack.Status || paystack.Data.AuthorizationURL == "" || paystack.Data.AccessCode == "" || paystack.Data.Reference == "" {
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Unable to retrieve checkout url or access code from paystack"})
		return
	}
	ctx.JSON(http.StatusOK, gin.H{"uri": paystack.Data.AuthorizationURL, "token": paystack.Data.AccessCode})
}

// VerifyTranscWebhook godoc
// @Summary This is a webhook for the paystack transaction events
// @Description An endpoint for intercepting the paystack webhooks transaction events
// @Tags Transaction
// @Accept json
// @Produce json
// @Success 200 {object} schema.DocNormalResponse "Success"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/transc/webhook [post]
func (t *TranscService) VerifyTranscWebhook(ctx *gin.Context) {
	body, err := io.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Status(http.StatusBadRequest)
		return
	}

	signature := ctx.GetHeader("x-paystack-signature")

	mac := hmac.New(sha512.New, []byte(t.SecretKey))
	mac.Write(body)
	expectedHash := hex.EncodeToString(mac.Sum(nil))

	if !hmac.Equal([]byte(expectedHash), []byte(signature)) {
		ctx.Status(http.StatusUnauthorized)
		return
	}

	var event schema.PaystackEvent
	log.Println(string(body))
	if err := json.Unmarshal(body, &event); err != nil {
		log.Println("[TRANSACTION] An error occured in the webhook for the transaction while parsing payload, err -> ", err.Error())
		ctx.Status(http.StatusUnprocessableEntity)
		return
	}

	var user model.User
	if err := t.DB.SearchUserEmail(&user, event.Data.Customer.Email); err != nil {
		log.Println("[TRANSACTION] Failed to complete transaction as the customer could not be identified, err -> ", err.Error())
		ctx.Status(http.StatusUnauthorized)
		return
	}

	switch event.Event {
	case model.PaystackSubscriptionCreate:
		user.PaystackEmailToken = &event.Data.EmailToken
		user.PaystackSubCode = &event.Data.SubCode
		user.PaystackCusCode = &event.Data.Customer.CusCode
		user.PaystackAuthCode = &event.Data.Authorization.AuthCode

		user.Last4 = &event.Data.Authorization.Last4
		user.CardType = &event.Data.Authorization.Brand
		user.ExpMonth = &event.Data.Authorization.ExpMonth
		user.ExpYear = &event.Data.Authorization.ExpYear

		if err := t.DB.SaveUser(&user); err != nil {
			ctx.Status(http.StatusInternalServerError)
			return
		}

		t.Email.QueueSubscriptionCreate(user.UserName, "", event.Data.Currency, event.Data.Plan.Name, "", user.Email)

		ctx.Status(http.StatusOK)
		return
	case model.PaystackChargeSuccess:

		// Handling charges for updating card and stuff
		if event.Data.Amount == 5000 {
			user.PaystackAuthCode = &event.Data.Authorization.AuthCode

			user.Last4 = &event.Data.Authorization.Last4
			user.CardType = &event.Data.Authorization.Brand
			user.ExpMonth = &event.Data.Authorization.ExpMonth
			user.ExpYear = &event.Data.Authorization.ExpYear

			if err := t.DB.SaveUser(&user); err != nil {
				ctx.Status(http.StatusInternalServerError)
				return
			}

			ctx.Status(http.StatusOK)
			return
		}

		transc := model.Transactions{
			UserID:      user.ID,
			PaystackRef: event.Data.Reference,
			Amount:      event.Data.Amount,
			Status:      event.Data.Status,
			Channel:     event.Data.Channel,
			Curency:     event.Data.Currency,
			PaidAt:      &event.Data.PaidAt,
		}

		isManual := false
		sid := ""

		if event.Data.Metadata != nil {
			if metadata, ok := event.Data.Metadata.(map[string]any); ok {
				if chargeType, exists := metadata["charge_type"]; exists && chargeType == "manual_retry" {
					isManual = true
					if subID, ok := metadata["sub_id"]; ok {
						sid = subID.(string)
					}
				}
			}
		}

		if isManual && model.IsValidUUID(sid) {
			var sub model.Subscriptions
			if err := t.DB.FetchSub(&sub, sid); err != nil {
				log.Println("[TRANSACTION] An error occured while trying to fetch sub for manual retry payment, err -> ", err.Error())
				ctx.Status(http.StatusInternalServerError)
				return
			}

			sub.Status = model.StatusActive
			user.LastSub = &sub.EndDate
			user.NextPaymentDate = user.LastSub

			if err := t.DB.AddTranscSaveSub(&transc, &sub, &user); err != nil {
				ctx.Status(http.StatusInternalServerError)
				return
			}
		} else {
			details, err := t.FetchSubscriptionDetails(*user.PaystackSubCode)
			if err != nil || details == nil {
				ctx.Status(http.StatusInternalServerError)
				return
			}

			sub := model.Subscriptions{
				UserID:    user.ID,
				Status:    model.StatusActive,
				PlanName:  event.Data.Plan.Name,
				StartDate: time.Now(),
				EndDate:   details.Data.NextPaymentDate,
			}

			user.NextPaymentDate = &sub.EndDate
			user.LastSub = user.NextPaymentDate

			if err := t.DB.AddTranscSub(&transc, &sub, &user); err != nil {
				ctx.Status(http.StatusInternalServerError)
				return
			}
		}

		ctx.Status(http.StatusOK)
		return
	case model.PaystackInvoiceUpdate:
		if event.Data.Paid == 0 {
			sub := model.Subscriptions{
				UserID:    user.ID,
				Status:    model.StatusFailed,
				PlanName:  event.Data.Plan.Name,
				StartDate: time.Now(),
				EndDate:   event.Data.Subscription.NextPaymentDate,
			}

			grace := user.LastSub.Add(time.Hour * 24 * 7)
			user.LastSub = &grace

			if err := t.DB.AddFailedSub(&sub, &user); err != nil {
				ctx.Status(http.StatusInternalServerError)
				return
			}

			amount := fmt.Sprintf("%d", event.Data.Amount)
			t.Email.QueueTransactionFailedEmail(user.UserName, amount, event.Data.Currency, event.Data.Plan.Name, "", user.Email)
		}

		ctx.Status(http.StatusOK)
		return
	case model.PaystackSubscriptionNotRenew:
		t.Email.QueueSubscriptionCancelled(user.UserName, user.NextPaymentDate.Format("January 02, 2006"), user.Email)

		user.NextPaymentDate = nil
		if err := t.DB.SaveUser(&user); err != nil {
			ctx.Status(http.StatusInternalServerError)
		}
	default:
		ctx.Status(http.StatusOK)
		return
	}
}

// UpdateSubscriptionCard godoc
// @Summary This is an endpoint for udpating card details on paystack
// @Description This is an endpoint for retrieving link for updating card details used for transaction on paystack
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocUpdateCardSub "Link Generated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "Failed communication with external service"
// @Router /api/transc/update-card [get]
func (t *TranscService) UpdateSubscriptionCard(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := t.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	req, _ := http.NewRequest(http.MethodGet, "https://api.paystack.co/subscription/"+*user.PaystackSubCode+"/manage/link", nil)
	req.Header.Set("Authorization", "Bearer "+t.SecretKey)
	req.Header.Set("Content-Type", "application/json")

	resp, err := t.Client.Do(req)
	if err != nil || resp.StatusCode != http.StatusOK {
		log.Println("[TRANSACTION] An error occured while trying to generate a update card link on paystack, err -> ", err)
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Failed to communicate with paystack"})
		return
	}

	defer resp.Body.Close()
	var card schema.PaystackUpdateCard

	body, _ := io.ReadAll(resp.Body)

	if err := json.Unmarshal(body, &card); err != nil {
		log.Println("[TRANSACTION] An error occured while trying to Unmarshal payload from paystack, err -> ", err.Error())
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse response from paystack"})
		return
	}

	if !card.Status {
		ctx.JSON(resp.StatusCode, gin.H{"msg": card.Message})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"msg": card.Message, "link": card.Data.Link})
}

// RetryFailedPayment godoc
// @Summary Retries a failed payment for subscription
// @Description An endpoint for retrying a failed subscription payment
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id query string true "Sub ID"
// @Success 200 {object} schema.DocNormalResponse "Success"
// @Failure 400 {object} schema.DocNormalResponse "Bad Request"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 402 {object} schema.DocMsgResResponse "Payment required"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload / response"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "External server error"
// @Router /api/transc/retry-payment [post]
func (t *TranscService) RetryFailedPayment(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized"})
		return
	}

	subID := ctx.Query("id")
	if !model.IsValidUUID(subID) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid sub id."})
		return
	}

	var user model.User
	if err := t.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var sub model.Subscriptions
	if err := t.DB.FetchSub(&sub, subID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if sub.Status != model.StatusFailed {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Subscription is not failed and can't be retried."})
		return
	}

	plans, err := t.RetrievePlans()
	if err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var subPlan schema.ViewPlansResp
	for _, plan := range plans {
		if sub.PlanName == plan.Name {
			subPlan = plan
			break
		}
	}

	amount := fmt.Sprintf("%d", subPlan.Amount)
	chargePayload := map[string]any{
		"email":              user.Email,
		"amount":             amount,
		"authorization_code": *user.PaystackAuthCode,
		"metadata": map[string]any{
			"charge_type": "manual_retry",
			"sub_id":      subID,
		},
	}

	chargeBody, _ := json.Marshal(chargePayload)

	chargeReq, _ := http.NewRequest(http.MethodPost, "https://api.paystack.co/transaction/charge_authorization", bytes.NewBuffer(chargeBody))
	chargeReq.Header.Set("Authorization", "Bearer "+t.SecretKey)
	chargeReq.Header.Set("Content-Type", "application/json")

	chargeResp, err := t.Client.Do(chargeReq)
	if err != nil {
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Failed to communicate with paystack to make payment."})
		return
	}

	defer chargeResp.Body.Close()

	var chargeResponse schema.AuthCharge
	chargeData, _ := io.ReadAll(chargeResp.Body)

	if err := json.Unmarshal(chargeData, &chargeResponse); err != nil {
		log.Println("[TRANSACTION] An error occured while trying to unmarshal the response of paystack, err -> ", err.Error())
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Unable to communicate with paystack to initiate transaction."})
		return
	}

	if !chargeResponse.Status || chargeResponse.Data.Status != model.StatusSuccess {
		ctx.JSON(http.StatusPaymentRequired, gin.H{"msg": "Failed payment!", "reason": chargeResponse.Message})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"msg": "Payment successful your subscription will be renewed."})
}

// CancelSubscription godoc
// @Summary An endpoint for canceling a subscription
// @Description An endpoint for canceling a subscription
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocNormalResponse "Success"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "Failed communication with external service"
// @Router /api/transc/cancel-sub [patch]
func (t *TranscService) CancelSubscription(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := t.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	payload := map[string]string{
		"code":  *user.PaystackSubCode,
		"token": *user.PaystackEmailToken,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "https://api.paystack.co/subscription/disable", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+t.SecretKey)
	req.Header.Set("Content-Type", "application/json")

	resp, err := t.Client.Do(req)
	if err != nil || resp.StatusCode != http.StatusOK {
		log.Println("[TRANSACTION] An error occured while trying to cancel a subscription, err -> ", err)
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Failed to communicate with paystack."})
		return
	}

	defer resp.Body.Close()
	var sub schema.PaystackSubResp

	body, _ = io.ReadAll(resp.Body)

	if err := json.Unmarshal(body, &sub); err != nil {
		log.Println("[TRANSACTION] An error occured while trying to Unmarshal payload from paystack, err -> ", err.Error())
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse response from paystack"})
		return
	}

	if !sub.Status {
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": sub.Message})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"msg": sub.Message})
}

// EnableSubscription godoc
// @Summary An endpoint for enabling a subscription
// @Description An endpoint for re enabling a subscription
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocNormalResponse "Success"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 402 {object} schema.DocNormalResponse "Payment required"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "Failed communication with external service"
// @Router /api/transc/enable-sub [patch]
func (t *TranscService) EnableSubscription(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := t.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	payload := map[string]string{
		"code":  *user.PaystackSubCode,
		"token": *user.PaystackEmailToken,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "https://api.paystack.co/subscription/enable", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+t.SecretKey)
	req.Header.Set("Content-Type", "application/json")

	resp, err := t.Client.Do(req)
	if err != nil {
		log.Println("[TRANSACTION] An error occured while trying to enable a subscription, err -> ", err, resp.StatusCode)
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Failed to communicate with paystack."})
		return
	}

	defer resp.Body.Close()
	var sub schema.PaystackSubResp

	body, _ = io.ReadAll(resp.Body)
	log.Println(string(body))

	if err := json.Unmarshal(body, &sub); err != nil {
		log.Println("[TRANSACTION] An error occured while trying to Unmarshal payload from paystack, err -> ", err.Error())
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse response from paystack"})
		return
	}

	if !sub.Status {
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": sub.Message})
		return
	}

	t.Email.QueueSubscriptionReEnabled(user.UserName, user.NextPaymentDate.Format("January 02, 2006"), user.Email)

	ctx.JSON(http.StatusOK, gin.H{"msg": sub.Message})
}

// ViewPlans godoc
// @Summary An endpoint to view available plans
// @Description An endpoint to view available plans
// @Tags Transaction
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewPlansResponse "Success"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 502 {object} schema.DocNormalResponse "Bad Gateway"
// @Router /api/transc/view/plans [get]
func (t *TranscService) ViewPlans(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	plans, err := t.RetrievePlans()
	if err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"plans": plans})
}

// RetrievePlans -> A helper func to retrieve plans from cache if available or fetch from paystack
func (t *TranscService) RetrievePlans() ([]schema.ViewPlansResp, error) {
	if plan, err := t.RDB.RetrieveCachedPlans(); err == nil && plan != nil && len(plan) != 0 {
		return plan, nil
	}

	req, _ := http.NewRequest(http.MethodGet, "https://api.paystack.co/plan", nil)
	req.Header.Set("Authorization", "Bearer "+t.SecretKey)

	resp, err := t.Client.Do(req)
	if err != nil || resp.StatusCode != http.StatusOK {
		return nil, &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to communicate with paystack."}
	}

	defer resp.Body.Close()
	var plans schema.PaystackViewPlans

	body, _ := io.ReadAll(resp.Body)

	if err := json.Unmarshal(body, &plans); err != nil {
		log.Println("[TRANSACTION] An error occured while trying to Unmarshal payload from paystack, err -> ", err.Error())
		return nil, &core.CustomMessage{Code: http.StatusUnprocessableEntity, Message: "Failed to parse response from paystack."}
	}

	if !plans.Status {
		return nil, &core.CustomMessage{Code: http.StatusBadGateway, Message: plans.Message}
	}

	var res []schema.ViewPlansResp

	for _, plan := range plans.Data {
		res = append(res, schema.ViewPlansResp{
			ID:       plan.PlanCode,
			Amount:   plan.Amount,
			Name:     plan.Name,
			Interval: plan.Interval,
			Currency: plan.Currency,
		})
	}

	_ = t.RDB.CachePlans(res)
	return res, nil
}

// FetchSubscriptionDetails -> A helper func to fetch the subscription details from paystack
func (t *TranscService) FetchSubscriptionDetails(subCode string) (*schema.SubscriptionDetails, error) {
	req, _ := http.NewRequest(http.MethodGet, "https://api.paystack.co/subscription/"+subCode, nil)
	req.Header.Set("Authorization", "Bearer "+t.SecretKey)

	resp, err := t.Client.Do(req)
	if err != nil || resp.StatusCode != http.StatusOK {
		return nil, &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to communicate with paystack."}
	}

	defer resp.Body.Close()

	var sub schema.SubscriptionDetails
	body, _ := io.ReadAll(resp.Body)

	if err := json.Unmarshal(body, &sub); err != nil {
		log.Println("[TRANSACTION] Failed to unmarshal paystack response for subscription details, err -> ", err.Error())
		return nil, &core.CustomMessage{Code: http.StatusUnprocessableEntity, Message: "Failed to unmarshal paystack response"}
	}

	return &sub, nil
}
```

## File: model/msg.go
```go
// Package model -> The ERM of the app
package model

import (
	"math/rand"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

var groupnames = []string{
	"alpha-room",
	"collab-space",
	"innovation-lab",
	"dev-dungeon",
	"mission-base",
	"brainstorm-hub",
}

type UserMessage struct {
	GormModel
	ChatID  string `gorm:"not null"`
	FromID  string `gorm:"not null"`
	Message string `gorm:"not null"`

	// Relations:
	FromUser *User `gorm:"foreignKey:FromID"`
}

type Chat struct {
	GormModel
	Name     string
	Messages []*UserMessage `gorm:"foreignKey:ChatID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Users    []*User        `gorm:"many2many:chat_users"`

	Group   bool `gorm:"not null"`
	OwnerID *string
	Owner   *User `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type ChatUser struct {
	UserID string `gorm:"primaryKey"`
	ChatID string `gorm:"primaryKey"`

	User *User `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Chat *Chat `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

func (c *Chat) BeforeCreate(tx *gorm.DB) (err error) {
	if c.ID == "" {
		c.ID = uuid.NewString()
	}

	if c.Group {
		idx := rand.Intn(len(groupnames))
		c.Name = groupnames[idx]
	}

	return err
}

func (u *UserMessage) BeforeCreate(tx *gorm.DB) (err error) {
	if u.ID == "" {
		u.ID = uuid.NewString()
	}
	return err
}
```

## File: test/unit/msg_test.go
```go
package unit

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
)

var (
	msgDefPayload = map[string]string{
		"msg":     "Yo i need your help with the frontend or mobile dev.",
		"chat_id": "",
	}
	msg ViewMsg
)

func TestCreateMessage(t *testing.T) {
	payload := msgDefPayload
	payload["chat_id"] = cid
	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/msg/send-message", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)
	assert.Contains(t, w.Body.String(), payload["msg"])

	_ = json.Unmarshal(w.Body.Bytes(), &msg)
}

func TestCreateMessageInvalidChatID(t *testing.T) {
	payload := msgDefPayload
	payload["chat_id"] = "nil"
	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/msg/send-message", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNotFound, w.Code)
	assert.Contains(t, w.Body.String(), "Chat not found.")
}

func TestViewHist(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/msg/view-hist?id="+cid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), msgDefPayload["msg"])
}

func TestViewChats(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/msg/view-chats", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), msgDefPayload["msg"])
	assert.Contains(t, w.Body.String(), cid)
}

func TestEditMessage(t *testing.T) {
	payload := map[string]string{
		"msg":    "Yo i really need your help i'm almost done with the project but i don't do mobile dev",
		"msg_id": msg.ID,
	}
	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/msg/edit-message", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), payload["msg"])
}

func TestDeleteMessage(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/msg/delete-message?id="+msg.ID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestOpenChat(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/msg/open-chat?id="+id2, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName1)
}

func TestRenameChat(t *testing.T) {
	payload := map[string]string{
		"chat_id": gid,
		"name":    "Bankai",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/msg/rename-chat", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Chat name updated successfully.")
}

func TestAddUserToChat(t *testing.T) {
	payload := map[string]string{
		"chat_id": gid,
		"user_id": id2,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPut, "/api/msg/add-user", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestRemoveUserFromChat(t *testing.T) {
	payload := map[string]string{
		"chat_id": gid,
		"user_id": id2,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodDelete, "/api/msg/remove-user", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestAddUserToChatToLeave(t *testing.T) {
	payload := map[string]string{
		"chat_id": gid,
		"user_id": id2,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPut, "/api/msg/add-user", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestLeaveChat(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/msg/leave-chat?id="+gid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestAddUserToTestOwnership(t *testing.T) {
	payload := map[string]string{
		"chat_id": gid,
		"user_id": id2,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPut, "/api/msg/add-user", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestTransferOwner(t *testing.T) {
	payload := map[string]string{
		"chat_id": gid,
		"user_id": id2,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/msg/transfer-owner", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestDeleteChat(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/msg/delete-chat?id="+gid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}
```

## File: .gitignore
```
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Code coverage profiles and other test artifacts
*.out
coverage.*
*.coverprofile
profile.cov

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

# Editor/IDE
# .idea/
# .vscode/
```

## File: LICENSE
```
MIT License

Copyright (c) 2025 Imisioluwa Isong

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## File: handlers/conf.go
```go
// Package handlers -> Endpoints for the app
package handlers

import (
	"net/http"
	"os"
	"strings"
	"time"

	"findme/core"
	"findme/model"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/gorilla/websocket"
)

type JWTClaims struct {
	UserID  string
	Purpose string
	Premium bool
	jwt.RegisteredClaims
}

var (
	JWTSecret  = os.Getenv("JWTSECRET")
	JWTExpiry  = time.Hour * 24
	JWTRExpiry = time.Minute * 5
	HTTPClient = &http.Client{Timeout: 10 * time.Second}
	upgrade    = websocket.Upgrader{
		ReadBufferSize:  2048,
		WriteBufferSize: 2048,
		CheckOrigin: func(r *http.Request) bool {
			return true
		},
	}
)

// GenerateJWT -> Generates JWT token
func GenerateJWT(userID string, purpose string, premium bool, expiry time.Duration) (string, error) {
	claims := JWTClaims{
		UserID:  userID,
		Purpose: purpose,
		Premium: premium,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(JWTSecret))
}

// ValidateJWT -> Validates JWT token for authentication
func ValidateJWT(tokenSting string) (*JWTClaims, error) {
	token, err := jwt.ParseWithClaims(tokenSting, &JWTClaims{}, func(t *jwt.Token) (any, error) {
		if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, &core.CustomMessage{Code: 400, Message: "Invalid Token!"}
		}
		return []byte(JWTSecret), nil
	})
	if err != nil {
		return nil, &core.CustomMessage{Code: 400, Message: "Expired Token!"}
	}

	payload, ok := token.Claims.(*JWTClaims)

	if ok && token.Valid {
		return payload, nil
	}

	return nil, &core.CustomMessage{Code: 400, Message: "Invalid Token!"}
}

// Authorization -> Authorize user
func Authorization(user *model.User, password string) (string, error) {
	err := core.VerifyHashedPassword(password, user.Password)
	if err != nil {
		return "", &core.CustomMessage{Code: 404, Message: "Invalid Credentials!"}
	}

	premium := CheckSubscription(user)

	jwtToken, err := GenerateJWT(user.ID, "login", premium, JWTExpiry)
	if err != nil {
		return "", &core.CustomMessage{Code: 500, Message: "Failed to generate jwt token"}
	}

	return jwtToken, nil
}

// CheckSubscription -> Checks if a user has a current subscription
func CheckSubscription(user *model.User) bool {
	if time.Now().Before(user.FreeTrial) {
		return true
	}

	if user.LastSub != nil {
		if time.Now().Before(*user.NextPaymentDate) {
			return true
		}
	}

	return false
}

// Authentication -> Authenticate user
func (s *Service) Authentication() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		authHeader := ctx.GetHeader("Authorization")

		if authHeader == "" {
			ctx.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"message": "Authorization header missing!"})
			return
		}

		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
			ctx.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"message": "Bearer token not found in the authorization header!"})
			return
		}

		tokenString := parts[1]

		payload, err := ValidateJWT(tokenString)
		if err != nil {
			cm := err.(*core.CustomMessage)
			ctx.AbortWithStatusJSON(cm.Code, gin.H{"message": cm.Message})
			return
		}

		ctx.Set("userID", payload.UserID)
		ctx.Set("purpose", payload.Purpose)
		ctx.Set("premium", payload.Premium)

		ctx.Next()
	}
}

// CheckAndUpdateSkills -> Helper func for checking and updating skills
func (s *Service) CheckAndUpdateSkills(payload []string) ([]*model.Skill, error) {
	skills, err := s.RDB.RetrieveCachedSkills(payload)
	if err != nil { // Falling back to the db if the cache fails
		var existingSkills []*model.Skill

		if err := s.DB.FindExistingSkills(&existingSkills, payload); err != nil {
			return nil, err
		}

		existingSkillSet := make(map[string]bool)
		for _, name := range existingSkills {
			existingSkillSet[name.Name] = true
		}

		var newSkill []*model.Skill
		for _, skill := range payload {
			if _, exists := existingSkillSet[skill]; !exists {
				newSkill = append(newSkill, &model.Skill{Name: skill})
			}
		}

		if len(newSkill) > 0 {
			if err := s.DB.AddSkills(&newSkill); err != nil {
				return nil, err
			}
		}
		newSkill = append(newSkill, existingSkills...)
		return newSkill, nil
	}

	var newskills, allskills []*model.Skill
	for _, skill := range payload {
		if id, exists := skills[skill]; exists {
			allskills = append(allskills, &model.Skill{Name: skill, GormModel: model.GormModel{ID: id}})
			continue
		}
		newskills = append(newskills, &model.Skill{Name: skill})
	}

	if len(newskills) > 0 {
		if err := s.DB.AddSkills(&newskills); err != nil {
			return nil, err
		}
		s.RDB.AddNewSkillToCache(newskills)
	}
	allskills = append(allskills, newskills...)
	return allskills, nil
}
```

## File: schema/doc.go
```go
package schema

type DocTokenResponse struct {
	Token string `json:"token"`
}

type DocNormalResponse struct {
	Msg string `json:"msg"`
}

type DocProjectUserResponse struct {
	User UserProfileResponse `json:"user"`
	Post []ProjectResponse   `json:"posts"`
}

type DocUserResponse struct {
	User UserProfileResponse `json:"user"`
}

type DocRecUsersResponse struct {
	Users []RecProfileResponse `json:"users"`
}

type DocUsersSearch struct {
	Users []SearchUser `json:"users"`
}

type DocFriendReqStatus struct {
	Req FriendReqStatus `json:"req"`
}

type DocViewFriendReqs struct {
	SentReq []FriendReqStatus `json:"sent_req"`
	RecReq  []FriendReqStatus `json:"rec_req"`
}

type DocFriendReqAccept struct {
	Msg    string `json:"msg"`
	ChatID string `json:"chat_id"`
}

type DocViewFriends struct {
	Friends []ViewFriends `json:"friends"`
}

type DocSkillsResponse struct {
	Skills []string `json:"skills"`
}

type DocProjectResponse struct {
	Project ProjectResponse `json:"project"`
}

type DocRecProjectsResponse struct {
	Projects []RecProjectResponse `json:"projects"`
}

type DocAllProjectResponse struct {
	Project []ProjectResponse `json:"project"`
}

type DocDetailedProjectResponse struct {
	Project DetailedProjectResponse `json:"project"`
}

type DocViewProjectApplications struct {
	Req ApplicationProjectResponse `json:"req"`
}

type DocProjectApplication struct {
	ProjectReq ViewProjectApplication `json:"project_req"`
}

type DocViewAllProjectApplication struct {
	Project map[string]any `json:"project"`
}

type DocMsgResponse struct {
	Msg ViewMessage `json:"msg"`
}

type DocViewChatHistory struct {
	Msg ViewChat `json:"msg"`
}

type DocViewAllChats struct {
	Msg []ViewChat `json:"msg"`
}

type DocViewRepos struct {
	Repos []ViewRepo `json:"repos"`
}

type DocTranscResposne struct {
	Transactions []TransactionResponse
}

type DocViewSubscriptions struct {
	Subs []ViewSubscriptions
}

type DocInitTranscResponse struct {
	URI   string `json:"uri"`
	Token string `json:"token"`
}

type DocUpdateCardSub struct {
	Msg  string `json:"msg"`
	Link string `json:"link"`
}

type DocViewPlansResponse struct {
	Plans []ViewPlansResp `json:"plans"`
}

type DocViewPaymentInfo struct {
	Info PaymentInfo `json:"info"`
}

type DocMsgResResponse struct {
	Msg    string `json:"msg"`
	Reason string `json:"reason"`
}
```

## File: model/post.go
```go
package model

import (
	"github.com/google/uuid"
	"gorm.io/gorm"
)

type Project struct {
	GormModel
	Title        string `gorm:"not null"`
	Description  string `gorm:"not null"`
	Views        uint   `gorm:"not null"`
	Availability bool
	GitProject   bool
	GitLink      string
	ChatID       *string
	UserID       string `gorm:"not null"`

	// Relations:
	User         *User         `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Tags         []*Skill      `gorm:"many2many:project_skills"`
	Applications []*ProjectReq `gorm:"foreignKey:ProjectID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Chat         *Chat         `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type ProjectReq struct {
	GormModel
	Status    string `gorm:"not null;default:'pending'"`
	Message   string `gorm:"default:'Hey I can work on this'"`
	ProjectID string `gorm:"not null"`
	FromID    string `gorm:"not null"`
	ToID      string `gorm:"not null"`

	// Relations:
	Project  *Project `gorm:"foreignKey:ProjectID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	FromUser *User    `gorm:"foreignKey:FromID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	ToUser   *User    `gorm:"foreignKey:ToID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type ProjectSkill struct {
	ProjectID string `gorm:"primaryKey"`
	SkillID   string `gorm:"primaryKey"`

	// Relations:
	Project *Project `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

func (p *Project) BeforeCreate(tx *gorm.DB) (err error) {
	if p.ID == "" {
		p.ID = uuid.NewString()
	}
	return err
}

func (p *ProjectReq) BeforeCreate(tx *gorm.DB) (err error) {
	if p.ID == "" {
		p.ID = uuid.NewString()
	}
	return nil
}
```

## File: docs/docs.go
```go
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/msg/add-user": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for adding users to a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Add a user to a group chat",
                "parameters": [
                    {
                        "description": "Chat payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.AddUserChat"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User Added",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/delete-chat": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a group chat owned by the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Delete a group chat",
                "parameters": [
                    {
                        "type": "string",
                        "description": "chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Chat deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/delete-message": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a sent message of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Delete a sent message",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Msg ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Message deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/edit-message": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing a sent message",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Editing a sent message",
                "parameters": [
                    {
                        "description": "Message payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.EditMessage"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Message edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocMsgResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/leave-chat": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for leaving a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Leave a group chat",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Chat removed"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/open-chat": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for opening a chat between users with IDs.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Open a chat between users",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Chat opened",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewChatHistory"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/remove-user": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for removing a user from a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Remove a user from a group",
                "parameters": [
                    {
                        "description": "Chat payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.AddUserChat"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "User removed"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/rename-chat": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for renaming a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Renaming a group chat",
                "parameters": [
                    {
                        "description": "Chat payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.RenameChat"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Chat Updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/send-message": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for sending a message to a chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Sending of message to a chat",
                "parameters": [
                    {
                        "description": "Message payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.NewMessage"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Message Sent",
                        "schema": {
                            "$ref": "#/definitions/schema.DocMsgResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/transfer-owner": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for transferring the ownership of a group chat to another user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Transfer group chat ownership to another user",
                "parameters": [
                    {
                        "description": "payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.AddUserChat"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Ownership Transferred",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/view-chats": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for fetching all chats of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Fetch the current user chats",
                "responses": {
                    "200": {
                        "description": "User chats",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewAllChats"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/view-hist": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to view all messages in a chat (the chat history)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "View All messages in a chat",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Chat history",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewChatHistory"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/ws/chat": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint that upgrades client to a websocket connection for real-time chatting experience",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "A websocket message hub for real-time chatting",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "101": {
                        "description": "Switching Protocols",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/apply": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for applying to a project to work on",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Apply for a project to work on",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Application payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.ProjectApplication"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Applied successfully",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectApplication"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing record",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/clear-application": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for clearing all applications on a project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Clear all applications on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Applications cleared"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/create": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for creating a new project for the current user it internally calls a service to create a vector for the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Create a new project",
                "parameters": [
                    {
                        "description": "Project payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.NewProjectRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Project created",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/delete-application": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a sent project application for the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Delete a send project application",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Request deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/edit": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing major details of a project it internally calls a service to update the vector for the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Editing details of a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Project payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.NewProjectRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Project Edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/edit-status": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing the availability status of a project it internally calls a service to update the vector for the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Editing the availability of a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Status",
                        "name": "staus",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Project edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/edit-view": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing the number of views on a project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Editing the number of views on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Project view edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/posts/all": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for retreiving all current user projects",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Retreive all current user projects",
                "responses": {
                    "200": {
                        "description": "Fetched all projects",
                        "schema": {
                            "$ref": "#/definitions/schema.DocAllProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/recommend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for recommending users for a project using ai",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Recommends users to work on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Users Retrieved",
                        "schema": {
                            "$ref": "#/definitions/schema.DocRecUsersResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment Required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/save-post": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for adding a project to the current user bookmarks",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Bookmark a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Bookmarked project",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/tags": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for project with tags associated with the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Search for a project with tags/skills",
                "parameters": [
                    {
                        "description": "Tags",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SearchProjectWithTags"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Projects",
                        "schema": {
                            "$ref": "#/definitions/schema.DocAllProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/update-application": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating a project application status to accepted or rejected",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Updating a project application status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Request status",
                        "name": "status",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.RejectApplication"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Status Updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing a single project in details by using the project ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View a single project with ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Fetched project",
                        "schema": {
                            "$ref": "#/definitions/schema.DocDetailedProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view-application": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the applications on a single project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View all applications on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Project applications",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewProjectApplications"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view-applications": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all sent and received project applications",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View all project applications sent and received",
                "responses": {
                    "200": {
                        "description": "Fetched applications",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewAllProjectApplication"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view/saved-post": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to view all of the bookmarked projects of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View all current user bookmarked projects",
                "responses": {
                    "200": {
                        "description": "Bookmarked projects",
                        "schema": {
                            "$ref": "#/definitions/schema.DocAllProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/cancel-sub": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for canceling a subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint for canceling a subscription",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Failed communication with external service",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/enable-sub": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for re enabling a subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint for enabling a subscription",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Failed communication with external service",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/initialize": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for initializing a transaction on paystack to receive a checkout url for payment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint for initializing a transaction on paystack",
                "parameters": [
                    {
                        "type": "string",
                        "description": "amount",
                        "name": "amount",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "plan",
                        "name": "plan",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocInitTranscResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Query",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/retry-payment": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for retrying a failed subscription payment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "Retries a failed payment for subscription",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Sub ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocMsgResResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload / response",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "External server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/update-card": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "This is an endpoint for retrieving link for updating card details used for transaction on paystack",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "This is an endpoint for udpating card details on paystack",
                "responses": {
                    "200": {
                        "description": "Link Generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUpdateCardSub"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Failed communication with external service",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/view": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint that retrieves all the transactions of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "Retrieves the transactions for a user",
                "responses": {
                    "200": {
                        "description": "Transactions retrieved",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTranscResposne"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/view/plans": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to view available plans",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint to view available plans",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewPlansResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/webhook": {
            "post": {
                "description": "An endpoint for intercepting the paystack webhooks transaction events",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "This is a webhook for the paystack transaction events",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/connect-github": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An redirecting endpoint for connecting a github account to the current user account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Connecting github account to user account",
                "responses": {
                    "307": {
                        "description": "Redirecting",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-friend-req": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a sent friend request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a sent friend req",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request id",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Request deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission Denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-skills": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to delete some skills from the current user skills it internally calls a service to update the user vector",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete skills from the user skills",
                "parameters": [
                    {
                        "description": "Skills",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.DeleteUserSkillsRequest"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Skills Deleted"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-user": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting the current user account it internally calls a service to delete the vector of the user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a user account",
                "responses": {
                    "204": {
                        "description": "Account deleted"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-user-friend": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a friend from the users friend list",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a existing friendship",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User id",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Chat id",
                        "name": "chat_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Friend deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/get-user": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for fetching a user by their ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get a user by their ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "user and projects fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid user id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/payment-info": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for retreiving a user saved payment info used for subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Retreives a user saved payment info used for subscription",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewPaymentInfo"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/profile": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for fetching the currently logged in user profile details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get the logged in user info",
                "responses": {
                    "200": {
                        "description": "user fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUserResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/recommend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for recommending projects for a user to work on using ai",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Recommends projects for a user to work on",
                "responses": {
                    "200": {
                        "description": "Projects Retreived",
                        "schema": {
                            "$ref": "#/definitions/schema.DocRecProjectsResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment Required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/reset-password": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for reseting the user password with a reset jwt token gotten from the verify-otp route",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Reset user password through forgot password route",
                "parameters": [
                    {
                        "description": "new password",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.ResetPassword"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "reset successful",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid password",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/search": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for users with their skills to show their profiles",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Search for users by skills/tags",
                "parameters": [
                    {
                        "description": "Skills",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SearchUserbySkills"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "users fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUsersSearch"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/send-user-req": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for sending friend requests to users for connecting",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Send a Friend req to a user",
                "parameters": [
                    {
                        "description": "Request",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SendFriendReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Request sent",
                        "schema": {
                            "$ref": "#/definitions/schema.DocFriendReqStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing Friend Req / Friend",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-availability/{status}": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the Availability status of the current user to either true or false it internally calls a service to update the user vector payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update Availability status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Availability status",
                        "name": "status",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Status updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-bio": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user bio information it internally calls a service to update the vector for the user.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user bio",
                "parameters": [
                    {
                        "description": "new details",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdateUserBio"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-interest": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user interests it internally calls a service to update the vector for the user.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user interests",
                "parameters": [
                    {
                        "description": "new details",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdateUserInterests"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-password": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user password",
                "parameters": [
                    {
                        "description": "new password",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdatePassword"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "password updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-profile": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user profile details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user profile details",
                "parameters": [
                    {
                        "description": "new details",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UserProfileRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUserResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing username / email",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-skills": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the skills of the current user it internally calls a service to update the user vector",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update User skills",
                "parameters": [
                    {
                        "description": "Skills",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdateUserSkillsRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Skills updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocSkillsResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-user-req": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the status of received friend req to rejected / accepted",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update a friend req status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Request status updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocFriendReqAccept"
                        }
                    },
                    "400": {
                        "description": "Invalid status / id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission Denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for a user with their username to show their projects and profile",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Search for user with their username",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Username",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "user and projects fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid username",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-friend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the friends for the currently logged in user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "View all friends for the logged in user",
                "responses": {
                    "200": {
                        "description": "User friends fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewFriends"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-git": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for a user with their git username to show their projects and profile",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Search for user with their git username",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Git Username",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "user and projects fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid git username",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-repo": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing the user public repo to tag to a project.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Git"
                ],
                "summary": "View Github public repo for current user",
                "responses": {
                    "200": {
                        "description": "Repo fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewRepos"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-subs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing the history of a user's subsciption",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Views a user subscription history",
                "responses": {
                    "200": {
                        "description": "Subscriptions",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewSubscriptions"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-user-friend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the friends of a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "View all friends of a user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User friends fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewFriends"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-user-req": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the looged in users friend reqs (sent and received)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "View All friend reqs",
                "responses": {
                    "200": {
                        "description": "Fetched requests",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewFriendReqs"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/auth/github/callback": {
            "get": {
                "description": "An endpoint for selecting the callback for login, connect github endpoint",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Callback for the github sign-in / connect",
                "responses": {
                    "200": {
                        "description": "Token generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "202": {
                        "description": "Github Connected",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing record",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/forgot-password": {
            "post": {
                "description": "An endpoint for getting an otp for reseting the user password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get a OTP for reseting user password",
                "parameters": [
                    {
                        "description": "User email",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.ForgotPasswordEmail"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Email sent to user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid Email",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/github-signup": {
            "get": {
                "description": "A redirecting endpoint for sign-in / sign-up with github it calls a service internally to create a vector for new users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Signing up user using github",
                "responses": {
                    "307": {
                        "description": "Redirecting",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/health/detailed": {
            "get": {
                "description": "This gives a detailed health status of the running services",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Checks the health of the services running",
                "responses": {
                    "200": {
                        "description": "Service Healthy",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "503": {
                        "description": "Service Degraded",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "description": "Log in endpoint for existing users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User login payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "jwt token generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/signup": {
            "post": {
                "description": "Sign up endpoint for new users it internally calls a service to create a vector for the user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User signup payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SignupRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "jwt token generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "409": {
                        "description": "Existing email or username",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/verify-otp": {
            "get": {
                "description": "An endpoint to verify sent otp to create reset jwt token for reseting user password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Verify Sent otp to reset password",
                "parameters": [
                    {
                        "type": "string",
                        "description": "otp",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "reset token",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "400": {
                        "description": "invalid otp",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "invalid otp",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "schema.AddUserChat": {
            "type": "object",
            "required": [
                "chat_id",
                "user_id"
            ],
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "user_id": {
                    "type": "string"
                }
            }
        },
        "schema.ApplicationProjectResponse": {
            "type": "object",
            "properties": {
                "applications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewProjectApplication"
                    }
                }
            }
        },
        "schema.DeleteUserSkillsRequest": {
            "type": "object",
            "required": [
                "skills"
            ],
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.DetailedProjectResponse": {
            "type": "object",
            "properties": {
                "available": {
                    "type": "boolean"
                },
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "gitLink": {
                    "type": "string"
                },
                "gitProject": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "schema.DocAllProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ProjectResponse"
                    }
                }
            }
        },
        "schema.DocDetailedProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "$ref": "#/definitions/schema.DetailedProjectResponse"
                }
            }
        },
        "schema.DocFriendReqAccept": {
            "type": "object",
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.DocFriendReqStatus": {
            "type": "object",
            "properties": {
                "req": {
                    "$ref": "#/definitions/schema.FriendReqStatus"
                }
            }
        },
        "schema.DocInitTranscResponse": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                },
                "uri": {
                    "type": "string"
                }
            }
        },
        "schema.DocMsgResResponse": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                }
            }
        },
        "schema.DocMsgResponse": {
            "type": "object",
            "properties": {
                "msg": {
                    "$ref": "#/definitions/schema.ViewMessage"
                }
            }
        },
        "schema.DocNormalResponse": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.DocProjectApplication": {
            "type": "object",
            "properties": {
                "project_req": {
                    "$ref": "#/definitions/schema.ViewProjectApplication"
                }
            }
        },
        "schema.DocProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "$ref": "#/definitions/schema.ProjectResponse"
                }
            }
        },
        "schema.DocProjectUserResponse": {
            "type": "object",
            "properties": {
                "posts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ProjectResponse"
                    }
                },
                "user": {
                    "$ref": "#/definitions/schema.UserProfileResponse"
                }
            }
        },
        "schema.DocRecProjectsResponse": {
            "type": "object",
            "properties": {
                "projects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.RecProjectResponse"
                    }
                }
            }
        },
        "schema.DocRecUsersResponse": {
            "type": "object",
            "properties": {
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.RecProfileResponse"
                    }
                }
            }
        },
        "schema.DocSkillsResponse": {
            "type": "object",
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.DocTokenResponse": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "schema.DocTranscResposne": {
            "type": "object",
            "properties": {
                "transactions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.TransactionResponse"
                    }
                }
            }
        },
        "schema.DocUpdateCardSub": {
            "type": "object",
            "properties": {
                "link": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.DocUserResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/schema.UserProfileResponse"
                }
            }
        },
        "schema.DocUsersSearch": {
            "type": "object",
            "properties": {
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.SearchUser"
                    }
                }
            }
        },
        "schema.DocViewAllChats": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewChat"
                    }
                }
            }
        },
        "schema.DocViewAllProjectApplication": {
            "type": "object",
            "properties": {
                "project": {
                    "type": "object",
                    "additionalProperties": {}
                }
            }
        },
        "schema.DocViewChatHistory": {
            "type": "object",
            "properties": {
                "msg": {
                    "$ref": "#/definitions/schema.ViewChat"
                }
            }
        },
        "schema.DocViewFriendReqs": {
            "type": "object",
            "properties": {
                "rec_req": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.FriendReqStatus"
                    }
                },
                "sent_req": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.FriendReqStatus"
                    }
                }
            }
        },
        "schema.DocViewFriends": {
            "type": "object",
            "properties": {
                "friends": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewFriends"
                    }
                }
            }
        },
        "schema.DocViewPaymentInfo": {
            "type": "object",
            "properties": {
                "info": {
                    "$ref": "#/definitions/schema.PaymentInfo"
                }
            }
        },
        "schema.DocViewPlansResponse": {
            "type": "object",
            "properties": {
                "plans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewPlansResp"
                    }
                }
            }
        },
        "schema.DocViewProjectApplications": {
            "type": "object",
            "properties": {
                "req": {
                    "$ref": "#/definitions/schema.ApplicationProjectResponse"
                }
            }
        },
        "schema.DocViewRepos": {
            "type": "object",
            "properties": {
                "repos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewRepo"
                    }
                }
            }
        },
        "schema.DocViewSubscriptions": {
            "type": "object",
            "properties": {
                "subs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewSubscriptions"
                    }
                }
            }
        },
        "schema.EditMessage": {
            "type": "object",
            "required": [
                "msg",
                "msg_id"
            ],
            "properties": {
                "msg": {
                    "type": "string"
                },
                "msg_id": {
                    "type": "string"
                }
            }
        },
        "schema.ForgotPasswordEmail": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "schema.FriendReqStatus": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "sent": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.LoginRequest": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.NewMessage": {
            "type": "object",
            "required": [
                "chat_id",
                "msg"
            ],
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.NewProjectRequest": {
            "type": "object",
            "required": [
                "description",
                "tags",
                "title"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "git": {
                    "type": "boolean"
                },
                "git_link": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "schema.PaymentInfo": {
            "type": "object",
            "properties": {
                "card": {
                    "type": "string"
                },
                "last4": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "nextPaymentDate": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                }
            }
        },
        "schema.ProjectApplication": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string",
                    "maxLength": 50
                }
            }
        },
        "schema.ProjectResponse": {
            "type": "object",
            "properties": {
                "available": {
                    "type": "boolean"
                },
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "schema.RecProfileResponse": {
            "type": "object",
            "properties": {
                "score": {
                    "type": "number",
                    "format": "float32"
                },
                "user": {
                    "$ref": "#/definitions/schema.UserProfileResponse"
                }
            }
        },
        "schema.RecProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "$ref": "#/definitions/schema.ProjectResponse"
                },
                "score": {
                    "type": "number",
                    "format": "float32"
                }
            }
        },
        "schema.RejectApplication": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.RenameChat": {
            "type": "object",
            "required": [
                "chat_id",
                "name"
            ],
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ResetPassword": {
            "type": "object",
            "required": [
                "password"
            ],
            "properties": {
                "password": {
                    "type": "string",
                    "minLength": 8
                }
            }
        },
        "schema.SearchProjectWithTags": {
            "type": "object",
            "required": [
                "tags"
            ],
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.SearchUser": {
            "type": "object",
            "properties": {
                "availability": {
                    "type": "boolean"
                },
                "bio": {
                    "type": "string"
                },
                "gitUser": {
                    "type": "boolean"
                },
                "gitUserName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "interests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userName": {
                    "type": "string"
                }
            }
        },
        "schema.SearchUserbySkills": {
            "type": "object",
            "required": [
                "skills"
            ],
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.SendFriendReq": {
            "type": "object",
            "required": [
                "uid"
            ],
            "properties": {
                "msg": {
                    "type": "string",
                    "maxLength": 50
                },
                "uid": {
                    "type": "string"
                }
            }
        },
        "schema.SignupRequest": {
            "type": "object",
            "required": [
                "country",
                "email",
                "fullname",
                "password",
                "username"
            ],
            "properties": {
                "bio": {
                    "type": "string",
                    "maxLength": 50
                },
                "country": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "fullname": {
                    "type": "string"
                },
                "interests": {
                    "type": "array",
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    }
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.TransactionResponse": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "integer",
                    "format": "int64"
                },
                "channel": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "paidAt": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "schema.UpdatePassword": {
            "type": "object",
            "required": [
                "new_password",
                "password"
            ],
            "properties": {
                "new_password": {
                    "type": "string",
                    "minLength": 8
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "schema.UpdateUserBio": {
            "type": "object",
            "properties": {
                "bio": {
                    "type": "string",
                    "maxLength": 50
                }
            }
        },
        "schema.UpdateUserInterests": {
            "type": "object",
            "properties": {
                "interests": {
                    "type": "array",
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.UpdateUserSkillsRequest": {
            "type": "object",
            "required": [
                "skills"
            ],
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.UserProfileRequest": {
            "type": "object",
            "required": [
                "country",
                "email",
                "fullname",
                "username"
            ],
            "properties": {
                "country": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "fullname": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.UserProfileResponse": {
            "type": "object",
            "properties": {
                "availability": {
                    "type": "boolean"
                },
                "bio": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "fullName": {
                    "type": "string"
                },
                "gitUserName": {
                    "type": "string"
                },
                "gituser": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "interests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userName": {
                    "type": "string"
                }
            }
        },
        "schema.ViewChat": {
            "type": "object",
            "properties": {
                "cid": {
                    "type": "string"
                },
                "group": {
                    "type": "boolean"
                },
                "message": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewMessage"
                    }
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ViewFriends": {
            "type": "object",
            "properties": {
                "bio": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.ViewMessage": {
            "type": "object",
            "properties": {
                "edited": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                },
                "sent": {
                    "type": "string"
                },
                "uid": {
                    "type": "string"
                }
            }
        },
        "schema.ViewPlansResp": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "integer",
                    "format": "int64"
                },
                "currency": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "interval": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ViewProjectApplication": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "reqID": {
                    "type": "string"
                },
                "sent": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.ViewRepo": {
            "type": "object",
            "properties": {
                "html_url": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ViewSubscriptions": {
            "type": "object",
            "properties": {
                "end": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "start": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "",
	BasePath:         "",
	Schemes:          []string{},
	Title:            "FindMe API",
	Description:      "API documentation for FindMe application.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
```

## File: docs/swagger.json
```json
{
    "swagger": "2.0",
    "info": {
        "description": "API documentation for FindMe application.",
        "title": "FindMe API",
        "contact": {},
        "version": "1.0"
    },
    "paths": {
        "/api/msg/add-user": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for adding users to a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Add a user to a group chat",
                "parameters": [
                    {
                        "description": "Chat payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.AddUserChat"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User Added",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/delete-chat": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a group chat owned by the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Delete a group chat",
                "parameters": [
                    {
                        "type": "string",
                        "description": "chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Chat deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/delete-message": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a sent message of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Delete a sent message",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Msg ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Message deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/edit-message": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing a sent message",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Editing a sent message",
                "parameters": [
                    {
                        "description": "Message payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.EditMessage"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Message edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocMsgResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/leave-chat": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for leaving a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Leave a group chat",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Chat removed"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/open-chat": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for opening a chat between users with IDs.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Open a chat between users",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Chat opened",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewChatHistory"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/remove-user": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for removing a user from a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Remove a user from a group",
                "parameters": [
                    {
                        "description": "Chat payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.AddUserChat"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "User removed"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/rename-chat": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for renaming a group chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Renaming a group chat",
                "parameters": [
                    {
                        "description": "Chat payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.RenameChat"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Chat Updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/send-message": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for sending a message to a chat",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Sending of message to a chat",
                "parameters": [
                    {
                        "description": "Message payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.NewMessage"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Message Sent",
                        "schema": {
                            "$ref": "#/definitions/schema.DocMsgResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/transfer-owner": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for transferring the ownership of a group chat to another user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Transfer group chat ownership to another user",
                "parameters": [
                    {
                        "description": "payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.AddUserChat"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Ownership Transferred",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/view-chats": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for fetching all chats of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "Fetch the current user chats",
                "responses": {
                    "200": {
                        "description": "User chats",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewAllChats"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/view-hist": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to view all messages in a chat (the chat history)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "View All messages in a chat",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Chat history",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewChatHistory"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/msg/ws/chat": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint that upgrades client to a websocket connection for real-time chatting experience",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Msg"
                ],
                "summary": "A websocket message hub for real-time chatting",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Chat ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "101": {
                        "description": "Switching Protocols",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/apply": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for applying to a project to work on",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Apply for a project to work on",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Application payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.ProjectApplication"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Applied successfully",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectApplication"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing record",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/clear-application": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for clearing all applications on a project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Clear all applications on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Applications cleared"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/create": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for creating a new project for the current user it internally calls a service to create a vector for the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Create a new project",
                "parameters": [
                    {
                        "description": "Project payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.NewProjectRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Project created",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/delete-application": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a sent project application for the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Delete a send project application",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Request deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/edit": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing major details of a project it internally calls a service to update the vector for the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Editing details of a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Project payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.NewProjectRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Project Edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/edit-status": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing the availability status of a project it internally calls a service to update the vector for the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Editing the availability of a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Status",
                        "name": "staus",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Project edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/edit-view": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for editing the number of views on a project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Editing the number of views on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Project view edited",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/posts/all": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for retreiving all current user projects",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Retreive all current user projects",
                "responses": {
                    "200": {
                        "description": "Fetched all projects",
                        "schema": {
                            "$ref": "#/definitions/schema.DocAllProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/recommend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for recommending users for a project using ai",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Recommends users to work on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Users Retrieved",
                        "schema": {
                            "$ref": "#/definitions/schema.DocRecUsersResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment Required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/save-post": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for adding a project to the current user bookmarks",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Bookmark a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Bookmarked project",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/tags": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for project with tags associated with the project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Search for a project with tags/skills",
                "parameters": [
                    {
                        "description": "Tags",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SearchProjectWithTags"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Projects",
                        "schema": {
                            "$ref": "#/definitions/schema.DocAllProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/update-application": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating a project application status to accepted or rejected",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "Updating a project application status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Request status",
                        "name": "status",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.RejectApplication"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Status Updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing a single project in details by using the project ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View a single project with ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Fetched project",
                        "schema": {
                            "$ref": "#/definitions/schema.DocDetailedProjectResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view-application": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the applications on a single project",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View all applications on a project",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Project applications",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewProjectApplications"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view-applications": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all sent and received project applications",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View all project applications sent and received",
                "responses": {
                    "200": {
                        "description": "Fetched applications",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewAllProjectApplication"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/post/view/saved-post": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to view all of the bookmarked projects of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Project"
                ],
                "summary": "View all current user bookmarked projects",
                "responses": {
                    "200": {
                        "description": "Bookmarked projects",
                        "schema": {
                            "$ref": "#/definitions/schema.DocAllProjectResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/cancel-sub": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for canceling a subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint for canceling a subscription",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Failed communication with external service",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/enable-sub": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for re enabling a subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint for enabling a subscription",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Failed communication with external service",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/initialize": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for initializing a transaction on paystack to receive a checkout url for payment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint for initializing a transaction on paystack",
                "parameters": [
                    {
                        "type": "string",
                        "description": "amount",
                        "name": "amount",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "plan",
                        "name": "plan",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocInitTranscResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Query",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/retry-payment": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for retrying a failed subscription payment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "Retries a failed payment for subscription",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Sub ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocMsgResResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload / response",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "External server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/update-card": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "This is an endpoint for retrieving link for updating card details used for transaction on paystack",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "This is an endpoint for udpating card details on paystack",
                "responses": {
                    "200": {
                        "description": "Link Generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUpdateCardSub"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Failed communication with external service",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/view": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint that retrieves all the transactions of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "Retrieves the transactions for a user",
                "responses": {
                    "200": {
                        "description": "Transactions retrieved",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTranscResposne"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/view/plans": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to view available plans",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "An endpoint to view available plans",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewPlansResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/transc/webhook": {
            "post": {
                "description": "An endpoint for intercepting the paystack webhooks transaction events",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Transaction"
                ],
                "summary": "This is a webhook for the paystack transaction events",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/connect-github": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An redirecting endpoint for connecting a github account to the current user account",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Connecting github account to user account",
                "responses": {
                    "307": {
                        "description": "Redirecting",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-friend-req": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a sent friend request",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a sent friend req",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request id",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Request deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission Denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-skills": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint to delete some skills from the current user skills it internally calls a service to update the user vector",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete skills from the user skills",
                "parameters": [
                    {
                        "description": "Skills",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.DeleteUserSkillsRequest"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Skills Deleted"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-user": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting the current user account it internally calls a service to delete the vector of the user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a user account",
                "responses": {
                    "204": {
                        "description": "Account deleted"
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/delete-user-friend": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for deleting a friend from the users friend list",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete a existing friendship",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User id",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Chat id",
                        "name": "chat_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Friend deleted"
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/get-user": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for fetching a user by their ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get a user by their ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "user and projects fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid user id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/payment-info": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for retreiving a user saved payment info used for subscription",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Retreives a user saved payment info used for subscription",
                "responses": {
                    "200": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewPaymentInfo"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/profile": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for fetching the currently logged in user profile details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get the logged in user info",
                "responses": {
                    "200": {
                        "description": "user fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUserResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/recommend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for recommending projects for a user to work on using ai",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Recommends projects for a user to work on",
                "responses": {
                    "200": {
                        "description": "Projects Retreived",
                        "schema": {
                            "$ref": "#/definitions/schema.DocRecProjectsResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "402": {
                        "description": "Payment Required",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/reset-password": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for reseting the user password with a reset jwt token gotten from the verify-otp route",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Reset user password through forgot password route",
                "parameters": [
                    {
                        "description": "new password",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.ResetPassword"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "reset successful",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid password",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/search": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for users with their skills to show their profiles",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Search for users by skills/tags",
                "parameters": [
                    {
                        "description": "Skills",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SearchUserbySkills"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "users fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUsersSearch"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/send-user-req": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for sending friend requests to users for connecting",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Send a Friend req to a user",
                "parameters": [
                    {
                        "description": "Request",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SendFriendReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Request sent",
                        "schema": {
                            "$ref": "#/definitions/schema.DocFriendReqStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing Friend Req / Friend",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-availability/{status}": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the Availability status of the current user to either true or false it internally calls a service to update the user vector payload",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update Availability status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Availability status",
                        "name": "status",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Status updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-bio": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user bio information it internally calls a service to update the vector for the user.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user bio",
                "parameters": [
                    {
                        "description": "new details",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdateUserBio"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-interest": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user interests it internally calls a service to update the vector for the user.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user interests",
                "parameters": [
                    {
                        "description": "new details",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdateUserInterests"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-password": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user password",
                "parameters": [
                    {
                        "description": "new password",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdatePassword"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "password updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-profile": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the logged-in user profile details",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update the current user profile details",
                "parameters": [
                    {
                        "description": "new details",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UserProfileRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "User updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocUserResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing username / email",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-skills": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the skills of the current user it internally calls a service to update the user vector",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update User skills",
                "parameters": [
                    {
                        "description": "Skills",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.UpdateUserSkillsRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Skills updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocSkillsResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/update-user-req": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for updating the status of received friend req to rejected / accepted",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update a friend req status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Request ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Request status updated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocFriendReqAccept"
                        }
                    },
                    "400": {
                        "description": "Invalid status / id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "403": {
                        "description": "Permission Denied",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for a user with their username to show their projects and profile",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Search for user with their username",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Username",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "user and projects fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid username",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-friend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the friends for the currently logged in user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "View all friends for the logged in user",
                "responses": {
                    "200": {
                        "description": "User friends fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewFriends"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-git": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for searching for a user with their git username to show their projects and profile",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Search for user with their git username",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Git Username",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "user and projects fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocProjectUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid git username",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-repo": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing the user public repo to tag to a project.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Git"
                ],
                "summary": "View Github public repo for current user",
                "responses": {
                    "200": {
                        "description": "Repo fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewRepos"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-subs": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing the history of a user's subsciption",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Views a user subscription history",
                "responses": {
                    "200": {
                        "description": "Subscriptions",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewSubscriptions"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-user-friend": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the friends of a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "View all friends of a user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User friends fetched",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewFriends"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/user/view-user-req": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "An endpoint for viewing all the looged in users friend reqs (sent and received)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "View All friend reqs",
                "responses": {
                    "200": {
                        "description": "Fetched requests",
                        "schema": {
                            "$ref": "#/definitions/schema.DocViewFriendReqs"
                        }
                    },
                    "401": {
                        "description": "Unauthorized user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/auth/github/callback": {
            "get": {
                "description": "An endpoint for selecting the callback for login, connect github endpoint",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Callback for the github sign-in / connect",
                "responses": {
                    "200": {
                        "description": "Token generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "202": {
                        "description": "Github Connected",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid id",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "409": {
                        "description": "Existing record",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/forgot-password": {
            "post": {
                "description": "An endpoint for getting an otp for reseting the user password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get a OTP for reseting user password",
                "parameters": [
                    {
                        "description": "User email",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.ForgotPasswordEmail"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Email sent to user",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Invalid Email",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/github-signup": {
            "get": {
                "description": "A redirecting endpoint for sign-in / sign-up with github it calls a service internally to create a vector for new users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Signing up user using github",
                "responses": {
                    "307": {
                        "description": "Redirecting",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/health/detailed": {
            "get": {
                "description": "This gives a detailed health status of the running services",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Checks the health of the services running",
                "responses": {
                    "200": {
                        "description": "Service Healthy",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "503": {
                        "description": "Service Degraded",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/login": {
            "post": {
                "description": "Log in endpoint for existing users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User login payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "jwt token generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "404": {
                        "description": "Record not found",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/signup": {
            "post": {
                "description": "Sign up endpoint for new users it internally calls a service to create a vector for the user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User signup payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schema.SignupRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "jwt token generated",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "409": {
                        "description": "Existing email or username",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "422": {
                        "description": "Failed to parse payload",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "Server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        },
        "/verify-otp": {
            "get": {
                "description": "An endpoint to verify sent otp to create reset jwt token for reseting user password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Verify Sent otp to reset password",
                "parameters": [
                    {
                        "type": "string",
                        "description": "otp",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "reset token",
                        "schema": {
                            "$ref": "#/definitions/schema.DocTokenResponse"
                        }
                    },
                    "400": {
                        "description": "invalid otp",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "404": {
                        "description": "invalid otp",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    },
                    "500": {
                        "description": "server error",
                        "schema": {
                            "$ref": "#/definitions/schema.DocNormalResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "schema.AddUserChat": {
            "type": "object",
            "required": [
                "chat_id",
                "user_id"
            ],
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "user_id": {
                    "type": "string"
                }
            }
        },
        "schema.ApplicationProjectResponse": {
            "type": "object",
            "properties": {
                "applications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewProjectApplication"
                    }
                }
            }
        },
        "schema.DeleteUserSkillsRequest": {
            "type": "object",
            "required": [
                "skills"
            ],
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.DetailedProjectResponse": {
            "type": "object",
            "properties": {
                "available": {
                    "type": "boolean"
                },
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "gitLink": {
                    "type": "string"
                },
                "gitProject": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "schema.DocAllProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ProjectResponse"
                    }
                }
            }
        },
        "schema.DocDetailedProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "$ref": "#/definitions/schema.DetailedProjectResponse"
                }
            }
        },
        "schema.DocFriendReqAccept": {
            "type": "object",
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.DocFriendReqStatus": {
            "type": "object",
            "properties": {
                "req": {
                    "$ref": "#/definitions/schema.FriendReqStatus"
                }
            }
        },
        "schema.DocInitTranscResponse": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                },
                "uri": {
                    "type": "string"
                }
            }
        },
        "schema.DocMsgResResponse": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string"
                },
                "reason": {
                    "type": "string"
                }
            }
        },
        "schema.DocMsgResponse": {
            "type": "object",
            "properties": {
                "msg": {
                    "$ref": "#/definitions/schema.ViewMessage"
                }
            }
        },
        "schema.DocNormalResponse": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.DocProjectApplication": {
            "type": "object",
            "properties": {
                "project_req": {
                    "$ref": "#/definitions/schema.ViewProjectApplication"
                }
            }
        },
        "schema.DocProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "$ref": "#/definitions/schema.ProjectResponse"
                }
            }
        },
        "schema.DocProjectUserResponse": {
            "type": "object",
            "properties": {
                "posts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ProjectResponse"
                    }
                },
                "user": {
                    "$ref": "#/definitions/schema.UserProfileResponse"
                }
            }
        },
        "schema.DocRecProjectsResponse": {
            "type": "object",
            "properties": {
                "projects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.RecProjectResponse"
                    }
                }
            }
        },
        "schema.DocRecUsersResponse": {
            "type": "object",
            "properties": {
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.RecProfileResponse"
                    }
                }
            }
        },
        "schema.DocSkillsResponse": {
            "type": "object",
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.DocTokenResponse": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "schema.DocTranscResposne": {
            "type": "object",
            "properties": {
                "transactions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.TransactionResponse"
                    }
                }
            }
        },
        "schema.DocUpdateCardSub": {
            "type": "object",
            "properties": {
                "link": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.DocUserResponse": {
            "type": "object",
            "properties": {
                "user": {
                    "$ref": "#/definitions/schema.UserProfileResponse"
                }
            }
        },
        "schema.DocUsersSearch": {
            "type": "object",
            "properties": {
                "users": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.SearchUser"
                    }
                }
            }
        },
        "schema.DocViewAllChats": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewChat"
                    }
                }
            }
        },
        "schema.DocViewAllProjectApplication": {
            "type": "object",
            "properties": {
                "project": {
                    "type": "object",
                    "additionalProperties": {}
                }
            }
        },
        "schema.DocViewChatHistory": {
            "type": "object",
            "properties": {
                "msg": {
                    "$ref": "#/definitions/schema.ViewChat"
                }
            }
        },
        "schema.DocViewFriendReqs": {
            "type": "object",
            "properties": {
                "rec_req": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.FriendReqStatus"
                    }
                },
                "sent_req": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.FriendReqStatus"
                    }
                }
            }
        },
        "schema.DocViewFriends": {
            "type": "object",
            "properties": {
                "friends": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewFriends"
                    }
                }
            }
        },
        "schema.DocViewPaymentInfo": {
            "type": "object",
            "properties": {
                "info": {
                    "$ref": "#/definitions/schema.PaymentInfo"
                }
            }
        },
        "schema.DocViewPlansResponse": {
            "type": "object",
            "properties": {
                "plans": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewPlansResp"
                    }
                }
            }
        },
        "schema.DocViewProjectApplications": {
            "type": "object",
            "properties": {
                "req": {
                    "$ref": "#/definitions/schema.ApplicationProjectResponse"
                }
            }
        },
        "schema.DocViewRepos": {
            "type": "object",
            "properties": {
                "repos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewRepo"
                    }
                }
            }
        },
        "schema.DocViewSubscriptions": {
            "type": "object",
            "properties": {
                "subs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewSubscriptions"
                    }
                }
            }
        },
        "schema.EditMessage": {
            "type": "object",
            "required": [
                "msg",
                "msg_id"
            ],
            "properties": {
                "msg": {
                    "type": "string"
                },
                "msg_id": {
                    "type": "string"
                }
            }
        },
        "schema.ForgotPasswordEmail": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        },
        "schema.FriendReqStatus": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "sent": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.LoginRequest": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.NewMessage": {
            "type": "object",
            "required": [
                "chat_id",
                "msg"
            ],
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.NewProjectRequest": {
            "type": "object",
            "required": [
                "description",
                "tags",
                "title"
            ],
            "properties": {
                "description": {
                    "type": "string"
                },
                "git": {
                    "type": "boolean"
                },
                "git_link": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "schema.PaymentInfo": {
            "type": "object",
            "properties": {
                "card": {
                    "type": "string"
                },
                "last4": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "nextPaymentDate": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                }
            }
        },
        "schema.ProjectApplication": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string",
                    "maxLength": 50
                }
            }
        },
        "schema.ProjectResponse": {
            "type": "object",
            "properties": {
                "available": {
                    "type": "boolean"
                },
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "schema.RecProfileResponse": {
            "type": "object",
            "properties": {
                "score": {
                    "type": "number",
                    "format": "float32"
                },
                "user": {
                    "$ref": "#/definitions/schema.UserProfileResponse"
                }
            }
        },
        "schema.RecProjectResponse": {
            "type": "object",
            "properties": {
                "project": {
                    "$ref": "#/definitions/schema.ProjectResponse"
                },
                "score": {
                    "type": "number",
                    "format": "float32"
                }
            }
        },
        "schema.RejectApplication": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "string"
                }
            }
        },
        "schema.RenameChat": {
            "type": "object",
            "required": [
                "chat_id",
                "name"
            ],
            "properties": {
                "chat_id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ResetPassword": {
            "type": "object",
            "required": [
                "password"
            ],
            "properties": {
                "password": {
                    "type": "string",
                    "minLength": 8
                }
            }
        },
        "schema.SearchProjectWithTags": {
            "type": "object",
            "required": [
                "tags"
            ],
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.SearchUser": {
            "type": "object",
            "properties": {
                "availability": {
                    "type": "boolean"
                },
                "bio": {
                    "type": "string"
                },
                "gitUser": {
                    "type": "boolean"
                },
                "gitUserName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "interests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userName": {
                    "type": "string"
                }
            }
        },
        "schema.SearchUserbySkills": {
            "type": "object",
            "required": [
                "skills"
            ],
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.SendFriendReq": {
            "type": "object",
            "required": [
                "uid"
            ],
            "properties": {
                "msg": {
                    "type": "string",
                    "maxLength": 50
                },
                "uid": {
                    "type": "string"
                }
            }
        },
        "schema.SignupRequest": {
            "type": "object",
            "required": [
                "country",
                "email",
                "fullname",
                "password",
                "username"
            ],
            "properties": {
                "bio": {
                    "type": "string",
                    "maxLength": 50
                },
                "country": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "fullname": {
                    "type": "string"
                },
                "interests": {
                    "type": "array",
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    }
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.TransactionResponse": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "integer",
                    "format": "int64"
                },
                "channel": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "paidAt": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "schema.UpdatePassword": {
            "type": "object",
            "required": [
                "new_password",
                "password"
            ],
            "properties": {
                "new_password": {
                    "type": "string",
                    "minLength": 8
                },
                "password": {
                    "type": "string"
                }
            }
        },
        "schema.UpdateUserBio": {
            "type": "object",
            "properties": {
                "bio": {
                    "type": "string",
                    "maxLength": 50
                }
            }
        },
        "schema.UpdateUserInterests": {
            "type": "object",
            "properties": {
                "interests": {
                    "type": "array",
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.UpdateUserSkillsRequest": {
            "type": "object",
            "required": [
                "skills"
            ],
            "properties": {
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "schema.UserProfileRequest": {
            "type": "object",
            "required": [
                "country",
                "email",
                "fullname",
                "username"
            ],
            "properties": {
                "country": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "fullname": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.UserProfileResponse": {
            "type": "object",
            "properties": {
                "availability": {
                    "type": "boolean"
                },
                "bio": {
                    "type": "string"
                },
                "country": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "fullName": {
                    "type": "string"
                },
                "gitUserName": {
                    "type": "string"
                },
                "gituser": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "interests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "skills": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "userName": {
                    "type": "string"
                }
            }
        },
        "schema.ViewChat": {
            "type": "object",
            "properties": {
                "cid": {
                    "type": "string"
                },
                "group": {
                    "type": "boolean"
                },
                "message": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/schema.ViewMessage"
                    }
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ViewFriends": {
            "type": "object",
            "properties": {
                "bio": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.ViewMessage": {
            "type": "object",
            "properties": {
                "edited": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "msg": {
                    "type": "string"
                },
                "sent": {
                    "type": "string"
                },
                "uid": {
                    "type": "string"
                }
            }
        },
        "schema.ViewPlansResp": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "integer",
                    "format": "int64"
                },
                "currency": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "interval": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ViewProjectApplication": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "reqID": {
                    "type": "string"
                },
                "sent": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "schema.ViewRepo": {
            "type": "object",
            "properties": {
                "html_url": {
                    "type": "string"
                },
                "language": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "schema.ViewSubscriptions": {
            "type": "object",
            "properties": {
                "end": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "start": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}
```

## File: docs/swagger.yaml
```yaml
definitions:
  schema.AddUserChat:
    properties:
      chat_id:
        type: string
      user_id:
        type: string
    required:
    - chat_id
    - user_id
    type: object
  schema.ApplicationProjectResponse:
    properties:
      applications:
        items:
          $ref: '#/definitions/schema.ViewProjectApplication'
        type: array
    type: object
  schema.DeleteUserSkillsRequest:
    properties:
      skills:
        items:
          type: string
        type: array
    required:
    - skills
    type: object
  schema.DetailedProjectResponse:
    properties:
      available:
        type: boolean
      createdAt:
        type: string
      description:
        type: string
      gitLink:
        type: string
      gitProject:
        type: boolean
      id:
        type: string
      tags:
        items:
          type: string
        type: array
      title:
        type: string
      updatedAt:
        type: string
      username:
        type: string
      views:
        type: integer
    type: object
  schema.DocAllProjectResponse:
    properties:
      project:
        items:
          $ref: '#/definitions/schema.ProjectResponse'
        type: array
    type: object
  schema.DocDetailedProjectResponse:
    properties:
      project:
        $ref: '#/definitions/schema.DetailedProjectResponse'
    type: object
  schema.DocFriendReqAccept:
    properties:
      chat_id:
        type: string
      msg:
        type: string
    type: object
  schema.DocFriendReqStatus:
    properties:
      req:
        $ref: '#/definitions/schema.FriendReqStatus'
    type: object
  schema.DocInitTranscResponse:
    properties:
      token:
        type: string
      uri:
        type: string
    type: object
  schema.DocMsgResResponse:
    properties:
      msg:
        type: string
      reason:
        type: string
    type: object
  schema.DocMsgResponse:
    properties:
      msg:
        $ref: '#/definitions/schema.ViewMessage'
    type: object
  schema.DocNormalResponse:
    properties:
      msg:
        type: string
    type: object
  schema.DocProjectApplication:
    properties:
      project_req:
        $ref: '#/definitions/schema.ViewProjectApplication'
    type: object
  schema.DocProjectResponse:
    properties:
      project:
        $ref: '#/definitions/schema.ProjectResponse'
    type: object
  schema.DocProjectUserResponse:
    properties:
      posts:
        items:
          $ref: '#/definitions/schema.ProjectResponse'
        type: array
      user:
        $ref: '#/definitions/schema.UserProfileResponse'
    type: object
  schema.DocRecProjectsResponse:
    properties:
      projects:
        items:
          $ref: '#/definitions/schema.RecProjectResponse'
        type: array
    type: object
  schema.DocRecUsersResponse:
    properties:
      users:
        items:
          $ref: '#/definitions/schema.RecProfileResponse'
        type: array
    type: object
  schema.DocSkillsResponse:
    properties:
      skills:
        items:
          type: string
        type: array
    type: object
  schema.DocTokenResponse:
    properties:
      token:
        type: string
    type: object
  schema.DocTranscResposne:
    properties:
      transactions:
        items:
          $ref: '#/definitions/schema.TransactionResponse'
        type: array
    type: object
  schema.DocUpdateCardSub:
    properties:
      link:
        type: string
      msg:
        type: string
    type: object
  schema.DocUserResponse:
    properties:
      user:
        $ref: '#/definitions/schema.UserProfileResponse'
    type: object
  schema.DocUsersSearch:
    properties:
      users:
        items:
          $ref: '#/definitions/schema.SearchUser'
        type: array
    type: object
  schema.DocViewAllChats:
    properties:
      msg:
        items:
          $ref: '#/definitions/schema.ViewChat'
        type: array
    type: object
  schema.DocViewAllProjectApplication:
    properties:
      project:
        additionalProperties: {}
        type: object
    type: object
  schema.DocViewChatHistory:
    properties:
      msg:
        $ref: '#/definitions/schema.ViewChat'
    type: object
  schema.DocViewFriendReqs:
    properties:
      rec_req:
        items:
          $ref: '#/definitions/schema.FriendReqStatus'
        type: array
      sent_req:
        items:
          $ref: '#/definitions/schema.FriendReqStatus'
        type: array
    type: object
  schema.DocViewFriends:
    properties:
      friends:
        items:
          $ref: '#/definitions/schema.ViewFriends'
        type: array
    type: object
  schema.DocViewPaymentInfo:
    properties:
      info:
        $ref: '#/definitions/schema.PaymentInfo'
    type: object
  schema.DocViewPlansResponse:
    properties:
      plans:
        items:
          $ref: '#/definitions/schema.ViewPlansResp'
        type: array
    type: object
  schema.DocViewProjectApplications:
    properties:
      req:
        $ref: '#/definitions/schema.ApplicationProjectResponse'
    type: object
  schema.DocViewRepos:
    properties:
      repos:
        items:
          $ref: '#/definitions/schema.ViewRepo'
        type: array
    type: object
  schema.DocViewSubscriptions:
    properties:
      subs:
        items:
          $ref: '#/definitions/schema.ViewSubscriptions'
        type: array
    type: object
  schema.EditMessage:
    properties:
      msg:
        type: string
      msg_id:
        type: string
    required:
    - msg
    - msg_id
    type: object
  schema.ForgotPasswordEmail:
    properties:
      email:
        type: string
    required:
    - email
    type: object
  schema.FriendReqStatus:
    properties:
      id:
        type: string
      message:
        type: string
      sent:
        type: string
      status:
        type: string
      username:
        type: string
    type: object
  schema.LoginRequest:
    properties:
      password:
        type: string
      username:
        type: string
    required:
    - password
    - username
    type: object
  schema.NewMessage:
    properties:
      chat_id:
        type: string
      msg:
        type: string
    required:
    - chat_id
    - msg
    type: object
  schema.NewProjectRequest:
    properties:
      description:
        type: string
      git:
        type: boolean
      git_link:
        type: string
      tags:
        items:
          type: string
        type: array
      title:
        type: string
    required:
    - description
    - tags
    - title
    type: object
  schema.PaymentInfo:
    properties:
      card:
        type: string
      last4:
        type: string
      month:
        type: string
      nextPaymentDate:
        type: string
      year:
        type: string
    type: object
  schema.ProjectApplication:
    properties:
      msg:
        maxLength: 50
        type: string
    type: object
  schema.ProjectResponse:
    properties:
      available:
        type: boolean
      createdAt:
        type: string
      description:
        type: string
      id:
        type: string
      tags:
        items:
          type: string
        type: array
      title:
        type: string
      updatedAt:
        type: string
      views:
        type: integer
    type: object
  schema.RecProfileResponse:
    properties:
      score:
        format: float32
        type: number
      user:
        $ref: '#/definitions/schema.UserProfileResponse'
    type: object
  schema.RecProjectResponse:
    properties:
      project:
        $ref: '#/definitions/schema.ProjectResponse'
      score:
        format: float32
        type: number
    type: object
  schema.RejectApplication:
    properties:
      msg:
        type: string
    type: object
  schema.RenameChat:
    properties:
      chat_id:
        type: string
      name:
        type: string
    required:
    - chat_id
    - name
    type: object
  schema.ResetPassword:
    properties:
      password:
        minLength: 8
        type: string
    required:
    - password
    type: object
  schema.SearchProjectWithTags:
    properties:
      tags:
        items:
          type: string
        type: array
    required:
    - tags
    type: object
  schema.SearchUser:
    properties:
      availability:
        type: boolean
      bio:
        type: string
      gitUser:
        type: boolean
      gitUserName:
        type: string
      id:
        type: string
      interests:
        items:
          type: string
        type: array
      skills:
        items:
          type: string
        type: array
      userName:
        type: string
    type: object
  schema.SearchUserbySkills:
    properties:
      skills:
        items:
          type: string
        type: array
    required:
    - skills
    type: object
  schema.SendFriendReq:
    properties:
      msg:
        maxLength: 50
        type: string
      uid:
        type: string
    required:
    - uid
    type: object
  schema.SignupRequest:
    properties:
      bio:
        maxLength: 50
        type: string
      country:
        type: string
      email:
        type: string
      fullname:
        type: string
      interests:
        items:
          type: string
        maxItems: 5
        type: array
      password:
        minLength: 8
        type: string
      skills:
        items:
          type: string
        type: array
      username:
        type: string
    required:
    - country
    - email
    - fullname
    - password
    - username
    type: object
  schema.TransactionResponse:
    properties:
      amount:
        format: int64
        type: integer
      channel:
        type: string
      id:
        type: string
      paidAt:
        type: string
      status:
        type: string
    type: object
  schema.UpdatePassword:
    properties:
      new_password:
        minLength: 8
        type: string
      password:
        type: string
    required:
    - new_password
    - password
    type: object
  schema.UpdateUserBio:
    properties:
      bio:
        maxLength: 50
        type: string
    type: object
  schema.UpdateUserInterests:
    properties:
      interests:
        items:
          type: string
        maxItems: 5
        type: array
    type: object
  schema.UpdateUserSkillsRequest:
    properties:
      skills:
        items:
          type: string
        type: array
    required:
    - skills
    type: object
  schema.UserProfileRequest:
    properties:
      country:
        type: string
      email:
        type: string
      fullname:
        type: string
      username:
        type: string
    required:
    - country
    - email
    - fullname
    - username
    type: object
  schema.UserProfileResponse:
    properties:
      availability:
        type: boolean
      bio:
        type: string
      country:
        type: string
      email:
        type: string
      fullName:
        type: string
      gitUserName:
        type: string
      gituser:
        type: boolean
      id:
        type: string
      interests:
        items:
          type: string
        type: array
      skills:
        items:
          type: string
        type: array
      userName:
        type: string
    type: object
  schema.ViewChat:
    properties:
      cid:
        type: string
      group:
        type: boolean
      message:
        items:
          $ref: '#/definitions/schema.ViewMessage'
        type: array
      name:
        type: string
    type: object
  schema.ViewFriends:
    properties:
      bio:
        type: string
      id:
        type: string
      username:
        type: string
    type: object
  schema.ViewMessage:
    properties:
      edited:
        type: string
      id:
        type: string
      msg:
        type: string
      sent:
        type: string
      uid:
        type: string
    type: object
  schema.ViewPlansResp:
    properties:
      amount:
        format: int64
        type: integer
      currency:
        type: string
      id:
        type: string
      interval:
        type: string
      name:
        type: string
    type: object
  schema.ViewProjectApplication:
    properties:
      message:
        type: string
      reqID:
        type: string
      sent:
        type: string
      status:
        type: string
      username:
        type: string
    type: object
  schema.ViewRepo:
    properties:
      html_url:
        type: string
      language:
        type: string
      name:
        type: string
    type: object
  schema.ViewSubscriptions:
    properties:
      end:
        type: string
      id:
        type: string
      start:
        type: string
    type: object
info:
  contact: {}
  description: API documentation for FindMe application.
  title: FindMe API
  version: "1.0"
paths:
  /api/msg/add-user:
    put:
      consumes:
      - application/json
      description: An endpoint for adding users to a group chat
      parameters:
      - description: Chat payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.AddUserChat'
      produces:
      - application/json
      responses:
        "202":
          description: User Added
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Add a user to a group chat
      tags:
      - Msg
  /api/msg/delete-chat:
    delete:
      consumes:
      - application/json
      description: An endpoint for deleting a group chat owned by the current user
      parameters:
      - description: chat ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Chat deleted
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete a group chat
      tags:
      - Msg
  /api/msg/delete-message:
    delete:
      consumes:
      - application/json
      description: An endpoint for deleting a sent message of the current user
      parameters:
      - description: Msg ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Message deleted
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete a sent message
      tags:
      - Msg
  /api/msg/edit-message:
    patch:
      consumes:
      - application/json
      description: An endpoint for editing a sent message
      parameters:
      - description: Message payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.EditMessage'
      produces:
      - application/json
      responses:
        "202":
          description: Message edited
          schema:
            $ref: '#/definitions/schema.DocMsgResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Editing a sent message
      tags:
      - Msg
  /api/msg/leave-chat:
    delete:
      consumes:
      - application/json
      description: An endpoint for leaving a group chat
      parameters:
      - description: Chat ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Chat removed
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Leave a group chat
      tags:
      - Msg
  /api/msg/open-chat:
    get:
      consumes:
      - application/json
      description: An endpoint for opening a chat between users with IDs.
      parameters:
      - description: User ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Chat opened
          schema:
            $ref: '#/definitions/schema.DocViewChatHistory'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Open a chat between users
      tags:
      - Msg
  /api/msg/remove-user:
    delete:
      consumes:
      - application/json
      description: An endpoint for removing a user from a group chat
      parameters:
      - description: Chat payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.AddUserChat'
      produces:
      - application/json
      responses:
        "204":
          description: User removed
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Remove a user from a group
      tags:
      - Msg
  /api/msg/rename-chat:
    patch:
      consumes:
      - application/json
      description: An endpoint for renaming a group chat
      parameters:
      - description: Chat payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.RenameChat'
      produces:
      - application/json
      responses:
        "202":
          description: Chat Updated
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Renaming a group chat
      tags:
      - Msg
  /api/msg/send-message:
    post:
      consumes:
      - application/json
      description: An endpoint for sending a message to a chat
      parameters:
      - description: Message payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.NewMessage'
      produces:
      - application/json
      responses:
        "201":
          description: Message Sent
          schema:
            $ref: '#/definitions/schema.DocMsgResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Sending of message to a chat
      tags:
      - Msg
  /api/msg/transfer-owner:
    patch:
      consumes:
      - application/json
      description: An endpoint for transferring the ownership of a group chat to another
        user
      parameters:
      - description: payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.AddUserChat'
      produces:
      - application/json
      responses:
        "202":
          description: Ownership Transferred
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Transfer group chat ownership to another user
      tags:
      - Msg
  /api/msg/view-chats:
    get:
      consumes:
      - application/json
      description: An endpoint for fetching all chats of the current user
      produces:
      - application/json
      responses:
        "200":
          description: User chats
          schema:
            $ref: '#/definitions/schema.DocViewAllChats'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Fetch the current user chats
      tags:
      - Msg
  /api/msg/view-hist:
    get:
      consumes:
      - application/json
      description: An endpoint to view all messages in a chat (the chat history)
      parameters:
      - description: Chat ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Chat history
          schema:
            $ref: '#/definitions/schema.DocViewChatHistory'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View All messages in a chat
      tags:
      - Msg
  /api/msg/ws/chat:
    get:
      consumes:
      - application/json
      description: An endpoint that upgrades client to a websocket connection for
        real-time chatting experience
      parameters:
      - description: Chat ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "101":
          description: Switching Protocols
          schema:
            type: string
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: A websocket message hub for real-time chatting
      tags:
      - Msg
  /api/post/apply:
    post:
      consumes:
      - application/json
      description: An endpoint for applying to a project to work on
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      - description: Application payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.ProjectApplication'
      produces:
      - application/json
      responses:
        "200":
          description: Applied successfully
          schema:
            $ref: '#/definitions/schema.DocProjectApplication'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "409":
          description: Existing record
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Apply for a project to work on
      tags:
      - Project
  /api/post/clear-application:
    delete:
      consumes:
      - application/json
      description: An endpoint for clearing all applications on a project
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Applications cleared
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Clear all applications on a project
      tags:
      - Project
  /api/post/create:
    post:
      consumes:
      - application/json
      description: An endpoint for creating a new project for the current user it
        internally calls a service to create a vector for the project
      parameters:
      - description: Project payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.NewProjectRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Project created
          schema:
            $ref: '#/definitions/schema.DocProjectResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Create a new project
      tags:
      - Project
  /api/post/delete-application:
    delete:
      consumes:
      - application/json
      description: An endpoint for deleting a sent project application for the current
        user
      parameters:
      - description: Request ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Request deleted
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete a send project application
      tags:
      - Project
  /api/post/edit:
    put:
      consumes:
      - application/json
      description: An endpoint for editing major details of a project it internally
        calls a service to update the vector for the project
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      - description: Project payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.NewProjectRequest'
      produces:
      - application/json
      responses:
        "202":
          description: Project Edited
          schema:
            $ref: '#/definitions/schema.DocProjectResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Editing details of a project
      tags:
      - Project
  /api/post/edit-status:
    patch:
      consumes:
      - application/json
      description: An endpoint for editing the availability status of a project it
        internally calls a service to update the vector for the project
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      - description: Status
        in: query
        name: staus
        required: true
        type: string
      produces:
      - application/json
      responses:
        "202":
          description: Project edited
          schema:
            $ref: '#/definitions/schema.DocProjectResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Editing the availability of a project
      tags:
      - Project
  /api/post/edit-view:
    patch:
      consumes:
      - application/json
      description: An endpoint for editing the number of views on a project
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "202":
          description: Project view edited
          schema:
            $ref: '#/definitions/schema.DocProjectResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Editing the number of views on a project
      tags:
      - Project
  /api/post/posts/all:
    get:
      consumes:
      - application/json
      description: An endpoint for retreiving all current user projects
      produces:
      - application/json
      responses:
        "200":
          description: Fetched all projects
          schema:
            $ref: '#/definitions/schema.DocAllProjectResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Retreive all current user projects
      tags:
      - Project
  /api/post/recommend:
    get:
      consumes:
      - application/json
      description: An endpoint for recommending users for a project using ai
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Users Retrieved
          schema:
            $ref: '#/definitions/schema.DocRecUsersResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "402":
          description: Payment Required
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Recommends users to work on a project
      tags:
      - Project
  /api/post/save-post:
    put:
      consumes:
      - application/json
      description: An endpoint for adding a project to the current user bookmarks
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "202":
          description: Bookmarked project
          schema:
            $ref: '#/definitions/schema.DocProjectResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Bookmark a project
      tags:
      - Project
  /api/post/tags:
    post:
      consumes:
      - application/json
      description: An endpoint for searching for project with tags associated with
        the project
      parameters:
      - description: Tags
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.SearchProjectWithTags'
      produces:
      - application/json
      responses:
        "200":
          description: Projects
          schema:
            $ref: '#/definitions/schema.DocAllProjectResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Search for a project with tags/skills
      tags:
      - Project
  /api/post/update-application:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating a project application status to accepted
        or rejected
      parameters:
      - description: Request ID
        in: query
        name: id
        required: true
        type: string
      - description: Request status
        in: query
        name: status
        required: true
        type: string
      - description: Payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.RejectApplication'
      produces:
      - application/json
      responses:
        "202":
          description: Status Updated
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Updating a project application status
      tags:
      - Project
  /api/post/view:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing a single project in details by using the
        project ID
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Fetched project
          schema:
            $ref: '#/definitions/schema.DocDetailedProjectResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View a single project with ID
      tags:
      - Project
  /api/post/view-application:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing all the applications on a single project
      parameters:
      - description: Project ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Project applications
          schema:
            $ref: '#/definitions/schema.DocViewProjectApplications'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View all applications on a project
      tags:
      - Project
  /api/post/view-applications:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing all sent and received project applications
      produces:
      - application/json
      responses:
        "200":
          description: Fetched applications
          schema:
            $ref: '#/definitions/schema.DocViewAllProjectApplication'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View all project applications sent and received
      tags:
      - Project
  /api/post/view/saved-post:
    get:
      consumes:
      - application/json
      description: An endpoint to view all of the bookmarked projects of the current
        user
      produces:
      - application/json
      responses:
        "200":
          description: Bookmarked projects
          schema:
            $ref: '#/definitions/schema.DocAllProjectResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View all current user bookmarked projects
      tags:
      - Project
  /api/transc/cancel-sub:
    patch:
      consumes:
      - application/json
      description: An endpoint for canceling a subscription
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Failed communication with external service
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: An endpoint for canceling a subscription
      tags:
      - Transaction
  /api/transc/enable-sub:
    patch:
      consumes:
      - application/json
      description: An endpoint for re enabling a subscription
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "402":
          description: Payment required
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Failed communication with external service
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: An endpoint for enabling a subscription
      tags:
      - Transaction
  /api/transc/initialize:
    get:
      consumes:
      - application/json
      description: An endpoint for initializing a transaction on paystack to receive
        a checkout url for payment
      parameters:
      - description: amount
        in: query
        name: amount
        required: true
        type: string
      - description: plan
        in: query
        name: plan
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocInitTranscResponse'
        "400":
          description: Bad Query
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Bad Gateway
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: An endpoint for initializing a transaction on paystack
      tags:
      - Transaction
  /api/transc/retry-payment:
    post:
      consumes:
      - application/json
      description: An endpoint for retrying a failed subscription payment
      parameters:
      - description: Sub ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "400":
          description: Bad Request
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "402":
          description: Payment required
          schema:
            $ref: '#/definitions/schema.DocMsgResResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload / response
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: External server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Retries a failed payment for subscription
      tags:
      - Transaction
  /api/transc/update-card:
    get:
      consumes:
      - application/json
      description: This is an endpoint for retrieving link for updating card details
        used for transaction on paystack
      produces:
      - application/json
      responses:
        "200":
          description: Link Generated
          schema:
            $ref: '#/definitions/schema.DocUpdateCardSub'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Failed communication with external service
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: This is an endpoint for udpating card details on paystack
      tags:
      - Transaction
  /api/transc/view:
    get:
      consumes:
      - application/json
      description: An endpoint that retrieves all the transactions of the current
        user
      produces:
      - application/json
      responses:
        "200":
          description: Transactions retrieved
          schema:
            $ref: '#/definitions/schema.DocTranscResposne'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Retrieves the transactions for a user
      tags:
      - Transaction
  /api/transc/view/plans:
    get:
      consumes:
      - application/json
      description: An endpoint to view available plans
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocViewPlansResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Bad Gateway
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: An endpoint to view available plans
      tags:
      - Transaction
  /api/transc/webhook:
    post:
      consumes:
      - application/json
      description: An endpoint for intercepting the paystack webhooks transaction
        events
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: This is a webhook for the paystack transaction events
      tags:
      - Transaction
  /api/user/connect-github:
    post:
      consumes:
      - application/json
      description: An redirecting endpoint for connecting a github account to the
        current user account
      produces:
      - application/json
      responses:
        "307":
          description: Redirecting
          schema:
            type: string
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Connecting github account to user account
      tags:
      - Auth
  /api/user/delete-friend-req:
    delete:
      consumes:
      - application/json
      description: An endpoint for deleting a sent friend request
      parameters:
      - description: Request id
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Request deleted
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission Denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete a sent friend req
      tags:
      - User
  /api/user/delete-skills:
    delete:
      consumes:
      - application/json
      description: An endpoint to delete some skills from the current user skills
        it internally calls a service to update the user vector
      parameters:
      - description: Skills
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.DeleteUserSkillsRequest'
      produces:
      - application/json
      responses:
        "204":
          description: Skills Deleted
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete skills from the user skills
      tags:
      - User
  /api/user/delete-user:
    delete:
      consumes:
      - application/json
      description: An endpoint for deleting the current user account it internally
        calls a service to delete the vector of the user
      produces:
      - application/json
      responses:
        "204":
          description: Account deleted
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete a user account
      tags:
      - User
  /api/user/delete-user-friend:
    delete:
      consumes:
      - application/json
      description: An endpoint for deleting a friend from the users friend list
      parameters:
      - description: User id
        in: query
        name: id
        required: true
        type: string
      - description: Chat id
        in: query
        name: chat_id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "204":
          description: Friend deleted
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Delete a existing friendship
      tags:
      - User
  /api/user/get-user:
    get:
      consumes:
      - application/json
      description: An endpoint for fetching a user by their ID
      parameters:
      - description: User ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: user and projects fetched
          schema:
            $ref: '#/definitions/schema.DocProjectUserResponse'
        "400":
          description: Invalid user id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Get a user by their ID
      tags:
      - User
  /api/user/payment-info:
    get:
      consumes:
      - application/json
      description: An endpoint for retreiving a user saved payment info used for subscription
      produces:
      - application/json
      responses:
        "200":
          description: Success
          schema:
            $ref: '#/definitions/schema.DocViewPaymentInfo'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Retreives a user saved payment info used for subscription
      tags:
      - User
  /api/user/profile:
    get:
      consumes:
      - application/json
      description: An endpoint for fetching the currently logged in user profile details
      produces:
      - application/json
      responses:
        "200":
          description: user fetched
          schema:
            $ref: '#/definitions/schema.DocUserResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Get the logged in user info
      tags:
      - User
  /api/user/recommend:
    get:
      consumes:
      - application/json
      description: An endpoint for recommending projects for a user to work on using
        ai
      produces:
      - application/json
      responses:
        "200":
          description: Projects Retreived
          schema:
            $ref: '#/definitions/schema.DocRecProjectsResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "402":
          description: Payment Required
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Recommends projects for a user to work on
      tags:
      - User
  /api/user/reset-password:
    patch:
      consumes:
      - application/json
      description: An endpoint for reseting the user password with a reset jwt token
        gotten from the verify-otp route
      parameters:
      - description: new password
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.ResetPassword'
      produces:
      - application/json
      responses:
        "202":
          description: reset successful
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid password
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Reset user password through forgot password route
      tags:
      - User
  /api/user/search:
    post:
      consumes:
      - application/json
      description: An endpoint for searching for users with their skills to show their
        profiles
      parameters:
      - description: Skills
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.SearchUserbySkills'
      produces:
      - application/json
      responses:
        "200":
          description: users fetched
          schema:
            $ref: '#/definitions/schema.DocUsersSearch'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Search for users by skills/tags
      tags:
      - User
  /api/user/send-user-req:
    post:
      consumes:
      - application/json
      description: An endpoint for sending friend requests to users for connecting
      parameters:
      - description: Request
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.SendFriendReq'
      produces:
      - application/json
      responses:
        "200":
          description: Request sent
          schema:
            $ref: '#/definitions/schema.DocFriendReqStatus'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "409":
          description: Existing Friend Req / Friend
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Send a Friend req to a user
      tags:
      - User
  /api/user/update-availability/{status}:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating the Availability status of the current
        user to either true or false it internally calls a service to update the user
        vector payload
      parameters:
      - description: Availability status
        in: path
        name: status
        required: true
        type: string
      produces:
      - application/json
      responses:
        "202":
          description: Status updated
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update Availability status
      tags:
      - User
  /api/user/update-bio:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating the logged-in user bio information it
        internally calls a service to update the vector for the user.
      parameters:
      - description: new details
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.UpdateUserBio'
      produces:
      - application/json
      responses:
        "202":
          description: User updated
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update the current user bio
      tags:
      - User
  /api/user/update-interest:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating the logged-in user interests it internally
        calls a service to update the vector for the user.
      parameters:
      - description: new details
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.UpdateUserInterests'
      produces:
      - application/json
      responses:
        "202":
          description: User updated
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update the current user interests
      tags:
      - User
  /api/user/update-password:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating the logged-in user password
      parameters:
      - description: new password
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.UpdatePassword'
      produces:
      - application/json
      responses:
        "202":
          description: password updated
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update the current user password
      tags:
      - User
  /api/user/update-profile:
    put:
      consumes:
      - application/json
      description: An endpoint for updating the logged-in user profile details
      parameters:
      - description: new details
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.UserProfileRequest'
      produces:
      - application/json
      responses:
        "202":
          description: User updated
          schema:
            $ref: '#/definitions/schema.DocUserResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "409":
          description: Existing username / email
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update the current user profile details
      tags:
      - User
  /api/user/update-skills:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating the skills of the current user it internally
        calls a service to update the user vector
      parameters:
      - description: Skills
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.UpdateUserSkillsRequest'
      produces:
      - application/json
      responses:
        "202":
          description: Skills updated
          schema:
            $ref: '#/definitions/schema.DocSkillsResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update User skills
      tags:
      - User
  /api/user/update-user-req:
    patch:
      consumes:
      - application/json
      description: An endpoint for updating the status of received friend req to rejected
        / accepted
      parameters:
      - description: Request ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "202":
          description: Request status updated
          schema:
            $ref: '#/definitions/schema.DocFriendReqAccept'
        "400":
          description: Invalid status / id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "403":
          description: Permission Denied
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Update a friend req status
      tags:
      - User
  /api/user/view:
    get:
      consumes:
      - application/json
      description: An endpoint for searching for a user with their username to show
        their projects and profile
      parameters:
      - description: Username
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: user and projects fetched
          schema:
            $ref: '#/definitions/schema.DocProjectUserResponse'
        "400":
          description: Invalid username
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Search for user with their username
      tags:
      - User
  /api/user/view-friend:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing all the friends for the currently logged
        in user
      produces:
      - application/json
      responses:
        "200":
          description: User friends fetched
          schema:
            $ref: '#/definitions/schema.DocViewFriends'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View all friends for the logged in user
      tags:
      - User
  /api/user/view-git:
    get:
      consumes:
      - application/json
      description: An endpoint for searching for a user with their git username to
        show their projects and profile
      parameters:
      - description: Git Username
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: user and projects fetched
          schema:
            $ref: '#/definitions/schema.DocProjectUserResponse'
        "400":
          description: Invalid git username
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Search for user with their git username
      tags:
      - User
  /api/user/view-repo:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing the user public repo to tag to a project.
      produces:
      - application/json
      responses:
        "200":
          description: Repo fetched
          schema:
            $ref: '#/definitions/schema.DocViewRepos'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Bad Gateway
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View Github public repo for current user
      tags:
      - Git
  /api/user/view-subs:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing the history of a user's subsciption
      produces:
      - application/json
      responses:
        "200":
          description: Subscriptions
          schema:
            $ref: '#/definitions/schema.DocViewSubscriptions'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: Views a user subscription history
      tags:
      - User
  /api/user/view-user-friend:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing all the friends of a user
      parameters:
      - description: User ID
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: User friends fetched
          schema:
            $ref: '#/definitions/schema.DocViewFriends'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View all friends of a user
      tags:
      - User
  /api/user/view-user-req:
    get:
      consumes:
      - application/json
      description: An endpoint for viewing all the looged in users friend reqs (sent
        and received)
      produces:
      - application/json
      responses:
        "200":
          description: Fetched requests
          schema:
            $ref: '#/definitions/schema.DocViewFriendReqs'
        "401":
          description: Unauthorized user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      security:
      - BearerAuth: []
      summary: View All friend reqs
      tags:
      - User
  /api/v1/auth/github/callback:
    get:
      consumes:
      - application/json
      description: An endpoint for selecting the callback for login, connect github
        endpoint
      produces:
      - application/json
      responses:
        "200":
          description: Token generated
          schema:
            $ref: '#/definitions/schema.DocTokenResponse'
        "202":
          description: Github Connected
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "400":
          description: Invalid id
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "401":
          description: Unauthorized
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "409":
          description: Existing record
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "502":
          description: Bad Gateway
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: Callback for the github sign-in / connect
      tags:
      - Auth
  /forgot-password:
    post:
      consumes:
      - application/json
      description: An endpoint for getting an otp for reseting the user password
      parameters:
      - description: User email
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.ForgotPasswordEmail'
      produces:
      - application/json
      responses:
        "200":
          description: Email sent to user
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Invalid Email
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: Get a OTP for reseting user password
      tags:
      - User
  /github-signup:
    get:
      consumes:
      - application/json
      description: A redirecting endpoint for sign-in / sign-up with github it calls
        a service internally to create a vector for new users
      produces:
      - application/json
      responses:
        "307":
          description: Redirecting
          schema:
            type: string
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: Signing up user using github
      tags:
      - Auth
  /health/detailed:
    get:
      consumes:
      - application/json
      description: This gives a detailed health status of the running services
      produces:
      - application/json
      responses:
        "200":
          description: Service Healthy
          schema:
            additionalProperties: true
            type: object
        "503":
          description: Service Degraded
          schema:
            additionalProperties: true
            type: object
      summary: Checks the health of the services running
      tags:
      - Health
  /login:
    post:
      consumes:
      - application/json
      description: Log in endpoint for existing users
      parameters:
      - description: User login payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.LoginRequest'
      produces:
      - application/json
      responses:
        "200":
          description: jwt token generated
          schema:
            $ref: '#/definitions/schema.DocTokenResponse'
        "404":
          description: Record not found
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: Log in a user
      tags:
      - Auth
  /signup:
    post:
      consumes:
      - application/json
      description: Sign up endpoint for new users it internally calls a service to
        create a vector for the user
      parameters:
      - description: User signup payload
        in: body
        name: payload
        required: true
        schema:
          $ref: '#/definitions/schema.SignupRequest'
      produces:
      - application/json
      responses:
        "201":
          description: jwt token generated
          schema:
            $ref: '#/definitions/schema.DocTokenResponse'
        "409":
          description: Existing email or username
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "422":
          description: Failed to parse payload
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: Server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: Register a new user
      tags:
      - Auth
  /verify-otp:
    get:
      consumes:
      - application/json
      description: An endpoint to verify sent otp to create reset jwt token for reseting
        user password
      parameters:
      - description: otp
        in: query
        name: id
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: reset token
          schema:
            $ref: '#/definitions/schema.DocTokenResponse'
        "400":
          description: invalid otp
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "404":
          description: invalid otp
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
        "500":
          description: server error
          schema:
            $ref: '#/definitions/schema.DocNormalResponse'
      summary: Verify Sent otp to reset password
      tags:
      - User
securityDefinitions:
  BearerAuth:
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"
```

## File: schema/post.go
```go
package schema

import "time"

type NewProjectRequest struct {
	Title       string   `json:"title" binding:"required"`
	Description string   `json:"description" binding:"required"`
	Tags        []string `json:"tags" binding:"required"`
	Git         bool     `json:"git" binding:"omitempty"`
	GitLink     string   `json:"git_link" binding:"omitempty"`
}

type ProjectResponse struct {
	ID          string
	Title       string
	Description string
	Available   bool
	Tags        []string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Views       uint
}

type DetailedProjectResponse struct {
	ProjectResponse
	Username   string
	GitProject bool
	GitLink    string
}

type ApplicationProjectResponse struct {
	Applications []ViewProjectApplication
}

type RejectApplication struct {
	Reason string `json:"msg" binding:"omitempty"`
}

type ProjectApplication struct {
	Message string `json:"msg" binding:"omitempty,max=50"`
}

type SearchProjectWithTags struct {
	Tags []string `json:"tags" binding:"required"`
}

type ViewProjectApplication struct {
	ReqID    string
	Status   string
	Message  string
	Username string
	Sent     time.Time
}
```

## File: docker-compose.yml
```yaml
services:
  db:
    image: postgres:15
    container_name: findMe_postgres_db
    restart: always
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - findMe:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - findme-shared-network

  redis:
    image: redis:8.2.3
    container_name: findMe_redis
    restart: always
    command: [
      "redis-server", "--appendonly", "yes",
      "--requirepass", "${REDIS_PASS}",
      "--maxmemory", "50mb",
      "--maxmemory-policy", "volatile-ttl"
    ]
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - findme-shared-network

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: findMe_app
    restart: always
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_HOST=db
      - REDIS_PASS=${REDIS_PASS}
      - REDIS_ADDR=redis:6379
      - JWTSECRET=${JWTSECRET}
      - GIT_CLIENT_ID=${GIT_CLIENT_ID}
      - GIT_CLIENT_SECRET=${GIT_CLIENT_SECRET}
      - GIT_CALLBACK_URL=${GIT_CALLBACK_URL}
      - EMAIL=${EMAIL}
      - EMAIL_APP_PASSWORD=${EMAIL_APP_PASSWORD}
      - PAYSTACK_API_KEY=${PAYSTACK_API_KEY}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 120s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - findme-shared-network

  nginx:
    image: nginx:alpine
    container_name: findMe_nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./certbot/conf:/etc/letsencrypt:ro
      - ./certbot/www:/var/www/certbot:ro
    depends_on:
      app:
        condition: service_healthy
    networks:
      - findme-shared-network
    command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"

  certbot:
    image: certbot/certbot
    container_name: findMe_certbot
    restart: always
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    networks:
      - findme-shared-network

networks:
  findme-shared-network:
    external: true

volumes:
  findMe:
  redis-data:
```

## File: core/cache.go
```go
// Package core -> Core Functionalities of the app
package core

import (
	"context"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"time"

	"findme/model"
	"findme/schema"

	"github.com/redis/go-redis/v9"
)

type Cache interface {
	CheckHealth() error
	CacheSkills(skills []model.Skill)
	CachePlans(plans []schema.ViewPlansResp) error
	RetrieveCachedPlans() ([]schema.ViewPlansResp, error)
	RetrieveCachedSkills(skills []string) (map[string]string, error)
	AddNewSkillToCache(skill []*model.Skill)
	SetOTP(otp string, uid string) error
	GetOTP(otp string) (string, error)
}

type RDB struct {
	Cache *redis.Client
}

func NewRDB(rdb *redis.Client) *RDB {
	return &RDB{Cache: rdb}
}

func (c *RDB) CheckHealth() error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	_, err := c.Cache.Ping(ctx).Result()
	return err
}

// CacheSkills -> Cache skills in rdb at app startup
func (c *RDB) CacheSkills(skills []model.Skill) {
	skillName := make(map[string]any, 0)

	for _, skill := range skills {
		skillName[skill.Name] = skill.ID
	}
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if _, err := c.Cache.HSet(ctx, "skills", skillName).Result(); err != nil {
		log.Printf("[ERROR] [RDB] An error occured while trying to set skills in redis -> %v", err)
	}
}

// RetrieveCachedSkills -> Retrieve cached skills from rdb if possible
func (c *RDB) RetrieveCachedSkills(skills []string) (map[string]string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	skill, err := c.Cache.HMGet(ctx, "skills", skills...).Result()
	if err != nil {
		log.Printf("[ERROR] [RDB] Failed to receive skills from redis -> %s", err)
		return nil, err
	}

	foundskills := make(map[string]string, 0)

	for i, val := range skill {
		if val == nil {
			continue
		}
		id := val.(string)
		foundskills[skills[i]] = id
	}
	return foundskills, nil
}

// AddNewSkillToCache -> Add new skills to rdb
func (c *RDB) AddNewSkillToCache(newskills []*model.Skill) {
	skills := make(map[string]any, 0)

	for _, skill := range newskills {
		skills[skill.Name] = skill.ID
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if _, err := c.Cache.HSet(ctx, "skills", skills).Result(); err != nil {
		log.Printf("An error occured while trying to set new skill in redis -> %v", err)
	}
}

// SetOTP -> Set OTP for password reset temporary in rdb
func (c *RDB) SetOTP(otp string, userID string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if _, err := c.Cache.HGet(ctx, "otps", otp).Result(); err != redis.Nil {
		return &CustomMessage{http.StatusConflict, "Token already exists."}
	}

	otps := &redis.HSetEXOptions{
		ExpirationType: redis.HSetEXExpirationEX,
		ExpirationVal:  600,
	}

	if _, err := c.Cache.HSetEXWithArgs(ctx, "otps", otps, otp, userID).Result(); err != nil {
		log.Printf("An error occured while trying to set otp in redis -> %v", err)
		return &CustomMessage{http.StatusInternalServerError, "Failed to set otp."}
	}
	return nil
}

// GetOTP -> Verify if OTP provided exists in rdb and returns the userID
func (c *RDB) GetOTP(otp string) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	userID, err := c.Cache.HGetDel(ctx, "otps", otp).Result()
	if err != nil {
		if errors.Is(err, redis.Nil) {
			return "", &CustomMessage{http.StatusNotFound, "Invalid otp."}
		} else {
			return "", &CustomMessage{http.StatusInternalServerError, "Failed to verify otp."}
		}
	}
	if len(userID) != 1 || userID[0] == "" {
		return "", &CustomMessage{http.StatusNotFound, "Invalid otp."}
	}
	return userID[0], nil
}

// CachePlans -> Caches the plans in rdb
func (c *RDB) CachePlans(plans []schema.ViewPlansResp) error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	data, err := json.Marshal(plans)
	if err != nil {
		log.Printf("Failed to marshal plans -> %v", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to cache plans."}
	}

	if _, err := c.Cache.Set(ctx, "plans", data, 24*time.Hour).Result(); err != nil {
		log.Printf("An error occured while trying to set plans in redis -> %v", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to set plans in cache."}
	}

	return nil
}

// RetrieveCachedPlans -> Retreives the cached plans from rdb
func (c *RDB) RetrieveCachedPlans() ([]schema.ViewPlansResp, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	data, err := c.Cache.Get(ctx, "plans").Result()
	if err != nil {
		if err == redis.Nil {
			return nil, nil
		}
		return nil, &CustomMessage{http.StatusInternalServerError, "Failed to retrieve cahced plans."}
	}

	var plans []schema.ViewPlansResp
	if err := json.Unmarshal([]byte(data), &plans); err != nil {
		log.Printf("Failed to Unmarshal cached plans -> %v", err.Error())
		return nil, &CustomMessage{http.StatusInternalServerError, "Failed to parse cached plans."}
	}

	return plans, nil
}
```

## File: handlers/github.go
```go
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

type Git interface {
	GitHubAddUser(ctx *gin.Context)
	SelectCallback(ctx *gin.Context)
	ConnectGitHub(ctx *gin.Context)
	ConnectGitHubCallback(uid, code, state, storedState string) (string, error)
	GitHubAddUserCallback(token, code, state, storedState string) (string, string, error)
	ViewRepo(ctx *gin.Context)
}

type GitService struct {
	ClientID     string
	ClientSecret string
	CallbackURL  string
	DB           core.DB
	EmbHub       *core.EmbeddingHub
	Client       *http.Client
}

func NewGitService(id, secret, callback string, db core.DB, emb *core.EmbeddingHub, client *http.Client) *GitService {
	return &GitService{ClientID: id, ClientSecret: secret, CallbackURL: callback, DB: db, EmbHub: emb, Client: client}
}

// GitHubAddUser godoc
// @Summary Signing up user using github
// @Description A redirecting endpoint for sign-in / sign-up with github it calls a service internally to create a vector for new users
// @Tags Auth
// @Accept json
// @Produce json
// @Success 307 {string} string "Redirecting"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /github-signup [get]
func (g *GitService) GitHubAddUser(ctx *gin.Context) {
	if _, err := ctx.Cookie("git-access-token"); err == nil {
		ctx.SetCookie("auth", "login", 150, "/", "", false, true)
		ctx.Redirect(http.StatusTemporaryRedirect, g.CallbackURL)
	}
	state, err := core.GenerateState()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"message": "Failed to generate user state."})
		return
	}

	ctx.SetCookie("state", state, 150, "/", "", false, true)
	ctx.SetCookie("auth", "login", 150, "/", "", false, true)

	redirectURL := fmt.Sprintf("https://github.com/login/oauth/authorize?client_id=%s&state=%s&scope=read:user user:email", g.ClientID, state)
	ctx.Redirect(http.StatusTemporaryRedirect, redirectURL)
}

// ConnectGitHub godoc
// @Summary Connecting github account to user account
// @Description An redirecting endpoint for connecting a github account to the current user account
// @Tags Auth
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 307 {string} string "Redirecting"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/connect-github [post]
func (g *GitService) ConnectGitHub(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	state, err := core.GenerateState()
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to generate state for github session."})
		return
	}

	ctx.SetCookie("state", state, 150, "/", "", false, true)
	ctx.SetCookie("auth", "connect", 150, "/", "", false, true)
	ctx.SetCookie("uid", uid, 150, "/", "", false, true)

	redirectURL := fmt.Sprintf("https://github.com/login/oauth/authorize?client_id=%s&state=%s&scope=read:user user:email", g.ClientID, state)
	ctx.Redirect(http.StatusTemporaryRedirect, redirectURL)
}

// SelectCallback godoc
// @Summary  Callback for the github sign-in / connect
// @Description An endpoint for selecting the callback for login, connect github endpoint
// @Tags Auth
// @Accept json
// @Produce json
// @Success 200 {object} schema.DocTokenResponse "Token generated"
// @Success 202 {object} schema.DocNormalResponse "Github Connected"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 409 {object} schema.DocNormalResponse "Existing record"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "Bad Gateway"
// @Router /api/v1/auth/github/callback [get]
func (g *GitService) SelectCallback(ctx *gin.Context) {
	auth, _ := ctx.Cookie("auth")
	token, _ := ctx.Cookie("git-access-token")
	storedState, _ := ctx.Cookie("state")
	uid, _ := ctx.Cookie("uid")

	state := ctx.Query("state")
	code := ctx.Query("code")
	switch auth {
	case "login":
		jwtToken, gitToken, err := g.GitHubAddUserCallback(token, code, state, storedState)
		if err != nil {
			cm := err.(*core.CustomMessage)
			ctx.AbortWithStatusJSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}
		ctx.SetCookie("git-access-token", gitToken, 60*60*24, "/", "", false, true)
		ctx.JSON(http.StatusOK, gin.H{"token": jwtToken})
		return
	case "auth":
		gitToken, err := g.ConnectGitHubCallback(uid, code, state, storedState)
		if err != nil {
			cm := err.(*core.CustomMessage)
			ctx.AbortWithStatusJSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}
		ctx.SetCookie("git-access-token", gitToken, 60*60*24, "/", "", false, true)
		ctx.JSON(http.StatusAccepted, gin.H{"msg": "Github account connected successfully."})
		return
	default:
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid auth mode."})
	}
}

// GitHubAddUserCallback -> callback for the github sign-up/sign-in endpoint
func (g *GitService) GitHubAddUserCallback(token, code, state, storedState string) (string, string, error) {
	if token == "" || !g.isTokenValid(token) {
		if state != storedState {
			return "", "", &core.CustomMessage{Code: http.StatusBadRequest, Message: "Invalid or expired state."}
		}

		data := url.Values{}
		data.Add("client_id", g.ClientID)
		data.Add("client_secret", g.ClientSecret)
		data.Add("code", code)

		req, _ := http.NewRequest(http.MethodPost, "https://github.com/login/oauth/access_token", bytes.NewBufferString(data.Encode()))
		req.Header.Set("Accept", "application/json")
		req.Header.Set("Content-type", "application/x-www-form-urlencoded")

		resp, err := g.Client.Do(req)
		if err != nil || resp.StatusCode != http.StatusOK {
			return "", "", &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to signup with github."}
		}

		defer resp.Body.Close()

		var gitToken schema.GitToken

		if err := json.NewDecoder(resp.Body).Decode(&gitToken); err != nil {
			return "", "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to parse access token."}
		}
		token = gitToken.AccessToken
	}

	userReq, _ := http.NewRequest(http.MethodGet, "https://api.github.com/user", nil)
	userReq.Header.Set("Authorization", "Bearer "+token)

	userResp, err := g.Client.Do(userReq)
	if err != nil || userResp.StatusCode != http.StatusOK {
		return "", "", &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to signup with github."}
	}

	defer userResp.Body.Close()

	var user schema.GitHubUser
	if err := json.NewDecoder(userResp.Body).Decode(&user); err != nil {
		return "", "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to parse user info."}
	}

	var existingUser model.User
	if err := g.DB.FindExistingGitID(&existingUser, user.ID); err == nil {
		premium := CheckSubscription(&existingUser)
		userToken, err := GenerateJWT(existingUser.ID, "login", premium, JWTExpiry)
		if err != nil {
			return "", "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to generate jwt token for user."}
		}
		return userToken, token, nil
	}

	if user.Email == "" {
		emailReq, _ := http.NewRequest(http.MethodGet, "https://api.github.com/user/emails", nil)
		emailReq.Header.Set("Authorization", "Bearer "+token)
		emailReq.Header.Set("Accept", "application/vnd.github+json")
		emailResp, err := g.Client.Do(emailReq)

		if err != nil || emailResp.StatusCode != http.StatusOK {
			return "", "", &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to fetch user email."}
		}

		defer emailResp.Body.Close()

		var email []struct {
			Email   string `json:"email"`
			Primary bool   `json:"primary"`
		}

		if err := json.NewDecoder(emailResp.Body).Decode(&email); err != nil {
			return "", "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to parse user github emails."}
		}

		for _, e := range email {
			if e.Primary {
				user.Email = e.Email
				break
			}
		}

		if user.Email == "" {
			return "", "", &core.CustomMessage{Code: http.StatusBadRequest, Message: "No email available on github."}
		}

	}

	if err := g.DB.CheckExistingEmail(user.Email); err != nil {
		return "", "", &core.CustomMessage{Code: http.StatusConflict, Message: "There's an account associated with that email already!"}
	}

	newUsername := user.UserName
	if err := g.DB.CheckExistingUsername(newUsername); err != nil {
		newUsername = core.GenerateUsername(existingUser.UserName)
	}

	newUser := model.User{
		FullName:     user.FullName,
		Email:        user.Email,
		GitUserName:  &user.UserName,
		GitID:        &user.ID,
		GitUser:      true,
		UserName:     newUsername,
		Availability: true,
		FreeTrial:    time.Now().Add(7 * 24 * time.Hour),
		Bio:          user.Bio,
	}

	if err := g.DB.AddUser(&newUser); err != nil {
		return "", "", err
	}

	g.EmbHub.QueueUserCreate(newUser.ID, newUser.Bio, []string{""}, []string{""})

	userToken, err := GenerateJWT(newUser.ID, "login", true, JWTExpiry)
	if err != nil {
		return "", "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to generate jwt token for user."}
	}

	return userToken, token, nil
}

// ConnectGitHubCallback -> callback for the github connect endpoint
func (g *GitService) ConnectGitHubCallback(uid, code, state, storedState string) (string, error) {
	if uid == "" {
		return "", &core.CustomMessage{Code: http.StatusUnauthorized, Message: "Unauthorized user."}
	}

	if storedState != state {
		return "", &core.CustomMessage{Code: http.StatusBadRequest, Message: "Invalid or Expired state."}
	}

	data := url.Values{}
	data.Add("client_id", g.ClientID)
	data.Add("client_secret", g.ClientSecret)
	data.Add("code", code)

	req, _ := http.NewRequest(http.MethodPost, "https://github.com/login/oauth/access_token", bytes.NewBufferString(data.Encode()))
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-type", "application/x-www-form-urlencoded")

	resp, err := g.Client.Do(req)
	if err != nil || resp.StatusCode != http.StatusOK {
		return "", &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to connect with github."}
	}

	defer resp.Body.Close()

	var gitToken schema.GitToken

	if err := json.NewDecoder(resp.Body).Decode(&gitToken); err != nil {
		return "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to parse access token."}
	}

	userReq, _ := http.NewRequest(http.MethodGet, "https://api.github.com/user", nil)
	userReq.Header.Set("Authorization", "Bearer "+gitToken.AccessToken)

	userResp, err := g.Client.Do(userReq)
	if err != nil || userResp.StatusCode != http.StatusOK {
		return "", &core.CustomMessage{Code: http.StatusBadGateway, Message: "Failed to signup with github."}
	}

	defer userResp.Body.Close()

	var gitUser schema.GitHubUser
	if err := json.NewDecoder(userReq.Body).Decode(&gitUser); err != nil {
		return "", &core.CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to parse user info."}
	}

	var user model.User
	if err := g.DB.FetchUser(&user, uid); err != nil {
		return "", err
	}

	user.GitID = &gitUser.ID
	user.GitUser = true
	user.GitUserName = &gitUser.UserName

	if err := g.DB.SaveUser(&user); err != nil {
		return "", err
	}

	return gitToken.AccessToken, nil
}

// ViewRepo godoc
// @Summary View Github public repo for current user
// @Description An endpoint for viewing the user public repo to tag to a project.
// @Tags Git
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewRepos "Repo fetched"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Failure 502 {object} schema.DocNormalResponse "Bad Gateway"
// @Router /api/user/view-repo [get]
func (g *GitService) ViewRepo(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if uid == "" || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := g.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if !user.GitUser {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "You have to connect your github account."})
		return
	}

	req, _ := http.NewRequest("GET", "https://api.github.com/users/"+*user.GitUserName+"/repos?sort=pushed", nil)
	req.Header.Set("Accept", "application/vnd.github+json")

	resp, err := g.Client.Do(req)

	if err != nil || resp.StatusCode != http.StatusOK {
		ctx.JSON(http.StatusBadGateway, gin.H{"msg": "Failed to communicate with github."})
		return
	}

	defer resp.Body.Close()
	var repos []schema.ViewRepo

	if err := json.NewDecoder(resp.Body).Decode(&repos); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse github data."})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"repos": repos})
}

// isTokenValid -> Checks if a git access token is valid
func (g *GitService) isTokenValid(token string) bool {
	req, _ := http.NewRequest(http.MethodGet, "https://api.github.com/user", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	resp, err := g.Client.Do(req)
	if err != nil {
		return false
	}

	defer resp.Body.Close()
	return resp.StatusCode == http.StatusOK
}
```

## File: test/unit/mock_test.go
```go
package unit

import (
	"errors"
	"net/http"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

type CacheMock struct {
	Store map[string]map[string]string
	Otp   map[string]string
}

func (mock *CacheMock) CheckHealth() error {
	return nil
}

func (mock *CacheMock) CacheSkills(skills []model.Skill) {
	cache := make(map[string]string, 0)

	for _, skill := range skills {
		cache[skill.Name] = skill.ID
	}

	mock.Store["skills"] = cache
}

func (mock *CacheMock) RetrieveCachedSkills(skills []string) (map[string]string, error) {
	foundskills := make(map[string]string, 0)
	for _, val := range skills {
		if id, exists := mock.Store["skills"][val]; exists {
			foundskills[val] = id
		}
	}

	return foundskills, nil
}

func (mock *CacheMock) AddNewSkillToCache(skills []*model.Skill) {
	for _, skill := range skills {
		mock.Store["skills"][skill.Name] = skill.ID
	}
}

func (mock *CacheMock) SetOTP(otp string, uid string) error {
	mock.Otp["123456"] = uid
	return nil
}

func (mock *CacheMock) GetOTP(otp string) (string, error) {
	if val, exists := mock.Otp[otp]; exists {
		return val, nil
	}
	return "", errors.New("missing")
}

func (mock *CacheMock) CachePlans(plans []schema.ViewPlansResp) error {
	return nil
}

func (mock *CacheMock) RetrieveCachedPlans() ([]schema.ViewPlansResp, error) {
	return nil, nil
}

func NewCacheMock() *CacheMock {
	return &CacheMock{
		Store: make(map[string]map[string]string, 0),
		Otp:   make(map[string]string, 0),
	}
}

type EmailHub struct{}

func (mock *EmailHub) QueueSubscriptionCreate(_, _, _, _, _, _ string)     {}
func (mock *EmailHub) QueueProjectApplicationReject(_, _, _, _, _ string)  {}
func (mock *EmailHub) QueueProjectApplicationAccept(_, _, _, _, _ string)  {}
func (mock *EmailHub) QueueTransactionFailedEmail(_, _, _, _, _, _ string) {}
func (mock *EmailHub) QueueProjectApplication(_, _, _, _, _ string)        {}
func (mock *EmailHub) QueueFriendReqEmail(_, _, _, _, _ string)            {}
func (mock *EmailHub) QueueForgotPassEmail(_, _, _ string)                 {}
func (mock *EmailHub) QueueSubscriptionReEnabled(_, _, _ string)           {}
func (mock *EmailHub) QueueSubscriptionCancelled(_, _, _ string)           {}
func (mock *EmailHub) QueueNotifyFreeTrialEnding(_, _, _, _ string)        {}
func (mock *EmailHub) Worker()                                             {}

func NewEmailHubMock() *EmailHub {
	return &EmailHub{}
}

type EmailMock struct{}

func (mock *EmailMock) SendForgotPassEmail(_, _ string) (string, string)               { return "", "" }
func (mock *EmailMock) SendFriendReqEmail(_, _, _, _ string) (string, string)          { return "", "" }
func (mock *EmailMock) SendProjectApplicationEmail(_, _, _, _ string) (string, string) { return "", "" }
func (mock *EmailMock) SendProjectApplicationAccept(_, _, _, _ string) (string, string) {
	return "", ""
}

func (mock *EmailMock) SendProjectApplicationReject(_, _, _, _ string) (string, string) {
	return "", ""
}

func (mock *EmailMock) SendSubscriptionCreateEmail(_, _, _, _, _ string) (string, string) {
	return "", ""
}

func (mock *EmailMock) SendTransactionFailedEmail(_, _, _, _, _ string) (string, string) {
	return "", ""
}
func (mock *EmailMock) SendSubscriptionCancelledEmail(_, _ string) (string, string) { return "", "" }
func (mock *EmailMock) SendSubscriptionReEnabledEmail(_, _ string) (string, string) { return "", "" }

func (mock *EmailMock) SendNotifyFreeTrialEnding(_, _, _ string) (string, string) { return "", "" }

func (mock *EmailMock) SendEmail(_, _, _ string) error { return nil }

func NewEmailMock() *EmailMock {
	return &EmailMock{}
}

type GitMock struct{}

func (mock *GitMock) GitHubAddUser(_ *gin.Context) {}
func (mock *GitMock) ConnectGitHub(_ *gin.Context) {}
func (mock *GitMock) SelectCallback(ctx *gin.Context) {
	ctx.JSON(http.StatusOK, gin.H{"token": "1234", "msg": "Logged in successfully."})
}

func (mock *GitMock) GitHubAddUserCallback(_, _, _, _ string) (string, string, error) {
	return "", "", nil
}

func (mock *GitMock) ConnectGitHubCallback(_, _, _, _ string) (string, error) {
	return "", nil
}

func (mock *GitMock) ViewRepo(ctx *gin.Context) {
	repo := schema.ViewRepo{
		Name:     "FindMe",
		HTMLURL:  "https://github.com/imisi99/FindMe",
		Language: "Go",
	}

	ctx.JSON(http.StatusOK, gin.H{"repos": repo})
}

func NewGitMock() *GitMock {
	return &GitMock{}
}

type TranscMock struct{}

func (mock *TranscMock) InitializeTransaction(_ *gin.Context)    {}
func (mock *TranscMock) GetTransactions(_ *gin.Context)          {}
func (mock *TranscMock) UpdateSubscriptionCard(ctx *gin.Context) {}
func (mock *TranscMock) CancelSubscription(ctx *gin.Context)     {}
func (mock *TranscMock) EnableSubscription(ctx *gin.Context)     {}
func (mock *TranscMock) ViewPlans(ctx *gin.Context)              {}
func (mock *TranscMock) VerifyTranscWebhook(ctx *gin.Context)    {}
func (mock *TranscMock) RetryFailedPayment(ctx *gin.Context)     {}

func NewTranscMock() *TranscMock {
	return &TranscMock{}
}

type EmbeddingMock struct{}

func (e *EmbeddingMock) QueueUserCreate(id, bio string, skills, interests []string)             {}
func (e *EmbeddingMock) QueueUserUpdate(id, bio string, skills, interest []string)              {}
func (e *EmbeddingMock) QueueUserUpdateStatus(id string, status bool)                           {}
func (e *EmbeddingMock) QueueUserDelete(id string)                                              {}
func (e *EmbeddingMock) QueueProjectCreate(id, title, description, uid string, skills []string) {}
func (e *EmbeddingMock) QueueProjectUpdate(id, title, description string, skills []string)      {}
func (e *EmbeddingMock) QueueProjectUpdateStatus(id string, status bool)                        {}
func (e *EmbeddingMock) QueueProjectDelete(id string)                                           {}

func NewEmbeddingMock() *EmbeddingMock {
	return &EmbeddingMock{}
}

type RecommendationMock struct{}

func (r *RecommendationMock) QueueUserRecommendation(_ string)    {}
func (r *RecommendationMock) QueueProjectRecommendation(_ string) {}
func (r *RecommendationMock) GetRecommendation(ID string, jobType core.RecommendationJobType) (*schema.RecResponse, error) {
	return &schema.RecResponse{}, nil
}

func NewRecommendationMock() *RecommendationMock {
	return &RecommendationMock{}
}

type CronMock struct{}

func NewCronMock() *CronMock {
	return &CronMock{}
}

func (mock *CronMock) TrialEndingReminders() error { return nil }
```

## File: database/database.go
```go
// Package database -> Connection to database and redis
package database

import (
	"fmt"
	"log"
	"os"

	"findme/model"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// Connect -> Connection to database
func Connect() *gorm.DB {
	dsn := fmt.Sprintf(
		"host=%s user=%s password=%s dbname=%s port=5432 sslmode=disable",
		os.Getenv("POSTGRES_HOST"),
		os.Getenv("POSTGRES_USER"),
		os.Getenv("POSTGRES_PASSWORD"),
		os.Getenv("POSTGRES_DB"),
	)

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	db.Logger.LogMode(logger.Silent)

	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to establish database connection -> %s", err.Error())
	}

	err = db.AutoMigrate(
		&model.User{},
		&model.Skill{},
		&model.Project{},
		&model.ProjectReq{},
		&model.ProjectSkill{},
		&model.UserSkill{},
		&model.UserFriend{},
		&model.FriendReq{},
		&model.UserMessage{},
		&model.UserSavedProject{},
		&model.Chat{},
		&model.ChatUser{},
		&model.Subscriptions{},
		&model.Transactions{},
	)
	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to create tables -> %s", err.Error())
	}

	err = db.SetupJoinTable(&model.Project{}, "Tags", &model.ProjectSkill{})
	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to create join table on project and skills -> %s", err.Error())
	}

	err = db.SetupJoinTable(&model.User{}, "Skills", &model.UserSkill{})
	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to create join table on user and skills -> %s", err.Error())
	}

	err = db.SetupJoinTable(&model.User{}, "Friends", &model.UserFriend{})
	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to create join table on user and friends -> %s", err.Error())
	}

	err = db.SetupJoinTable(&model.User{}, "Chats", &model.ChatUser{})
	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to create join table on user and chats -> %s", err.Error())
	}

	err = db.SetupJoinTable(&model.User{}, "SavedProjects", &model.UserSavedProject{})
	if err != nil {
		log.Fatalf("[ERROR] [DB] Failed to create join table on user and saved posts -> %s", err.Error())
	}

	log.Println("[INFO] [DB] Connected to the database successfully.")
	return db
}
```

## File: go.mod
```
module findme

go 1.24.0

require (
	github.com/gin-gonic/gin v1.10.1
	github.com/go-mail/mail/v2 v2.3.0
	github.com/golang-jwt/jwt/v5 v5.2.3
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.3
	github.com/joho/godotenv v1.5.1
	github.com/lib/pq v1.10.9
	github.com/redis/go-redis/v9 v9.12.1
	github.com/stretchr/testify v1.10.0
	github.com/swaggo/files v1.0.1
	github.com/swaggo/gin-swagger v1.6.1
	github.com/swaggo/swag v1.16.6
	golang.org/x/crypto v0.44.0
	google.golang.org/grpc v1.78.0
	google.golang.org/protobuf v1.36.10
	gorm.io/driver/postgres v1.6.0
	gorm.io/driver/sqlite v1.6.0
	gorm.io/gorm v1.30.0
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.1.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/bytedance/sonic v1.11.6 // indirect
	github.com/bytedance/sonic/loader v0.1.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cloudwego/base64x v0.1.4 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.19.6 // indirect
	github.com/go-openapi/spec v0.20.4 // indirect
	github.com/go-openapi/swag v0.19.15 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.20.0 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.5 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.7.6 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-sqlite3 v1.14.22 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.2 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/robfig/cron/v3 v3.0.1 // indirect
	github.com/rogpeppe/go-internal v1.14.1 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	golang.org/x/arch v0.8.0 // indirect
	golang.org/x/mod v0.29.0 // indirect
	golang.org/x/net v0.47.0 // indirect
	golang.org/x/sync v0.18.0 // indirect
	golang.org/x/sys v0.38.0 // indirect
	golang.org/x/text v0.31.0 // indirect
	golang.org/x/tools v0.38.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20251029180050-ab9386a59fda // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/mail.v2 v2.3.1 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
```

## File: core/email.go
```go
package core

import (
	"fmt"
	"log"
	"time"

	"github.com/go-mail/mail/v2"
)

type EmailS interface {
	SendEmail(to, subject, body string) error
	SendFriendReqEmail(fromUsername, toUsername, message, viewURL string) (string, string)
	SendForgotPassEmail(username, token string) (string, string)
	SendProjectApplicationEmail(fromUsername, toUsername, message, viewURL string) (string, string)
	SendProjectApplicationAccept(fromUsername, toUsername, message, chatURL string) (string, string)
	SendProjectApplicationReject(fromUsername, toUsername, message, reason string) (string, string)
	SendSubscriptionCreateEmail(username, amount, currency, planName, manageURL string) (string, string)
	SendTransactionFailedEmail(username, amount, currency, planName, retryURL string) (string, string)
	SendSubscriptionReEnabledEmail(username, nextBillingDate string) (string, string)
	SendSubscriptionCancelledEmail(username, endDate string) (string, string)
	SendNotifyFreeTrialEnding(username, endDate, subURL string) (string, string)
}

type Email interface {
	Worker()
	QueueFriendReqEmail(fromUsername, toUsername, message, viewURL, to string)
	QueueForgotPassEmail(to, username, token string)
	QueueProjectApplication(fromUsername, toUsername, message, viewURL, to string)
	QueueProjectApplicationAccept(fromUsername, toUsername, message, chatURL, to string)
	QueueProjectApplicationReject(fromUsername, toUsername, message, reason, to string)
	QueueSubscriptionCreate(username, amount, currency, planName, manageURL, to string)
	QueueTransactionFailedEmail(username, amount, currency, planName, retryURL, to string)
	QueueSubscriptionReEnabled(username, nextBillingDate, to string)
	QueueSubscriptionCancelled(username, endDate, to string)
	QueueNotifyFreeTrialEnding(username, endDate, subURL, to string)
}

type EmailService struct {
	Server   string
	MailPort int
	Addr     string
	Password string
}

type EmailJob struct {
	To          string
	Subject     string
	Body        string
	Attempts    int
	MaxAttempts int
}

type EmailHub struct {
	Jobs       chan *EmailJob
	Quit       chan bool
	WorkerPool int
	Service    EmailS
}

func NewEmailService(server, addr, pass string, port int) *EmailService {
	return &EmailService{Server: server, MailPort: port, Addr: addr, Password: pass}
}

func NewEmailHub(queueSize, workers int, service EmailS) *EmailHub {
	return &EmailHub{
		Jobs:       make(chan *EmailJob, queueSize),
		Quit:       make(chan bool),
		WorkerPool: workers,
		Service:    service,
	}
}

func (h *EmailHub) Run() {
	for range h.WorkerPool {
		go h.Worker()
	}
	log.Println("[EMAIL HUB] The Email hub is up and running")
}

func (h *EmailHub) Stop() {
	for range h.WorkerPool {
		h.Quit <- true
	}
}

func (h *EmailHub) Worker() {
	for {
		select {
		case job := <-h.Jobs:
			err := h.Service.SendEmail(job.To, job.Subject, job.Body)
			if err != nil {
				job.Attempts++
				if job.Attempts <= job.MaxAttempts {
					waitTime := time.Duration(job.Attempts*4) * time.Second
					log.Printf("[EmailJob] Retrying in %v", waitTime)

					go func(j *EmailJob, delay time.Duration) {
						time.Sleep(delay)
						h.Jobs <- j
					}(job, waitTime)
				}
			}
		case <-h.Quit:
			return
		}
	}
}

func (h *EmailHub) QueueFriendReqEmail(fromUsername, toUsername, message, viewURL, to string) {
	body, subject := h.Service.SendFriendReqEmail(fromUsername, toUsername, message, viewURL)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueForgotPassEmail(to, username, token string) {
	body, subject := h.Service.SendForgotPassEmail(username, token)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 3,
	}
}

func (h *EmailHub) QueueProjectApplication(fromUsername, toUsername, message, viewURL, to string) {
	body, subject := h.Service.SendProjectApplicationEmail(fromUsername, toUsername, message, viewURL)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueProjectApplicationAccept(fromUsername, toUsername, message, chatURL, to string) {
	body, subject := h.Service.SendProjectApplicationAccept(fromUsername, toUsername, message, chatURL)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueProjectApplicationReject(fromUsername, toUsername, message, reason, to string) {
	body, subject := h.Service.SendProjectApplicationReject(fromUsername, toUsername, message, reason)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueSubscriptionCreate(username, amount, currency, planName, manageURL, to string) {
	body, subject := h.Service.SendSubscriptionCreateEmail(username, amount, currency, planName, manageURL)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueTransactionFailedEmail(username, amount, currency, planName, retryURL, to string) {
	body, subject := h.Service.SendTransactionFailedEmail(username, amount, currency, planName, retryURL)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueSubscriptionReEnabled(username, nextBillingDate, to string) {
	body, subject := h.Service.SendSubscriptionReEnabledEmail(username, nextBillingDate)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueSubscriptionCancelled(username, endDate, to string) {
	body, subject := h.Service.SendSubscriptionCancelledEmail(username, endDate)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

func (h *EmailHub) QueueNotifyFreeTrialEnding(username, endDate, subURL, to string) {
	body, subject := h.Service.SendNotifyFreeTrialEnding(username, endDate, subURL)
	h.Jobs <- &EmailJob{
		To:          to,
		Subject:     subject,
		Body:        body,
		MaxAttempts: 2,
	}
}

// SendForgotPassEmail -> Sends an OTP for reseting Password
func (e *EmailService) SendForgotPassEmail(username, token string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Password Reset</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">

	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#4f46e5; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
				<h1 style="margin:0; font-size:22px; color:#ffffff;">Reset Your Password</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
				<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
				<p style="font-size:15px; color:#374151; margin-bottom:20px;">
					We received a request to reset your password. Please use the OTP code below:
				</p>
				<div style="text-align:center; margin:30px 0;">
					<span style="display:inline-block; background:#4f46e5; color:#ffffff; font-size:24px; font-weight:bold; padding:12px 24px; border-radius:6px;">
					%s
					</span>
				</div>
				<p style="font-size:14px; color:#6b7280; margin-bottom:10px;">
					This OTP is valid for the next 10 minutes.
				</p>
				<p style="font-size:14px; color:#6b7280;">
					If you didnt request this, you can safely ignore this email.
				</p>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
				This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>

	</body>
	</html>`, username, token)

	return htmlBody, "Password reset OTP"
}

// SendFriendReqEmail -> Sends a notification about a new friend request
func (e *EmailService) SendFriendReqEmail(fromUsername, toUsername, message, viewURL string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>New Friend Request</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">

	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#4f46e5; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">New Friend Request</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						<b>%s</b> has sent you a friend request!
					</p>
					<p style="font-size:14px; color:#374151; margin:20px 0;">
						<span style="font-weight:bold;">Message:</span>
					</p>
					<blockquote style="margin:0; padding:15px; background:#f3f4f6; border-left:4px solid #187e5fff; font-style:italic; font-size:14px; color:#1f2937;">
						%s
					</blockquote>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						You can view the request below:
					</p>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="%s" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold; margin-right:10px;">View Request</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					You are receiving this email because you have an account on <b>FindMe</b>.<br/>
					If you did not expect this, you can safely ignore this email.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>

	</body>
	</html>`,
		toUsername,
		fromUsername,
		message,
		viewURL,
	)

	return htmlBody, "New Friend Request"
}

// SendProjectApplicationEmail -> Sends a notification about a new application to post
func (e *EmailService) SendProjectApplicationEmail(fromUsername, toUsername, message, viewURL string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>New Project Application Request</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">

	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#4f46e5; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">New Project Application Request</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						<b>%s</b> has applied for a post created by you.
					</p>
					<p style="font-size:14px; color:#374151; margin:20px 0;">
						<span style="font-weight:bold;">Project Description:</span>
					</p>
					<blockquote style="margin:0; padding:15px; background:#f3f4f6; border-left:4px solid #758f19ff; font-style:italic; font-size:14px; color:#1f2937;">
						%s
					</blockquote>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						You can view the application below:
					</p>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="%s" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold; margin-right:10px;">View Application</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					You are receiving this email because you have an account on <b>FindMe</b>.<br/>
					If you did not expect this, you can safely ignore this email.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>

	</body>
	</html>`,
		toUsername,
		fromUsername,
		message,
		viewURL,
	)

	return htmlBody, "New Project Application Request"
}

// SendProjectApplicationAccept -> Sends notification about accepted post application
func (e *EmailService) SendProjectApplicationAccept(fromUsername, toUsername, message, chatURL string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Application Update</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">

	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#4f46e5; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Application Update</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						<b>%s</b> has accepted your application!
					</p>
					<p style="font-size:14px; color:#374151; margin:20px 0;">
						<span style="font-weight:bold;">You can now work together on the project with description:</span>
					</p>
					<blockquote style="margin:0; padding:15px; background:#f3f4f6; border-left:4px solid #26868aff; font-style:italic; font-size:14px; color:#1f2937;">
						%s
					</blockquote>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						You can chat with each other:
					</p>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="%s" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold; margin-right:10px;">Chat</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					You are receiving this email because you have an account on <b>FindMe</b>.<br/>
					If you did not expect this, you can safely ignore this email.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>

	</body>
	</html>`,
		toUsername,
		fromUsername,
		message,
		chatURL,
	)

	return htmlBody, "Project Application Update"
}

// SendProjectApplicationReject -> Sends notification about rejected post application
func (e *EmailService) SendProjectApplicationReject(fromUsername, toUsername, message, reason string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Application Update</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">

	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#4f46e5; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Application Update</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						<b>%s</b> has rejected your application!
					</p>
					<p style="font-size:14px; color:#374151; margin:20px 0;">
						<span style="font-weight:bold;">you've been rejected from project with description</span>
					</p>
					<blockquote style="margin:0; padding:15px; background:#f3f4f6; border-left:4px solid #26868aff; font-style:italic; font-size:14px; color:#1f2937;">
						%s
					</blockquote>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						You weren't accepted due to:
					</p>
					<blockquote style="margin:0; padding:15px; background:#f3f4f6; border-left:4px solid #26868aff; font-style:italic; font-size:14px; color:#1f2937;">
						%s
					</blockquote>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					You are receiving this email because you have an account on <b>FindMe</b>.<br/>
					If you did not expect this, you can safely ignore this email.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>

	</body>
	</html>`,
		toUsername,
		fromUsername,
		message,
		reason,
	)

	return htmlBody, "Project Application Update"
}

// SendSubscriptionCreateEmail -> Sends notification about a subscription creation
func (e *EmailService) SendSubscriptionCreateEmail(username, amount, currency, planName, manageURL string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Subscription created</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">
	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#dc2626; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Subscription created</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						Your subscription has been successfully created and you now have access to our premium features.
						We are excited to have you on board
					</p>
					<table width="100%%" cellpadding="10" cellspacing="0" border="0" style="background:#fef2f2; border-radius:6px; border:1px solid #fecaca; margin-bottom:20px;">
						<tr>
							<td style="font-size:14px; color:#6b7280; border-bottom:1px solid #fecaca;">Plan</td>
							<td style="font-size:14px; color:#111827; font-weight:bold; border-bottom:1px solid #fecaca; text-align:right;">%s</td>
						</tr>
						<tr>
							<td style="font-size:14px; color:#6b7280;">Amount</td>
							<td style="font-size:14px; color:#111827; font-weight:bold; text-align:right;">%s %s</td>
						</tr>
					</table>
					<p style="font-size:14px; color:#374151; margin-bottom:10px;">
						<b>What happens next?</b>
					</p>
					<ul style="font-size:14px; color:#6b7280; margin-bottom:20px; padding-left:20px;">
						<li style="margin-bottom:8px;">You now have access to all our premium features</li>
						<li style="margin-bottom:8px;">You will have a recurring payment for this subscription and can cancel at anytime</li>
					</ul>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="%s" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold;">Manage Subscription</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					You are receiving this email because you have a subscription on <b>FindMe</b>.<br/>
					If you believe this is an error, please contact our support team.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>
	</body>
	</html>`,
		username,
		planName,
		currency,
		amount,
		manageURL,
	)
	return htmlBody, "Subscription Created - FindMe"
}

// SendTransactionFailedEmail -> Sends notification about a failed transaction for a subscription
func (e *EmailService) SendTransactionFailedEmail(username, amount, currency, planName, retryURL string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Payment Failed</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">
	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#dc2626; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Payment Failed</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						We were unable to process your subscription payment. This could be due to insufficient funds, an expired card, or a temporary issue with your bank.
					</p>
					<table width="100%%" cellpadding="10" cellspacing="0" border="0" style="background:#fef2f2; border-radius:6px; border:1px solid #fecaca; margin-bottom:20px;">
						<tr>
							<td style="font-size:14px; color:#6b7280; border-bottom:1px solid #fecaca;">Plan</td>
							<td style="font-size:14px; color:#111827; font-weight:bold; border-bottom:1px solid #fecaca; text-align:right;">%s</td>
						</tr>
						<tr>
							<td style="font-size:14px; color:#6b7280;">Amount</td>
							<td style="font-size:14px; color:#111827; font-weight:bold; text-align:right;">%s %s</td>
						</tr>
					</table>
					<p style="font-size:14px; color:#374151; margin-bottom:10px;">
						<b>What happens next?</b>
					</p>
					<ul style="font-size:14px; color:#6b7280; margin-bottom:20px; padding-left:20px;">
						<li style="margin-bottom:8px;">You have a <b>7-day grace period</b> to update your payment method</li>
						<li style="margin-bottom:8px;">Your subscription will remain active during this period</li>
						<li>After the grace period, your subscription will be paused</li>
					</ul>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="%s" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold;">Manage your subscription</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					You are receiving this email because you have a subscription on <b>FindMe</b>.<br/>
					If you believe this is an error, please contact our support team.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>
	</body>
	</html>`,
		username,
		planName,
		currency,
		amount,
		retryURL,
	)
	return htmlBody, "Action Required: Payment Failed - FindMe"
}

// SendSubscriptionReEnabledEmail -> Sends a notification about a re-enabled subscription
func (e *EmailService) SendSubscriptionReEnabledEmail(username, nextBillingDate string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Subscription Re-enabled</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">
	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#059669; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Welcome Back!</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						Great news! Your subscription has been re-enabled. You'll continue to enjoy uninterrupted access to all premium features.
					</p>
					<table width="100%%" cellpadding="10" cellspacing="0" border="0" style="background:#ecfdf5; border-radius:6px; border:1px solid #a7f3d0; margin-bottom:20px;">
						<tr>
							<td style="font-size:14px; color:#6b7280;">Status</td>
							<td style="font-size:14px; color:#059669; font-weight:bold; text-align:right;">Active</td>
						</tr>
						<tr>
							<td style="font-size:14px; color:#6b7280; border-top:1px solid #a7f3d0;">Next Billing Date</td>
							<td style="font-size:14px; color:#111827; font-weight:bold; text-align:right; border-top:1px solid #a7f3d0;">%s</td>
						</tr>
					</table>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						Your card on file will be charged automatically on the next billing date.
					</p>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="https://findme.app/dashboard" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold;">Go to Dashboard</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					Thank you for staying with us!<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>
	</body>
	</html>`,
		username,
		nextBillingDate,
	)
	return htmlBody, "Your FindMe Subscription Has Been Re-enabled"
}

// SendSubscriptionCancelledEmail -> Sends a notification for a cancelled subscription
func (e *EmailService) SendSubscriptionCancelledEmail(username, endDate string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Subscription Cancelled</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">
	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#6b7280; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Subscription Cancelled</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						Your subscription has been cancelled. You will <b>not</b> be billed on your next payment date.
					</p>
					<table width="100%%" cellpadding="10" cellspacing="0" border="0" style="background:#f3f4f6; border-radius:6px; margin-bottom:20px;">
						<tr>
							<td style="font-size:14px; color:#6b7280;">Access Until</td>
							<td style="font-size:14px; color:#111827; font-weight:bold; text-align:right;">%s</td>
						</tr>
					</table>
					<p style="font-size:14px; color:#374151; margin-bottom:20px;">
						You'll continue to have full access to all premium features until this date. After that, your account will revert to the free plan.
					</p>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						Changed your mind? You can re-enable your subscription anytime before it expires.
					</p>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="https://findme.app/settings/subscription" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold;">Manage Subscription</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					We're sorry to see you go. If you have any feedback, we'd love to hear it.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>
	</body>
	</html>`,
		username,
		endDate,
	)
	return htmlBody, "Your FindMe Subscription Has Been Cancelled"
}

// SendNotifyFreeTrialEnding -> Sends an notification for a free trial ending
func (e *EmailService) SendNotifyFreeTrialEnding(username, endDate, subURL string) (string, string) {
	htmlBody := fmt.Sprintf(`
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Your Free Trial is Ending</title>
	</head>
	<body style="margin:0; padding:0; background:#f9fafb; font-family:Arial, sans-serif;">
	<table width="100%%" cellpadding="0" cellspacing="0" border="0" style="background:#f9fafb; padding:40px 0;">
		<tr>
		<td align="center">
			<table width="600" cellpadding="0" cellspacing="0" border="0" style="background:#ffffff; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.05);">
			<tr>
				<td style="background:#f59e0b; padding:20px; text-align:center; border-top-left-radius:8px; border-top-right-radius:8px;">
					<h1 style="margin:0; font-size:22px; color:#ffffff;">Your Free Trial is Ending Soon</h1>
				</td>
			</tr>
			<tr>
				<td style="padding:30px;">
					<p style="font-size:16px; color:#111827; margin-bottom:20px;">Hello %s,</p>
					<p style="font-size:15px; color:#374151; margin-bottom:20px;">
						Your free trial ends on <b>%s</b>. We hope you've been enjoying FindMe!
					</p>
					<p style="font-size:14px; color:#374151; margin-bottom:10px;">
						<b>Here's what you'll lose access to:</b>
					</p>
					<ul style="font-size:14px; color:#6b7280; margin-bottom:20px; padding-left:20px;">
						<li style="margin-bottom:8px;">Advanced skill matching algorithms to recommend projects suited to you</li>
					</ul>
					<p style="font-size:14px; color:#6b7280; margin-bottom:30px;">
						Subscribe now to keep your premium access without any interruption.
					</p>
					<div style="text-align:center; margin-bottom:30px;">
						<a href="%s" style="background:#4f46e5; color:#ffffff; padding:12px 24px; text-decoration:none; border-radius:6px; font-size:15px; font-weight:bold;">Subscribe Now</a>
					</div>
				</td>
			</tr>
			<tr>
				<td style="padding:20px; text-align:center; font-size:12px; color:#9ca3af;">
					If you have any questions, feel free to reach out to our support team.<br/><br/>
					This is an automated email, please do not reply.
				</td>
			</tr>
			</table>
		</td>
		</tr>
	</table>
	</body>
	</html>`,
		username,
		endDate,
		subURL,
	)
	return htmlBody, "Your FindMe Free Trial is Ending Soon"
}

func (e *EmailService) SendEmail(to, subject, body string) error {
	msg := mail.NewMessage()
	msg.SetAddressHeader("From", e.Addr, "FindMe Team")
	msg.SetHeader("To", to)
	msg.SetHeader("Subject", subject)
	msg.SetBody("text/html", body)

	mail := mail.NewDialer(e.Server, e.MailPort, e.Addr, e.Password)

	if err := mail.DialAndSend(msg); err != nil {
		return err
	}

	return nil
}
```

## File: handlers/msg.go
```go
package handlers

import (
	"net/http"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

// CreateMessage godoc
// @Summary     Sending of message to a chat
// @Description An endpoint for sending a message to a chat
// @Tags Msg
// @Accept json
// @Produce json
// @Param payload body schema.NewMessage true "Message payload"
// @Security BearerAuth
// @Success 201 {object} schema.DocMsgResponse "Message Sent"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/send-message [post]
func (s *Service) CreateMessage(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.NewMessage
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(payload.ChatID, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	msg := model.UserMessage{
		ChatID:  payload.ChatID,
		Message: payload.Message,
		FromID:  uid,
	}

	if err := s.DB.AddMessage(&msg); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	mesRes := schema.ViewMessage{
		ID:      msg.ID,
		Message: msg.Message,
		UserID:  uid,
		Sent:    msg.CreatedAt,
		Edited:  msg.UpdatedAt,
	}

	ctx.JSON(http.StatusCreated, gin.H{"msg": mesRes})
}

// ViewMessages godoc
// @Summary    View All messages in a chat
// @Description An endpoint to view all messages in a chat (the chat history)
// @Tags Msg
// @Accept json
// @Produce json
// @Param id query string true "Chat ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocViewChatHistory "Chat history"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/view-hist [get]
func (s *Service) ViewMessages(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	cid := ctx.Query("id")
	if !model.IsValidUUID(cid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid chat id."})
		return
	}

	var chat model.Chat
	if err := s.DB.GetChatHistory(cid, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}
	var hist schema.ViewChat
	hist.CID = cid
	hist.Group = chat.Group
	if hist.Group {
		hist.Name = chat.Name
	} else {
		if chat.Users[0].ID == uid {
			hist.Name = chat.Users[1].UserName
		} else {
			hist.Name = chat.Users[0].UserName
		}
	}

	for _, msg := range chat.Messages {
		hist.Message = append(hist.Message, schema.ViewMessage{
			ID:      msg.ID,
			UserID:  uid,
			Sent:    msg.CreatedAt,
			Edited:  msg.UpdatedAt,
			Message: msg.Message,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"msg": hist})
}

// FetchUserChats godoc
// @Summary    Fetch the current user chats
// @Description An endpoint for fetching all chats of the current user
// @Tags Msg
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewAllChats "User chats"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/view-chats [get]
func (s *Service) FetchUserChats(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadCM(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var chats []schema.ViewChat
	for _, chat := range user.Chats {
		var lastChat *model.UserMessage
		var chatName string
		if !chat.Group {
			if chat.Users[0].ID == uid {
				chatName = chat.Users[1].UserName
			} else {
				chatName = chat.Users[0].UserName
			}
		} else {
			chatName = chat.Name
		}
		if len(chat.Messages) > 0 {
			lastChat = chat.Messages[len(chat.Messages)-1]
			chats = append(chats, schema.ViewChat{
				Name: chatName,
				CID:  chat.ID,
				Message: []schema.ViewMessage{
					{
						ID:      lastChat.ID,
						Message: lastChat.Message,
						UserID:  lastChat.FromID,
						Sent:    lastChat.CreatedAt,
						Edited:  lastChat.UpdatedAt,
					},
				},
				Group: chat.Group,
			})
		} else {
			chats = append(chats, schema.ViewChat{
				Name:  chatName,
				CID:   chat.ID,
				Group: chat.Group,
			})
		}

	}

	ctx.JSON(http.StatusOK, gin.H{"msg": chats})
}

// EditMessage godoc
// @Summary    Editing a sent message
// @Description An endpoint for editing a sent message
// @Tags Msg
// @Accept json
// @Produce json
// @Param payload body schema.EditMessage true "Message payload"
// @Security BearerAuth
// @Success 202 {object} schema.DocMsgResponse "Message edited"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/edit-message [patch]
func (s *Service) EditMessage(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.EditMessage
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var msg model.UserMessage
	if err := s.DB.FetchMsg(&msg, payload.ID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if msg.FromID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You cannot delete a message that's not owned by you."})
		return
	}

	msg.Message = payload.Message
	if err := s.DB.SaveMsg(&msg); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	msgRes := schema.ViewMessage{
		ID:      msg.ID,
		Message: msg.Message,
		UserID:  msg.FromID,
		Sent:    msg.CreatedAt,
		Edited:  msg.UpdatedAt,
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": msgRes})
}

// DeleteMessage godoc
// @Summary     Delete a sent message
// @Description An endpoint for deleting a sent message of the current user
// @Tags Msg
// @Accept json
// @Produce json
// @Param id query string true "Msg ID"
// @Security BearerAuth
// @Success 204 {object} nil "Message deleted"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/delete-message [delete]
func (s *Service) DeleteMessage(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	mid := ctx.Query("id")
	if !model.IsValidUUID(mid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid message id."})
		return
	}

	var msg model.UserMessage
	if err := s.DB.FetchMsg(&msg, mid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if msg.FromID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You cannot delete a message that's not owned by you."})
	}

	if err := s.DB.DeleteMsg(&msg); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// OpenChat godoc
// @Summary     Open a chat between users
// @Description An endpoint for opening a chat between users with IDs.
// @Tags Msg
// @Accept json
// @Produce json
// @Param id query string true "User ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocViewChatHistory "Chat opened"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/open-chat [get]
func (s *Service) OpenChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	fid := ctx.Query("id")
	if !model.IsValidUUID(fid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid friend id."})
		return
	}

	var chat model.Chat
	if err := s.DB.FindChat(uid, fid, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var msgs []schema.ViewMessage
	for _, msg := range chat.Messages {
		msgs = append(msgs, schema.ViewMessage{
			ID:      msg.ID,
			Message: msg.Message,
			UserID:  msg.FromID,
			Sent:    msg.CreatedAt,
			Edited:  msg.UpdatedAt,
		})
	}

	var chatName string
	if chat.Users[0].ID == uid {
		chatName = chat.Users[1].UserName
	} else {
		chatName = chat.Users[0].UserName
	}

	result := schema.ViewChat{
		Name:    chatName,
		CID:     chat.ID,
		Message: msgs,
		Group:   chat.Group,
	}

	ctx.JSON(http.StatusOK, gin.H{"msg": result})
}

// RenameChat godoc
// @Summary   Renaming a group chat
// @Description An endpoint for renaming a group chat
// @Tags Msg
// @Accept json
// @Produce json
// @Param payload body schema.RenameChat true "Chat payload"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "Chat Updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/rename-chat [patch]
func (s *Service) RenameChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.RenameChat
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(payload.ChatID, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if *chat.OwnerID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to rename this group chat."})
		return
	}

	chat.Name = payload.Name
	if err := s.DB.SaveChat(&chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Chat name updated successfully."})
}

// AddUserToChat godoc
// @Summary Add a user to a group chat
// @Description An endpoint for adding users to a group chat
// @Tags Msg
// @Accept json
// @Produce json
// @Param payload body schema.AddUserChat true "Chat payload"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "User Added"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/add-user [put]
func (s *Service) AddUserToChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.AddUserChat
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(payload.ChatID, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if *chat.OwnerID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You aren't permitted to add users to this chat."})
		return
	}

	if payload.UserID == uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You're already in the group."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, payload.UserID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.AddUserChat(&chat, &user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "User added to Chat."})
}

// RemoveUserChat godoc
// @Summary Remove a user from a group
// @Description An endpoint for removing a user from a group chat
// @Tags Msg
// @Accept json
// @Produce json
// @Param payload body schema.AddUserChat true "Chat payload"
// @Security BearerAuth
// @Success 204 {object} nil "User removed"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/remove-user [delete]
func (s *Service) RemoveUserChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.AddUserChat
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var chat model.Chat

	if err := s.DB.FetchChat(payload.ChatID, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if *chat.OwnerID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You aren't permitted to remove users from this chat."})
		return
	}

	if payload.UserID == uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can't remove yourself from the group."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, payload.UserID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.RemoveUserChat(&chat, &user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// TransferOwner godoc
// @Summary Transfer group chat ownership to another user
// @Description An endpoint for transferring the ownership of a group chat to another user
// @Tags Msg
// @Accept json
// @Produce json
// @Param payload body schema.AddUserChat true "payload"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "Ownership Transferred"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/transfer-owner [patch]
func (s *Service) TransferOwner(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.AddUserChat
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload."})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(payload.ChatID, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if !chat.Group {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can only transfer ownership in group chats."})
		return
	}

	if chat.OwnerID == nil || *chat.OwnerID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to transfer ownership."})
		return
	}

	ownerID := payload.UserID
	chat.OwnerID = &ownerID
	if err := s.DB.SaveChat(&chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Ownership transferred successfully."})
}

// LeaveChat godoc
// @Summary Leave a group chat
// @Description An endpoint for leaving a group chat
// @Tags Msg
// @Accept json
// @Produce json
// @Param id query string true "Chat ID"
// @Security BearerAuth
// @Success 204 {object} nil "Chat removed"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/leave-chat [delete]
func (s *Service) LeaveChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	cid := ctx.Query("id")
	if !model.IsValidUUID(cid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid chat id."})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(cid, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if *chat.OwnerID == user.ID {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can't leave this chat you can to delete it if you must or transfer ownership."})
		return
	}

	if err := s.DB.LeaveChat(&chat, &user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// DeleteChat godoc
// @Summary Delete a group chat
// @Description An endpoint for deleting a group chat owned by the current user
// @Tags Msg
// @Accept json
// @Produce json
// @Param id query string true "chat ID"
// @Security BearerAuth
// @Success 204 {object} nil "Chat deleted"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/msg/delete-chat [delete]
func (s *Service) DeleteChat(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	cid := ctx.Query("id")
	if !model.IsValidUUID(cid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid chat id."})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(cid, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if *chat.OwnerID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have the permission to delete this chat."})
		return
	}

	if err := s.DB.DeleteChat(&chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}
```

## File: schema/user.go
```go
package schema

import "time"

type SignupRequest struct {
	FullName  string   `json:"fullname" binding:"required"`
	UserName  string   `json:"username" binding:"required"`
	Email     string   `json:"email" binding:"required,email"`
	Country   string   `json:"country" binding:"required"`
	Password  string   `json:"password" binding:"required,min=8"`
	Bio       string   `json:"bio" binding:"omitempty,max=50"`
	Skills    []string `json:"skills"`
	Interests []string `json:"interests" binding:"omitempty,max=5"`
}

type GitHubUser struct {
	ID       int64  `json:"id" binding:"required"`
	FullName string `json:"name" binding:"required"`
	UserName string `json:"login" binding:"required"`
	Email    string `json:"email"`
	Bio      string `json:"bio"`
}

type LoginRequest struct {
	UserName string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

type UserProfileRequest struct {
	UserName string `json:"username" binding:"required"`
	FullName string `json:"fullname" binding:"required"`
	Email    string `json:"email" binding:"required,email"`
	Country  string `json:"country" binding:"required"`
}

type UpdateUserBio struct {
	Bio string `json:"bio" binding:"omitempty,max=50"`
}

type UpdateUserInterests struct {
	Interest []string `json:"interests" binding:"omitempty,max=5"`
}

type UserAvailabilityStatusRequest struct {
	Availability bool `json:"availability" binding:"required"`
}

type UpdateUserSkillsRequest struct {
	Skills []string `json:"skills" binding:"required"`
}

type DeleteUserSkillsRequest struct {
	Skills []string `json:"skills" binding:"required"`
}

type ForgotPasswordEmail struct {
	Email string `json:"email" binding:"required,email"`
}

type UpdatePassword struct {
	FormerPassword string `json:"password" binding:"required"`
	Password       string `json:"new_password" binding:"required,min=8"`
}

type ResetPassword struct {
	Password string `json:"password" binding:"required,min=8"`
}

type SendFriendReq struct {
	Message string `json:"msg" binding:"omitempty,max=50"`
	ID      string `json:"uid" binding:"required"`
}

type SearchUserbySkills struct {
	Skills []string `json:"skills" binding:"required"`
}

type SearchUser struct {
	ID           string
	UserName     string
	Skills       []string
	GitUser      bool
	GitUserName  *string
	Availability bool
	Bio          string
	Interests    []string
}

type UserProfileResponse struct {
	ID           string
	UserName     string
	FullName     string
	Email        string
	Country      string
	GitUserName  *string
	Gituser      bool
	Bio          string
	Availability bool
	Skills       []string
	Interests    []string
}

type ViewSubscriptions struct {
	ID    string
	Start time.Time
	End   time.Time
}

type FriendReqStatus struct {
	ID       string
	Username string
	Message  string
	Status   string
	Sent     time.Time
}

type ViewFriends struct {
	ID       string
	Username string
	Bio      string
}

type ViewRepo struct {
	Name     string `json:"name"`
	HTMLURL  string `json:"html_url"`
	Language string `json:"language"`
}

type GitToken struct {
	AccessToken string `json:"access_token"`
}
```

## File: test/unit/main_test.go
```go
// Package unit -> Unit tests for the app
package unit

import (
	"net/http"
	"os"
	"testing"
	"time"

	"findme/core"
	"findme/handlers"
	"findme/model"

	"github.com/gin-gonic/gin"

	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	id1 = ""
	id2 = ""
	pid = ""
	cid = ""
	gid = ""
)

var router *gin.Engine

func getTestDB() *core.GormDB {
	db, _ := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Silent),
	})

	_ = db.AutoMigrate(
		&model.User{},
		&model.Skill{},
		&model.Project{},
		&model.ProjectReq{},
		&model.ProjectSkill{},
		&model.UserSkill{},
		&model.UserFriend{},
		&model.FriendReq{},
		&model.UserMessage{},
		&model.UserSavedProject{},
		&model.Chat{},
		&model.ChatUser{},
		&model.Subscriptions{},
		&model.Transactions{},
	)

	_ = db.SetupJoinTable(&model.Project{}, "Tags", &model.ProjectSkill{})
	_ = db.SetupJoinTable(&model.User{}, "Skills", &model.UserSkill{})
	_ = db.SetupJoinTable(&model.User{}, "Friends", &model.UserFriend{})
	_ = db.SetupJoinTable(&model.User{}, "Chats", &model.ChatUser{})
	_ = db.SetupJoinTable(&model.User{}, "SavedProjects", &model.UserSavedProject{})

	gdb := core.NewGormDB(db)
	superUser(gdb)
	return gdb
}

func getTestRouter(service *handlers.Service) *gin.Engine {
	gin.SetMode(gin.TestMode)
	router := gin.Default()
	handlers.SetupHandler(router, service)
	return router
}

func superUser(db *core.GormDB) {
	gitusername := "imisi99"

	be := model.Skill{Name: "backend"}
	ml := model.Skill{Name: "ml"}

	skill := []*model.Skill{&ml, &be}
	db.DB.Create(skill)

	hashpass, _ := core.HashPassword("Password")
	super := model.User{
		FullName:     "Isong Imisioluwa",
		UserName:     "Imisioluwa23",
		GitUserName:  &gitusername,
		GitUser:      true,
		Bio:          "I am the super user",
		Email:        "isongrichard234@gmail.com",
		Skills:       []*model.Skill{&be, &ml},
		Password:     hashpass,
		Availability: true,
		Country:      "NGN",
	}

	period := time.Now()
	val := "someVal"

	super1 := model.User{
		FullName:        "Isong Imisioluwa",
		UserName:        "knightmares23",
		Email:           "knightmares234@gmail.com",
		Password:        hashpass,
		Availability:    true,
		Skills:          []*model.Skill{&be},
		Bio:             "I'm the second super user",
		Country:         "NGN",
		NextPaymentDate: &period,
		Last4:           &val,
		ExpMonth:        &val,
		ExpYear:         &val,
		CardType:        &val,
	}

	users := []*model.User{&super, &super1}
	db.DB.Create(users)

	post := model.Project{
		Title:        "A project to connect developers",
		Description:  "Working on a platform for finding developers for contributive project",
		UserID:       super.ID,
		Views:        4,
		Tags:         []*model.Skill{&be},
		Availability: true,
		GitProject:   true,
		GitLink:      "https://github.com/imisi99/FindMe",
	}

	chat := model.Chat{}

	groupchat := model.Chat{}
	groupchat.Group = true
	groupchat.OwnerID = &super.ID

	db.DB.Create(&post)

	db.DB.Create(&chat)
	db.DB.Create(&groupchat)

	_ = db.DB.Model(&super).Association("Chats").Append(&chat)
	_ = db.DB.Model(&super1).Association("Chats").Append(&chat)
	_ = db.DB.Model(&super).Association("Chats").Append(&groupchat)

	id1 = super.ID
	id2 = super1.ID
	pid = post.ID
	cid = chat.ID
	gid = groupchat.ID
}

func TestMain(m *testing.M) {
	db := getTestDB()
	rdb := NewCacheMock()
	git := NewGitMock()
	transc := NewTranscMock()
	chathub := core.NewChatHub(20)
	emailHub := NewEmailHubMock()
	cron := NewCronMock()
	embhub := NewEmbeddingMock()
	recHub := NewRecommendationMock()

	go chathub.Run()
	service := handlers.NewService(db, rdb, emailHub, git, transc, embhub, recHub, &http.Client{}, chathub, cron)

	var skills []model.Skill
	_ = service.DB.FetchAllSkills(&skills)
	service.RDB.CacheSkills(skills)
	router = getTestRouter(service)
	tokenString, _ = handlers.GenerateJWT(id1, "login", true, handlers.JWTExpiry)  // Initially the logged in user is the super user me for the post test
	tokenString1, _ = handlers.GenerateJWT(id2, "login", true, handlers.JWTExpiry) // User for saving post
	code := m.Run()

	os.Exit(code)
}
```

## File: test/unit/post_test.go
```go
package unit

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"findme/schema"

	"github.com/stretchr/testify/assert"
)

var (
	projectPayload = schema.NewProjectRequest{
		Title:       "A project",
		Description: "Testing the project creation endpoint.",
		Tags:        []string{"ml", "backend"},
		Git:         true,
	}
	defProjectDescription = "Working on a platform for finding developers for contributive project"
	reqPayload            = map[string]string{
		"msg": "hey I'm interested in this project",
	}
	project    ProjectResponse
	projectReq ProjectApplicationResponse
)

func TestGetProject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/post/view?id="+pid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), defProjectDescription)
}

func TestCreateProject(t *testing.T) {
	payload := projectPayload

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/create", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)
	assert.Contains(t, w.Body.String(), projectPayload.Description)
	_ = json.Unmarshal(w.Body.Bytes(), &project)
}

func TestEditProject(t *testing.T) {
	payload := projectPayload
	payload.Description = "Testing the edit project endpoint"

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPut, "/api/post/edit?id="+project.ID, bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), payload.Description)
}

func TestGetProjects(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/post/posts/all", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "Testing the edit project endpoint")
	assert.Contains(t, w.Body.String(), defProjectDescription)
}

func TestRecommendUsers(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/post/recommend?id="+project.ID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestSearchProjectTags(t *testing.T) {
	payload := map[string][]string{"tags": {"backend"}}
	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/tags", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), defProjectDescription)
	assert.Contains(t, w.Body.String(), "Testing the edit project endpoint")
}

func TestEditProjectView(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/post/edit-view?id="+pid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "5")
}

func TestEditProjectAvailability(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/post/edit-status?id="+pid+"&status=false", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "false")
}

func TestSaveProjectFailed(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPut, "/api/post/save-post?id="+pid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusForbidden, w.Code)
	assert.Contains(t, w.Body.String(), "You can't save a project created by you.")
}

func TestSaveProject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPut, "/api/post/save-post?id="+pid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestViewSavedProject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/post/view/saved-post", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), defProjectDescription)
}

func TestRemoveSavedProject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/post/remove-post?id="+pid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestApplyForProjectFailed(t *testing.T) {
	body, _ := json.Marshal(reqPayload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/apply?id="+pid, bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusForbidden, w.Code)
	assert.Contains(t, w.Body.String(), "The owner of the project is no longer accepting applications.")
}

func TestEditProjectAvailabilityTrue(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/post/edit-status?id="+pid+"&status=true", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "true")
}

func TestApplyForProject(t *testing.T) {
	body, _ := json.Marshal(reqPayload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/apply?id="+pid, bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, w.Code, http.StatusOK)
	assert.Contains(t, w.Body.String(), reqPayload["msg"])

	_ = json.Unmarshal(w.Body.Bytes(), &projectReq)
}

func TestViewProjectApplications(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/post/view-applications", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), reqPayload["msg"])
	assert.Contains(t, w.Body.String(), superUserName)
}

func TestViewSingleProjectApplications(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/post/view-application?id="+pid, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), reqPayload["msg"])
	assert.Contains(t, w.Body.String(), superUserName1)
	assert.Contains(t, w.Body.String(), projectReq.ReqID)
}

func TestUpdateProjectApplicationInvalidStatus(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/post/update-application?id="+projectReq.ReqID+"&status=invalidstatus", bytes.NewBufferString(`{}`))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "Invalid status.")
}

func TestUpdateProjectApplicationReject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/post/update-application?id="+projectReq.ReqID+"&status=rejected", bytes.NewBufferString(`{}`))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Application status updated successfully.")
}

func TestCreateProjectApplicationToAccept(t *testing.T) {
	body, _ := json.Marshal(defPayload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/apply?id="+pid, bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	_ = json.Unmarshal(w.Body.Bytes(), &projectReq)
}

func TestUpdateProjectApplicationAccept(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/post/update-application?id="+projectReq.ReqID+"&status=accepted", bytes.NewBufferString(`{}`))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Application status updated successfully.")
}

func TestCreateProjectApplicationToDelete(t *testing.T) {
	body, _ := json.Marshal(defPayload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/apply?id="+project.ID, bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	_ = json.Unmarshal(w.Body.Bytes(), &projectReq)
}

func TestDeleteProjectApplication(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/post/delete-application?id="+projectReq.ReqID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestCreateProjectApplicationToClear(t *testing.T) {
	body, _ := json.Marshal(defPayload)

	req, _ := http.NewRequest(http.MethodPost, "/api/post/apply?id="+project.ID, bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	_ = json.Unmarshal(w.Body.Bytes(), &projectReq)
}

func TestClearProjectApplication(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/post/clear-application?id="+project.ID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestDeleteProject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/post/delete?id="+project.ID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}
```

## File: main.go
```go
// @title FindMe API
// @version 1.0
// @description API documentation for FindMe application.
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @BasePath /
package main

// TODO:
// Test the Paystack service
// Add a readme docs

//DONE:
// Fix the cache plans to store the struct directly (or a work around)
// The Email token for the paystack stuff does it come with the sub create event (fix this)
//

import (
	"log"
	"net/http"
	"os"
	"time"

	"findme/core"
	"findme/database"
	_ "findme/docs"
	"findme/handlers"
	"findme/model"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
	"github.com/robfig/cron/v3"

	swagFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func main() {
	log.SetPrefix("[FindMe]")
	log.SetFlags(log.Lshortfile)

	err := godotenv.Load()
	if err != nil {
		log.Println("[WARNING] Error loading .env file ->", err, "Ignore if in production")
	}

	// Setup db, redis and cron
	dbClient := database.Connect()
	rdbClient := database.ConnectRedis()
	db := core.NewGormDB(dbClient)
	rdb := core.NewRDB(rdbClient)
	cron := cron.New()

	// setup chat, email rec and embedding hub
	client := &http.Client{Timeout: 10 * time.Minute}
	email := core.NewEmailService("smtp.gmail.com", os.Getenv("EMAIL"), os.Getenv("EMAIL_APP_PASSWORD"), 587)

	chathub := core.NewChatHub(1000)
	emailHub := core.NewEmailHub(2000, 5, email)
	embHub := core.NewEmbeddingHub(100, 10, "emb:8000")
	recHub := core.NewRecommendationHub(10, 100, "rec:8050")

	worker := core.NewCron(db, emailHub, cron)

	// set up git and transc service
	git := handlers.NewGitService(os.Getenv("GIT_CLIENT_ID"), os.Getenv("GIT_CLIENT_SECRET"), os.Getenv("GIT_CALLBACK_URL"), db, embHub, client)
	transc := handlers.NewTranscService(db, rdb, emailHub, os.Getenv("PAYSTACK_API_KEY"), client)
	service := handlers.NewService(db, rdb, emailHub, git, transc, embHub, recHub, client, chathub, worker)

	go chathub.Run()
	go embHub.Run()
	go emailHub.Run()
	go recHub.Run()
	cron.Start()

	var skills []model.Skill
	if err := service.DB.FetchAllSkills(&skills); err != nil {
		log.Fatalln("Failed to Fetch skills from DB exiting...")
	}
	service.RDB.CacheSkills(skills)
	router := gin.Default()

	// Swagger UI
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swagFiles.Handler))

	// Cron Worker
	err = service.Cron.TrialEndingReminders()
	if err != nil {
		log.Println("[CRON] An error occured err -> ", err.Error())
	}

	handlers.SetupHandler(router, service)

	err = router.Run("0.0.0.0:8080")
	if err != nil {
		log.Fatalln("Failed to start app -> ", err.Error())
	}
}
```

## File: core/database.go
```go
package core

import (
	"errors"
	"log"
	"net/http"
	"time"

	"findme/model"

	"gorm.io/gorm"
)

type DB interface {
	CheckHealth() error
	FetchAllSkills(skills *[]model.Skill) error
	AddUser(user *model.User) error
	FindUsers(users *[]model.User, ids []string) error
	CheckExistingUser(user *model.User, email, username string) error
	CheckExistingUserUpdate(user *model.User, email, username, uid string) error
	CheckExistingEmail(email string) error
	CheckExistingUsername(username string) error
	CheckExistingFriends(uid, fid string) (error, bool)
	CheckExistingFriendReq(uid, fid string) (error, bool)
	CheckExistingAppReq(pid, uid string) (error, bool)
	VerifyUser(user *model.User, username string) error
	SaveUser(user *model.User) error
	FetchUser(user *model.User, uid string) error
	FetchUserPreloadSP(user *model.User, uid string) error
	FetchUserPreloadS(user *model.User, uid string) error
	FetchUserPreloadF(user *model.User, uid string) error
	FetchUserPreloadFReq(user *model.User, uid string) error
	FetchUserPreloadPReq(user *model.User, uid string) error
	FetchUserPreloadT(user *model.User, uid string) error
	FetchUserPreloadSub(user *model.User, uid string) error
	SearchUserEmail(user *model.User, email string) error
	SearchUserPreloadSP(user *model.User, username string) error
	SearchUserGitPreloadSP(user *model.User, gitusername string) error
	SearchUsersBySKills(users *[]model.User, skills []string, uid string) error
	AddFriendReq(req *model.FriendReq) error
	ViewFriendReq(user *model.User, uid string) error
	FetchFriendReq(req *model.FriendReq, rid string) error
	UpdateFriendReqReject(req *model.FriendReq) error
	UpdateFriendReqAccept(req *model.FriendReq, user, friend *model.User, chat *model.Chat) error
	DeleteFriendReq(req *model.FriendReq) error
	DeleteFriend(user, friend *model.User, chat *model.Chat) error
	UpdateSkills(user *model.User, skills []*model.Skill) error
	DeleteSkills(user *model.User, skills []*model.Skill) error
	DeleteUser(user *model.User) error
	AddProject(project *model.Project) error
	FindProjects(projects *[]model.Project, ids []string) error
	FetchUserProjects(user *model.User, uid string) error
	FetchProject(project *model.Project, pid string) error
	FetchProjectPreloadT(project *model.Project, pid string) error
	FetchProjectPreloadTU(project *model.Project, pid string) error
	FetchProjectPreloadA(project *model.Project, pid string) error
	FetchProjectPreloadC(project *model.Project, pid string) error
	EditProject(project *model.Project, skills []*model.Skill) error
	SaveProject(project *model.Project) error
	BookmarkProject(user *model.User, project *model.Project) error
	FetchUserPreloadB(user *model.User, uid string) error
	FetchProjectPreloadU(project *model.Project, pid string) error
	SearchProjectsBySKills(projects *[]model.Project, skills []string, uid string) error
	RemoveBookmarkedProject(user *model.User, project *model.Project) error
	AddProjectApplicationReq(req *model.ProjectReq) error
	ViewProjectApplications(user *model.User, uid string) error
	FetchProjectApplication(req *model.ProjectReq, rid string) error
	UpdateProjectAppliationReject(req *model.ProjectReq) error
	UpdateProjectApplicationAccept(req *model.ProjectReq, user *model.User, chat *model.Chat) error
	UpdateProjectApplicationAcceptF(req *model.ProjectReq, user1, user2 *model.User, project *model.Project, chat *model.Chat) error
	FetchProjectAppPreloadFU(req *model.ProjectReq, rid string) error
	DeleteProjectApplicationReq(req *model.ProjectReq) error
	ClearProjectApplication(req []*model.ProjectReq) error
	DeleteProject(project *model.Project) error
	AddSkills(skills *[]*model.Skill) error
	FindExistingSkills(skills *[]*model.Skill, skill []string) error
	FindExistingGitID(user *model.User, gitid int64) error
	AddMessage(msg *model.UserMessage) error
	GetChatHistory(chatID string, chat *model.Chat) error
	FetchChat(chatID string, chat *model.Chat) error
	FetchUserPreloadCM(user *model.User, uid string) error
	FetchUserPreloadC(user *model.User, uid string) error
	FetchMsg(msg *model.UserMessage, mid string) error
	SaveMsg(msg *model.UserMessage) error
	SaveChat(chat *model.Chat) error
	DeleteMsg(msg *model.UserMessage) error
	FindChat(uid, fid string, chat *model.Chat) error
	AddUserChat(chat *model.Chat, user *model.User) error
	RemoveUserChat(chat *model.Chat, user *model.User) error
	LeaveChat(chat *model.Chat, user *model.User) error
	DeleteChat(chat *model.Chat) error
	AddTransaction(transc *model.Transactions) error
	FetchTransaction(paystackRef string, transc *model.Transactions) error
	AddSubscription(sub *model.Subscriptions) error
	AddTranscSub(transc *model.Transactions, sub *model.Subscriptions, user *model.User) error
	AddTranscSaveSub(transc *model.Transactions, sub *model.Subscriptions, user *model.User) error
	AddFailedSub(sub *model.Subscriptions, user *model.User) error
	FetchTrialEndingUsers(users *[]model.User, limit, today time.Time) error
	UpdateSentReminder(ids []string) error
	FetchSub(sub *model.Subscriptions, sid string) error
}

type GormDB struct {
	DB *gorm.DB
}

func NewGormDB(db *gorm.DB) *GormDB {
	return &GormDB{DB: db}
}

func (db *GormDB) CheckHealth() error {
	var ping string
	err := db.DB.Raw("SELECT 1").Scan(&ping).Error
	return err
}

// FetchAllSkills -> Retrieves all the skills from the db
func (db *GormDB) FetchAllSkills(skills *[]model.Skill) error {
	if err := db.DB.Find(skills).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch skills."}
	}
	return nil
}

// AddUser -> Adds a user to the db
func (db *GormDB) AddUser(user *model.User) error {
	if err := db.DB.Create(user).Error; err != nil {
		log.Println("Failed to create user err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to create new user."}
	}
	return nil
}

// FindUsers -> Retrieves a list of users from the db with their skills preloaded
func (db *GormDB) FindUsers(users *[]model.User, ids []string) error {
	if err := db.DB.Preload("Skills").Where("id IN ?", ids).Find(users).Error; err != nil {
		log.Println(err)
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve users."}
	}
	return nil
}

// CheckExistingUser -> Checks for an existing user with the email or username
func (db *GormDB) CheckExistingUser(user *model.User, email, username string) error {
	err := db.DB.Where("username = ? OR email = ?", username, email).First(user).Error
	if err == nil {
		if user.Email == email {
			return &CustomMessage{Code: http.StatusConflict, Message: "Email already in use!"}
		} else {
			return &CustomMessage{Code: http.StatusConflict, Message: "Username already in use!"}
		}
	}
	if !errors.Is(err, gorm.ErrRecordNotFound) {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
	}
	return nil
}

// CheckExistingUserUpdate -> Checks for an existing user with the email or username that is not the current user
func (db *GormDB) CheckExistingUserUpdate(user *model.User, email, username, uid string) error {
	err := db.DB.Where("username = ? OR email = ?", username, email).First(user).Error
	if err == nil && user.ID != uid {
		if user.Email == email {
			return &CustomMessage{Code: http.StatusConflict, Message: "Email already in use!"}
		} else {
			return &CustomMessage{Code: http.StatusConflict, Message: "Username already in use!"}
		}
	}
	if !errors.Is(err, gorm.ErrRecordNotFound) && err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
	}
	return nil
}

// CheckExistingFriends -> Checks for an existing friendship between users
func (db *GormDB) CheckExistingFriends(uid, fid string) (error, bool) {
	var count int64
	if err := db.DB.Model(&model.UserFriend{}).Where("(user_id = ? AND friend_id = ?)", uid, fid).Count(&count).Error; err != nil {
		return &CustomMessage{http.StatusInternalServerError, "Failed to check for existing friendship staus."}, false
	}
	if count > 0 {
		return &CustomMessage{Code: http.StatusConflict, Message: "You're already friends!"}, true
	}
	return nil, false
}

// CheckExistingFriendReq -> Checks for an existing friend request between users
func (db *GormDB) CheckExistingFriendReq(uid, fid string) (error, bool) {
	var count int64
	if err := db.DB.Model(&model.FriendReq{}).Where("(user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)", uid, fid, fid, uid).Count(&count).Error; err != nil {
		return &CustomMessage{http.StatusInternalServerError, "Failed to check for existing friend req."}, false
	}
	if count > 0 {
		return &CustomMessage{http.StatusConflict, "An existing request exists."}, true
	}
	return nil, false
}

// CheckExistingAppReq -> Checks for an existing project application from a user
func (db *GormDB) CheckExistingAppReq(pid, uid string) (error, bool) {
	var count int64
	if err := db.DB.Model(&model.ProjectReq{}).Where("(project_id = ? AND from_id = ?)", pid, uid).Count(&count).Error; err != nil {
		return &CustomMessage{http.StatusInternalServerError, "Failed to check for existing project application req."}, false
	}
	if count > 0 {
		return &CustomMessage{http.StatusConflict, "An existing request exists."}, true
	}
	return nil, false
}

// VerifyUser -> Verify users for logging-in
func (db *GormDB) VerifyUser(user *model.User, username string) error {
	if err := db.DB.Preload("Subscriptions").Where("username = ? OR email = ?", username, username).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Invalid Credentials!"}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// SaveUser -> Saves a user to the db after changes to the record
func (db *GormDB) SaveUser(user *model.User) error {
	if err := db.DB.Save(user).Error; err != nil {
		log.Println("Failed to save user with id -> ", user.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to save user."}
	}
	return nil
}

// FetchUser -> Retrieves a user from the db
func (db *GormDB) FetchUser(user *model.User, uid string) error {
	if err := db.DB.Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadSP -> Retrieves a user from the db and preloads the user skills
// and projects with tags owned by the user
func (db *GormDB) FetchUserPreloadSP(user *model.User, uid string) error {
	if err := db.DB.Preload("Projects.Tags").Preload("Skills").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadS -> Retrieves a user from the db and preloads the user skills
func (db *GormDB) FetchUserPreloadS(user *model.User, uid string) error {
	if err := db.DB.Preload("Skills").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadF -> Retrieves a user from the db and preloads the user friends
func (db *GormDB) FetchUserPreloadF(user *model.User, uid string) error {
	if err := db.DB.Preload("Friends").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadFReq -> Retrieves a user from the db and preloads the friend req sent and received by the user
func (db *GormDB) FetchUserPreloadFReq(user *model.User, uid string) error {
	if err := db.DB.Preload("Friends").Preload("FriendReq.Friend").Preload("RecFriendReq.User").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadPReq -> Retrieves a user from the db and preloads the project applications made by the user
func (db *GormDB) FetchUserPreloadPReq(user *model.User, uid string) error {
	if err := db.DB.Preload("SentProjectReq").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadT -> Retrieves a user from the db with the user Transactions preloaded
func (db *GormDB) FetchUserPreloadT(user *model.User, uid string) error {
	if err := db.DB.Preload("Transactions").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found"}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchUserPreloadSub -> Retrieves a user from the db with the subscriptions preloaded
func (db *GormDB) FetchUserPreloadSub(user *model.User, uid string) error {
	if err := db.DB.Preload("Subscriptions").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found"}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// SearchUserEmail -> Searches for a user by using the email address of the user
func (db *GormDB) SearchUserEmail(user *model.User, email string) error {
	if err := db.DB.Where("email = ?", email).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// SearchUserPreloadSP -> Searches for a user by using the username and preloads the user skills
// and projects with tags owned by the user
func (db *GormDB) SearchUserPreloadSP(user *model.User, username string) error {
	if err := db.DB.Preload("Skills").Preload("Projects.Tags").Where("username = ?", username).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// SearchUserGitPreloadSP -> Searches for a user by using the github username and preloads the user skills
// and projects with tags owned by the user
func (db *GormDB) SearchUserGitPreloadSP(user *model.User, gitusername string) error {
	if err := db.DB.Preload("Skills").Preload("Projects.Tags").Where("gitusername = ?", gitusername).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// SearchUsersBySKills -> Searches for users that contain a given set of skills and preloads the users skills
func (db *GormDB) SearchUsersBySKills(users *[]model.User, skills []string, uid string) error {
	subquery := db.DB.Select("user_id").
		Table("user_skills").
		Joins("JOIN skills s ON user_skills.skill_id = s.id").
		Where("s.name IN ?", skills)

	if err := db.DB.Preload("Skills").Where("id IN (?)", subquery).Where("id != ?", uid).Find(users).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to find users."}
	}
	return nil
}

// AddFriendReq -> Adds a friend req to the db
func (db *GormDB) AddFriendReq(req *model.FriendReq) error {
	if err := db.DB.Create(req).Error; err != nil {
		log.Println("Failed to create friend req err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to create request."}
	}
	return nil
}

// ViewFriendReq -> Retrieves all friend req sent and received by a user
func (db *GormDB) ViewFriendReq(user *model.User, uid string) error {
	if err := db.DB.Preload("FriendReq.Friend").Preload("RecFriendReq.User").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve user."}
		}
	}
	return nil
}

// FetchFriendReq -> Retrieves a friend req from the db
func (db *GormDB) FetchFriendReq(req *model.FriendReq, rid string) error {
	if err := db.DB.Where("id = ?", rid).First(req).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Request not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve request."}
		}
	}
	return nil
}

// UpdateFriendReqReject -> Updates the status of a friend req to reject in the db
func (db *GormDB) UpdateFriendReqReject(req *model.FriendReq) error {
	if err := db.DB.Delete(req).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to update request status."}
	}
	return nil
}

// UpdateFriendReqAccept -> Updates the status of a friend req to accept
// and creates friendship and chat between users in the db
func (db *GormDB) UpdateFriendReqAccept(req *model.FriendReq, user, friend *model.User, chat *model.Chat) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Unscoped().Delete(req).Error; err != nil {
			return err
		}
		if err := tx.Model(user).Association("Friends").Append(friend); err != nil {
			return err
		}
		if err := tx.Model(friend).Association("Friends").Append(user); err != nil {
			return err
		}
		if err := tx.Create(chat).Error; err != nil {
			return err
		}
		if err := tx.Model(user).Association("Chats").Append(chat); err != nil {
			return err
		}
		if err := tx.Model(friend).Association("Chats").Append(chat); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to update request status."}
	}
	return nil
}

// DeleteFriendReq -> Deletes a friend req from the db
func (db *GormDB) DeleteFriendReq(req *model.FriendReq) error {
	if err := db.DB.Unscoped().Delete(req).Error; err != nil {
		log.Println("Failed to delete friend req with id -> ", req.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to delete friend request."}
	}
	return nil
}

// DeleteFriend -> Delete friendship between users from the db
func (db *GormDB) DeleteFriend(user, friend *model.User, chat *model.Chat) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Model(user).Association("Friends").Delete(friend); err != nil {
			return err
		}
		if err := tx.Model(friend).Association("Friends").Delete(user); err != nil {
			return err
		}
		if err := tx.Unscoped().Delete(chat).Error; err != nil {
			return err
		}
		return nil
	}); err != nil {
		log.Println("Failed to delete user friend with ids -> ", user.ID, friend.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to delete friend."}
	}
	return nil
}

// UpdateSkills -> Updates the skills of a user in the db by replacing it with the specified skills
func (db *GormDB) UpdateSkills(user *model.User, skills []*model.Skill) error {
	if err := db.DB.Model(user).Association("Skills").Replace(skills); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to update skills."}
	}
	return nil
}

// DeleteSkills -> Deletes the specified skills from the user skills in the db
func (db *GormDB) DeleteSkills(user *model.User, skills []*model.Skill) error {
	if err := db.DB.Model(user).Association("Skills").Delete(skills); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to delete skills."}
	}
	return nil
}

// DeleteUser -> Deletes a user from the db
func (db *GormDB) DeleteUser(user *model.User) error {
	if err := db.DB.Delete(user).Error; err != nil {
		log.Println("Failed to delete user with id -> ", user.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to delete user."}
	}
	return nil
}

// AddProject -> Adds a project to the db
func (db *GormDB) AddProject(project *model.Project) error {
	if err := db.DB.Create(project).Error; err != nil {
		log.Println("Failed to create project err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to create project."}
	}
	return nil
}

// FindProjects -> Retrieves a list of projects in the db with the tags preloaded
func (db *GormDB) FindProjects(projects *[]model.Project, ids []string) error {
	if err := db.DB.Preload("Tags").Where("id IN ?", ids).Find(projects).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to retrieve projects"}
	}
	return nil
}

// FetchUserProjects -> Retrieves the projects with the tags preloaded for a user in the db
func (db *GormDB) FetchUserProjects(user *model.User, uid string) error {
	if err := db.DB.Preload("Projects.Tags").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch user projects."}
		}
	}
	return nil
}

// FetchProject -> Retrieves a project from the db
func (db *GormDB) FetchProject(project *model.Project, pid string) error {
	if err := db.DB.Where("id = ?", pid).First(project).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project."}
		}
	}
	return nil
}

// FetchProjectPreloadT -> Retrieves a project with the tags preloaded from the db
func (db *GormDB) FetchProjectPreloadT(project *model.Project, pid string) error {
	if err := db.DB.Preload("Tags").Where("id = ?", pid).First(project).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project."}
		}
	}
	return nil
}

// FetchProjectPreloadTU -> Retrieves a project with the tags and the owner (user) preloaded from the db
func (db *GormDB) FetchProjectPreloadTU(project *model.Project, pid string) error {
	if err := db.DB.Preload("Tags").Preload("User").Where("id = ?", pid).First(project).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project."}
		}
	}
	return nil
}

// FetchProjectPreloadA -> Retrieves a project with the applications for the project preloaded from the db
func (db *GormDB) FetchProjectPreloadA(project *model.Project, pid string) error {
	if err := db.DB.Preload("Applications.FromUser").Where("id = ?", pid).First(project).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project."}
		}
	}
	return nil
}

// FetchProjectPreloadC -> Retrieves a project with the chat for the project preloaded from the db
func (db *GormDB) FetchProjectPreloadC(project *model.Project, pid string) error {
	if err := db.DB.Preload("Chat").Where("id = ?", pid).First(project).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project."}
		}
	}
	return nil
}

// EditProject -> Edits a project and saves the project in the db
func (db *GormDB) EditProject(project *model.Project, skills []*model.Skill) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Model(project).Association("Tags").Replace(skills); err != nil {
			return err
		}
		if err := tx.Save(project).Error; err != nil {
			return err
		}
		return nil
	}); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to edit project."}
	}
	return nil
}

// SaveProject -> Saves a project in the db
func (db *GormDB) SaveProject(project *model.Project) error {
	if err := db.DB.Save(project).Error; err != nil {
		log.Println("Failed to save project with id -> ", project.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to save project."}
	}
	return nil
}

// BookmarkProject -> Adds a project to a user's project bookmark in the db
func (db *GormDB) BookmarkProject(user *model.User, project *model.Project) error {
	if err := db.DB.Model(user).Association("SavedProjects").Append(project); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to bookmark project."}
	}
	return nil
}

// FetchUserPreloadB -> Retrieves a user from the db and preloads the user's project bookmark
func (db *GormDB) FetchUserPreloadB(user *model.User, uid string) error {
	if err := db.DB.Preload("SavedProjects").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch user bookmarks."}
		}
	}
	return nil
}

// FetchProjectPreloadU -> Retrieves a project from the db and preloads the owner of the project
func (db *GormDB) FetchProjectPreloadU(project *model.Project, pid string) error {
	if err := db.DB.Preload("User").Where("id = ?", pid).First(project).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project."}
		}
	}
	return nil
}

// SearchProjectsBySKills -> Searches for projects in the db by using the specified skills
func (db *GormDB) SearchProjectsBySKills(projects *[]model.Project, skills []string, uid string) error {
	subquery := db.DB.Select("project_id").
		Table("project_skills").
		Joins("JOIN skills s ON project_skills.skill_id = s.id").
		Where("s.name IN ?", skills)

	if err := db.DB.Preload("Tags").Where("id IN (?)", subquery).Where("user_id != ?", uid).Find(&projects).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to search project by skills."}
	}
	return nil
}

// RemoveBookmarkedProject -> Removes a project from a user's project bookmark in the db
func (db *GormDB) RemoveBookmarkedProject(user *model.User, project *model.Project) error {
	if err := db.DB.Model(user).Association("SavedProjects").Delete(project); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to remove project from bookmark."}
	}
	return nil
}

// AddProjectApplicationReq -> Add a project application to the db
func (db *GormDB) AddProjectApplicationReq(req *model.ProjectReq) error {
	if err := db.DB.Save(req).Error; err != nil {
		log.Println("Failed to save project application req with id -> ", req.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to send project application request."}
	}
	return nil
}

// ViewProjectApplications -> Retrieves all sent and received project's application of a user in the db
func (db *GormDB) ViewProjectApplications(user *model.User, uid string) error {
	if err := db.DB.Preload("RecProjectReq.FromUser").Preload("SentProjectReq.ToUser").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "User not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch user project applications."}
		}
	}
	return nil
}

// FetchProjectApplication -> Retrieves a project application with the applicant, owner and chat preloaded
func (db *GormDB) FetchProjectApplication(req *model.ProjectReq, rid string) error {
	if err := db.DB.Preload("FromUser").Preload("ToUser").Preload("Project.Chat").Where("id = ?", rid).First(req).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project request not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project request."}
		}
	}
	return nil
}

// UpdateProjectAppliationReject -> Updates the status of the project application to reject in the db
func (db *GormDB) UpdateProjectAppliationReject(req *model.ProjectReq) error {
	if err := db.DB.Delete(req).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to update project application status."}
	}
	return nil
}

// UpdateProjectApplicationAccept -> Updates the status of the project application
// and adds the applicant to the project's chat in the db
func (db *GormDB) UpdateProjectApplicationAccept(req *model.ProjectReq, user *model.User, chat *model.Chat) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Unscoped().Delete(req).Error; err != nil {
			return err
		}

		if err := tx.Model(user).Association("Chats").Append(chat); err != nil {
			return err
		}

		return nil
	}); err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to update project application status."}
	}
	return nil
}

// UpdateProjectApplicationAcceptF -> Updates the status of the project application
// and adds owner and applicant to the project's chat(new chat) in the db
func (db *GormDB) UpdateProjectApplicationAcceptF(req *model.ProjectReq, user1, user2 *model.User, project *model.Project, chat *model.Chat) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Unscoped().Delete(req).Error; err != nil {
			return err
		}

		if err := tx.Create(chat).Error; err != nil {
			return err
		}

		if err := tx.Model(project).Update("ChatID", &chat.ID).Error; err != nil {
			return err
		}

		if err := tx.Model(user1).Association("Chats").Append(chat); err != nil {
			return err
		}

		if err := tx.Model(user2).Association("Chats").Append(chat); err != nil {
			return err
		}
		return nil
	}); err != nil {
		log.Println(err)
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to update project application status."}
	}
	return nil
}

// FetchProjectAppPreloadFU -> Retrieves a project application with the applicant preloaded from the db
func (db *GormDB) FetchProjectAppPreloadFU(req *model.ProjectReq, rid string) error {
	if err := db.DB.Preload("FromUser").Where("id = ?", rid).First(req).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{Code: http.StatusNotFound, Message: "Project application request not found."}
		} else {
			return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to fetch project application request."}
		}
	}
	return nil
}

// DeleteProjectApplicationReq -> Deletes a project application from the db
func (db *GormDB) DeleteProjectApplicationReq(req *model.ProjectReq) error {
	if err := db.DB.Unscoped().Delete(req).Error; err != nil {
		log.Println("Failed to delete project application req with id -> ", req.ID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to delete project application request."}
	}
	return nil
}

// ClearProjectApplication -> Clears all applications on a project from the db
func (db *GormDB) ClearProjectApplication(req []*model.ProjectReq) error {
	if err := db.DB.Unscoped().Delete(req).Error; err != nil {
		log.Println("Failed to clear project applications for project with id -> ", req[0].ProjectID, "err -> ", err.Error())
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to clear project applications."}
	}
	return nil
}

// DeleteProject -> Deletes a project from the db
func (db *GormDB) DeleteProject(project *model.Project) error {
	if err := db.DB.Delete(project).Error; err != nil {
		log.Println("Failed to delete project with id -> ", project.ID, "err -> ", err.Error())

		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to delete project."}
	}
	return nil
}

// AddSkills -> Adds a set of skills to the db
func (db *GormDB) AddSkills(skills *[]*model.Skill) error {
	if err := db.DB.Create(skills).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to create new skills."}
	}
	return nil
}

// FindExistingSkills -> Retrieves existing skills in a skill set from the db
func (db *GormDB) FindExistingSkills(skills *[]*model.Skill, skill []string) error {
	if err := db.DB.Where("name IN ?", skill).Find(skills).Error; err != nil {
		return &CustomMessage{Code: http.StatusInternalServerError, Message: "Failed to find skills."}
	}
	return nil
}

// FindExistingGitID -> Searches for a user using a gitid
func (db *GormDB) FindExistingGitID(user *model.User, gitid int64) error {
	if err := db.DB.Where("gitid = ?", gitid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "User with gitid not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to check for user by gitid."}
		}
	}
	return nil
}

// CheckExistingEmail -> Searches for a user using the email address in the db
func (db *GormDB) CheckExistingEmail(email string) error {
	var count int64
	if err := db.DB.Model(&model.User{}).Where("email = ?", email).Count(&count).Error; err != nil {
		return &CustomMessage{http.StatusInternalServerError, "Failed to check for user by email."}
	}
	if count > 0 {
		return &CustomMessage{http.StatusConflict, "Email already in use!"}
	}
	return nil
}

// CheckExistingUsername -> Searches for an existing user with the username in the db
func (db *GormDB) CheckExistingUsername(username string) error {
	var count int64
	if err := db.DB.Model(&model.User{}).Where("username = ?", username).Count(&count).Error; err != nil {
		return &CustomMessage{http.StatusInternalServerError, "Failed to check for user by email."}
	}
	if count > 0 {
		return &CustomMessage{http.StatusConflict, "Username already in use!"}
	}
	return nil
}

// AddMessage -> Adds a message to the db
func (db *GormDB) AddMessage(msg *model.UserMessage) error {
	if err := db.DB.Create(msg).Error; err != nil {
		log.Println("Failed to create msg err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to send message."}
	}
	return nil
}

// GetChatHistory -> Retrieves the chat history for a chat from the db
func (db *GormDB) GetChatHistory(chatID string, chat *model.Chat) error {
	if err := db.DB.Preload("Messages").Preload("Users").Where("id = ?", chatID).First(chat).Error; err != nil {
		log.Println(chatID, err)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "Chat not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to get chat history."}
		}
	}
	return nil
}

// FetchChat -> Retrieves a chat from the db
func (db *GormDB) FetchChat(chatID string, chat *model.Chat) error {
	if err := db.DB.Where("id = ?", chatID).First(chat).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "Chat not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to get chat."}
		}
	}
	return nil
}

// FetchUserPreloadCM -> Retrieves a user with the user's chat, chat's messages and members preloaded
func (db *GormDB) FetchUserPreloadCM(user *model.User, uid string) error {
	if err := db.DB.Preload("Chats.Messages").Preload("Chats.Users").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "User not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to fetch user chats."}
		}
	}
	return nil
}

// FetchUserPreloadC -> Retrieves a user with the user's chat and chat members preloaded
func (db *GormDB) FetchUserPreloadC(user *model.User, uid string) error {
	if err := db.DB.Preload("Chats.Users").Where("id = ?", uid).First(user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "User not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to fetch user chats."}
		}
	}
	return nil
}

// FetchMsg -> Retrieves a message from the db
func (db *GormDB) FetchMsg(msg *model.UserMessage, mid string) error {
	if err := db.DB.Where("id = ?", mid).First(msg).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "Msg not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to fetch msg."}
		}
	}
	return nil
}

// SaveMsg -> Saves a message in the db
func (db *GormDB) SaveMsg(msg *model.UserMessage) error {
	if err := db.DB.Save(msg).Error; err != nil {
		log.Println("Failed to save msg with id -> ", msg.ID, "err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to edit msg."}
	}
	return nil
}

// SaveChat -> Saves a chat in the db
func (db *GormDB) SaveChat(chat *model.Chat) error {
	if err := db.DB.Save(chat).Error; err != nil {
		log.Printf("Failed to save chat with id -> %v, err -> %v", chat.ID, err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to edit chat."}
	}
	return nil
}

// DeleteMsg -> Deletes a message in the db
func (db *GormDB) DeleteMsg(msg *model.UserMessage) error {
	if err := db.DB.Delete(msg).Error; err != nil {
		log.Println("Failed to delete msg with id -> ", msg.ID, "err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to delete msg."}
	}
	return nil
}

// FindChat -> Finds an existing chat between two users with the messages preloaded
func (db *GormDB) FindChat(uid, fid string, chat *model.Chat) error {
	if err := db.DB.
		Preload("Messages").
		Preload("Users").
		Joins("JOIN chat_users cu1 ON cu1.chat_id = chats.id AND cu1.user_id = ?", uid).
		Joins("JOIN chat_users cu2 ON cu2.chat_id = chats.id AND cu2.user_id = ?", fid).
		Where("\"group\" = ?", false).
		First(chat).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "Chat for friend not found."}
		} else {
			log.Println(err.Error())
			return &CustomMessage{http.StatusInternalServerError, "Failed to fetch chat for friend."}
		}
	}
	return nil
}

// AddUserChat -> Adds a user to a chat group in the db
func (db *GormDB) AddUserChat(chat *model.Chat, user *model.User) error {
	if err := db.DB.Model(chat).Association("Users").Append(user); err != nil {
		log.Printf("Unable to add user with id -> %v to chat with id -> %v, Error: %v", user.ID, chat.ID, err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to add user to chat."}
	}
	return nil
}

// RemoveUserChat -> Removes a user from a chat group in the db
func (db *GormDB) RemoveUserChat(chat *model.Chat, user *model.User) error {
	if err := db.DB.Model(chat).Association("Users").Delete(user); err != nil {
		log.Printf("Unable to remove user with id -> %v from chat with id -> %v, Error: %v", user.ID, chat.ID, err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to remove user from chat."}
	}
	return nil
}

// LeaveChat -> Leave a chat group
func (db *GormDB) LeaveChat(chat *model.Chat, user *model.User) error {
	if err := db.DB.Model(chat).Association("Users").Delete(user); err != nil {
		log.Println("Failed to remove user from chat with ID -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to leave chat."}
	}
	return nil
}

// DeleteChat -> Delete a chat group in the db
func (db *GormDB) DeleteChat(chat *model.Chat) error {
	if err := db.DB.Delete(chat).Error; err != nil {
		log.Printf("Unable to delete a group chat with id -> %v , err -> %v ", chat.ID, err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to delete chat."}
	}
	return nil
}

func (db *GormDB) AddTransaction(transc *model.Transactions) error {
	if err := db.DB.Create(transc).Error; err != nil {
		log.Println("An error occured while trying to create a transaction -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to initiate transaction"}
	}
	return nil
}

func (db *GormDB) FetchTransaction(paystackRef string, transc *model.Transactions) error {
	if err := db.DB.Where("paystackref = ?", paystackRef).First(transc).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "Transaction not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to fetch transaction"}
		}
	}
	return nil
}

func (db *GormDB) AddSubscription(sub *model.Subscriptions) error {
	if err := db.DB.Create(sub).Error; err != nil {
		return &CustomMessage{http.StatusInternalServerError, "Failed to create subscription"}
	}
	return nil
}

func (db *GormDB) AddTranscSub(transc *model.Transactions, sub *model.Subscriptions, user *model.User) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(transc).Error; err != nil {
			return err
		}

		sub.TransactionID = transc.ID
		if err := tx.Create(sub).Error; err != nil {
			return err
		}

		if err := tx.Save(user).Error; err != nil {
			return err
		}

		return nil
	}); err != nil {
		log.Println("[DB TRANSACTION] An error occured, err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to finish transaction and create subscription"}
	}
	return nil
}

func (db *GormDB) AddTranscSaveSub(transc *model.Transactions, sub *model.Subscriptions, user *model.User) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(transc).Error; err != nil {
			return err
		}

		sub.TransactionID = transc.ID
		if err := tx.Save(sub).Error; err != nil {
			return err
		}

		if err := tx.Save(user).Error; err != nil {
			return err
		}

		return nil
	}); err != nil {
		log.Println("[DB TRANSACTION] An error occured, err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to finish transaction and create subscription"}
	}
	return nil
}

func (db *GormDB) AddFailedSub(sub *model.Subscriptions, user *model.User) error {
	if err := db.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(sub).Error; err != nil {
			return err
		}

		if err := tx.Save(user).Error; err != nil {
			return err
		}

		return nil
	}); err != nil {
		log.Println("[DB TRANSACTION] An error occured, err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to create a Failed subscription"}
	}
	return nil
}

func (db *GormDB) FetchTrialEndingUsers(users *[]model.User, limit, today time.Time) error {
	if err := db.DB.Where("freetrial <= ? AND freetrial > ? AND trialreminder = ?", limit, today, false).Find(users).Error; err != nil {
		log.Println("[DB] Failed to retrieve users with ending trial, err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to retrieve users with ending trial"}
	}

	return nil
}

func (db *GormDB) UpdateSentReminder(ids []string) error {
	if err := db.DB.Model(&model.User{}).Where("id IN ?", ids).Update("trialreminder", true).Error; err != nil {
		log.Println("[DB] Failed to update users trialreminder field, err -> ", err.Error())
		return &CustomMessage{http.StatusInternalServerError, "Failed to update users trialreminder field"}
	}

	return nil
}

func (db *GormDB) FetchSub(sub *model.Subscriptions, sid string) error {
	if err := db.DB.Where("id = ?", sid).First(sub).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return &CustomMessage{http.StatusNotFound, "Subscription not found."}
		} else {
			return &CustomMessage{http.StatusInternalServerError, "Failed to retrieve subscription."}
		}
	}
	return nil
}
```

## File: model/user.go
```go
package model

import (
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"gorm.io/gorm"
)

type User struct {
	GormModel
	FullName     string `gorm:"column:fullname;not null"`
	UserName     string `gorm:"column:username;unique;not null;index"`
	Email        string `gorm:"unique;not null"`
	Country      string
	GitUserName  *string `gorm:"column:gitusername;uniqueIndex"`
	GitID        *int64  `gorm:"column:gitid;uniqueIndex"`
	Password     string
	Bio          string
	Interests    pq.StringArray `gorm:"type:text[]"`
	GitUser      bool           `gorm:"column:gituser"`
	Availability bool

	// Sub Details
	FreeTrial       time.Time `gorm:"column:freetrial"`
	TrialReminder   bool      `gorm:"column:trialreminder"`
	NextPaymentDate *time.Time
	LastSub         *time.Time

	// Paystack Details
	PaystackSubCode    *string
	PaystackEmailToken *string
	PaystackCusCode    *string
	PaystackAuthCode   *string

	// Card Details
	Last4    *string
	CardType *string
	ExpMonth *string
	ExpYear  *string

	// Relations:
	Skills         []*Skill         `gorm:"many2many:user_skills"`
	Projects       []*Project       `gorm:"foreignKey:UserID"`
	SavedProjects  []*Project       `gorm:"many2many:user_saved_projects"`
	Friends        []*User          `gorm:"many2many:user_friends"`
	FriendReq      []*FriendReq     `gorm:"foreignKey:UserID"`
	RecFriendReq   []*FriendReq     `gorm:"foreignKey:FriendID"`
	Chats          []*Chat          `gorm:"many2many:chat_users"`
	SentProjectReq []*ProjectReq    `gorm:"foreignKey:FromID"`
	RecProjectReq  []*ProjectReq    `gorm:"foreignKey:ToID"`
	Subscriptions  []*Subscriptions `gorm:"foreignKey:UserID"`
	Transactions   []*Transactions  `gorm:"foreignKey:UserID"`
}

type UserFriend struct {
	UserID   string `gorm:"primaryKey"`
	FriendID string `gorm:"primaryKey"`

	// Relations:
	User   *User `gorm:"foreignKey:UserID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Friend *User `gorm:"foreignKey:FriendID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type UserSkill struct {
	UserID  string `gorm:"primaryKey"`
	SkillID string `gorm:"primaryKey"`

	// Relations:
	User *User `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type UserSavedProject struct {
	UserID    string `gorm:"primaryKey"`
	ProjectID string `gorm:"primaryKey"`

	// Relations:
	User    *User    `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
	Project *Project `gorm:"constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

type FriendReq struct {
	GormModel
	UserFriend
	Status  string `gorm:"not null;default:'pending'"`
	Message string `gorm:"default:'Hey let's be friends'"`
}

const (
	StatusAccepted  = "accepted"
	StatusRejected  = "rejected"
	StatusAttention = "attention"
	StatusPending   = "pending"
	StatusActive    = "active"
	StatusFailed    = "failed"
	StatusSuccess   = "success"
	StatusExpired   = "expired"
	StatusLogin     = "login"
)

func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
	if u.ID == "" {
		u.ID = uuid.NewString()
	}
	return err
}

func (f *FriendReq) BeforeCreate(tx *gorm.DB) (err error) {
	if f.ID == "" {
		f.ID = uuid.NewString()
	}

	return err
}

func (u *User) BeforeDelete(tx *gorm.DB) (err error) {
	if err := tx.Model(&Project{}).Where("user_id = ?", u.ID).Delete(&Project{}).Error; err != nil {
		return err
	}
	return nil
}

func IsValidUUID(id string) bool {
	_, err := uuid.Parse(id)
	return err == nil
}

type GormModel struct {
	ID        string `gorm:"type:char(36);primaryKey"`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt gorm.DeletedAt `gorm:"index"`
}
```

## File: test/unit/user_test.go
```go
package unit

import (
	"bytes"
	"encoding/json"
	"log"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"findme/handlers"

	"github.com/stretchr/testify/assert"
)

var (
	tokenString    = ""
	tokenString1   = ""
	resetToken     = ""
	superUserName  = "Imisioluwa23"
	superUserName1 = "knightmares23"
	userToken      = ""
	defPayload     = map[string]string{
		"username":    "JohnDoe23",
		"fullname":    "John Doe",
		"email":       "johndoe@gmail.com",
		"password":    "JohnDoe234",
		"gitusername": "johndoe23",
		"country":     "NGN",
	}
	token     Token
	friendreq ViewFriendReq
	chat      GetChatID
)

func TestSignup(t *testing.T) {
	payload := defPayload

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/signup", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)
}

func TestSignupDuplicate(t *testing.T) {
	payload := defPayload

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/signup", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusConflict, w.Code)
}

// Git Mock Test
func TestGitSignup(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/github-signup", nil)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	log.Println(w.Code, w.Body.String())
	assert.Equal(t, http.StatusOK, w.Code)
}

func TestGitConnect(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPost, "/api/user/connect-github", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	log.Println(w.Code, w.Body.String())
	assert.Equal(t, http.StatusOK, w.Code)
}

func TestGitViewRepo(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view-repo", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "imisi99/FindMe")
}

func TestLogin(t *testing.T) {
	payload := map[string]string{
		"username": "JohnDoe23",
		"password": "JohnDoe234",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/login", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	_ = json.Unmarshal(w.Body.Bytes(), &token)
	tokenString = token.Token
}

func TestLoginInvalid(t *testing.T) {
	payload := map[string]string{
		"username": "JohnDoe",
		"password": "JohnDoe234",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/login", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNotFound, w.Code)
	assert.Contains(t, w.Body.String(), "Invalid Credentials!")
}

func TestGetUserProfile(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/profile", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "johndoe@gmail.com")
}

func TestGetUserPaymentInfo(t *testing.T) {
	newToken, _ := handlers.GenerateJWT(id2, "login", true, 2*time.Minute)
	req, _ := http.NewRequest(http.MethodGet, "/api/user/payment-info", nil)
	req.Header.Set("Authorization", "Bearer "+newToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestRecommendProjects(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/recommend", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestViewGitUser(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view-git?id=imisi99", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	assert.Contains(t, w.Body.String(), defProjectDescription)
}

func TestSearchUserbySkills(t *testing.T) {
	skills := map[string][]string{
		"skills": {"go", "backend"},
	}
	body, _ := json.Marshal(skills)

	req, _ := http.NewRequest(http.MethodPost, "/api/user/search", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	assert.Contains(t, w.Body.String(), superUserName1)
}

func TestViewUser(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view?id="+superUserName, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	assert.Contains(t, w.Body.String(), defProjectDescription)
}

func TestGetUser(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/get-user?id="+id1, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	assert.Contains(t, w.Body.String(), defProjectDescription)
}

func TestSendFriendReq(t *testing.T) {
	payload := map[string]string{
		"msg": "Yo what's up ?",
		"uid": id1,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/user/send-user-req", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	_ = json.Unmarshal(w.Body.Bytes(), &friendreq)
}

func TestSendDuplicateFriendReq(t *testing.T) {
	payload := map[string]string{
		"msg": "Yo what's up ?",
		"uid": id2,
	}

	body, _ := json.Marshal(payload)
	userToken, _ = handlers.GenerateJWT(id1, "login", true, 5*time.Minute) // Super created user from the test above to test the accepting of friend request sent

	req, _ := http.NewRequest(http.MethodPost, "/api/user/send-user-req", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+userToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusConflict, w.Code)
	assert.Contains(t, w.Body.String(), "An existing request exists.")
}

func TestViewFriendReq(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view-user-req", nil)
	req.Header.Set("Authorization", "Bearer "+userToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName1)
}

func TestUpdateFriendReqInvalidStatus(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-user-req?id="+friendreq.ID+"&status=invalid", nil)
	req.Header.Set("Authorization", "Bearer "+userToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusBadRequest, w.Code)
	assert.Contains(t, w.Body.String(), "Invalid status")
}

func TestUpdateFriendReqReject(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-user-req?id="+friendreq.ID+"&status=rejected", nil)
	req.Header.Set("Authorization", "Bearer "+userToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Status updated successfully.")
}

func TestSendFriendReqToAccept(t *testing.T) {
	payload := map[string]string{
		"msg": "Yo what's up ?",
		"uid": id1,
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/user/send-user-req", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	_ = json.Unmarshal(w.Body.Bytes(), &friendreq)
}

func TestUpdateFriendReqAccept(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-user-req?id="+friendreq.ID+"&status=accepted", nil)
	req.Header.Set("Authorization", "Bearer "+userToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Status updated successfully.")
	_ = json.Unmarshal(w.Body.Bytes(), &chat)
}

func TestViewUserFriends(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view-friend", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
}

func TestViewUserFriendsByID(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view-user-friend?id="+id1, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName1)
}

func TestDeleteFriend(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/user/delete-user-friend?id="+id1+"&chat_id="+chat.ChatID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString1)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestAddReqToTestDelete(t *testing.T) {
	payload := map[string]string{
		"msg": "Testing the delete",
		"uid": id1,
	}
	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/api/user/send-user-req", bytes.NewBuffer(body))
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), superUserName)
	_ = json.Unmarshal(w.Body.Bytes(), &friendreq)
}

func TestDeleteReq(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/user/delete-friend-req?id="+friendreq.ID, nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestForgotPassword(t *testing.T) {
	payload := map[string]string{
		"email": "johndoe@gmail.com",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPost, "/forgot-password", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	assert.Contains(t, w.Body.String(), "Check email for otp.")
}

func TestVerifyOPT(t *testing.T) {
	// Using the default otp 123456 that is set in the mock
	otp := "123456"

	req, _ := http.NewRequest(http.MethodGet, "/verify-otp?id="+otp, nil)
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	_ = json.Unmarshal(w.Body.Bytes(), &token)
	resetToken = token.Token
}

func TestResetPassword(t *testing.T) {
	payload := map[string]string{
		"password": "johndoe66.",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/user/reset-password", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+resetToken)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "password reset successfully")
}

func TestUpdateuserProfile(t *testing.T) {
	payload := defPayload
	payload["fullname"] = "Knightmares"

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPut, "/api/user/update-profile", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), payload["bio"])
}

func TestUpdateuserProfileDuplicate(t *testing.T) {
	payload := map[string]string{
		"username": "Imisioluwa23",
		"fullname": "John Doe",
		"email":    "JohnDoe@gmail.com",
		"country":  "UK",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPut, "/api/user/update-profile", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusConflict, w.Code)
	assert.Contains(t, w.Body.String(), "Username already in use!")
}

func TestUpdateuserBio(t *testing.T) {
	payload := map[string]string{"bio": "I'm building stuff"}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-bio", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestUpdateuserinterest(t *testing.T) {
	payload := map[string][]string{"interest": {"ai, anime"}}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-interest", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
}

func TestUpdateuserPassword(t *testing.T) {
	payload := map[string]string{
		"password":     "johndoe66.",
		"new_password": "Johndoe12.",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-password", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Password updated successfully.")
}

func TestUpdateuserPasswordFail(t *testing.T) {
	payload := map[string]string{
		"password":     "wrongPassword",
		"new_password": "Johndoe12.",
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-password", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusUnauthorized, w.Code)
	assert.Contains(t, w.Body.String(), "Invalid Password.")
}

func TestUpdateAvailabilityStatus(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-availability/false", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "Availability updated successfully.")
}

func TestFailedUpdateAvailibilityStatus(t *testing.T) {
	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-availability/nothing", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusUnprocessableEntity, w.Code)
	assert.Contains(t, w.Body.String(), "Availability status can only be true or false.")
}

func TestUpdateSkills(t *testing.T) {
	payload := map[string][]string{
		"skills": {"rust", "java"},
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodPatch, "/api/user/update-skills", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusAccepted, w.Code)
	assert.Contains(t, w.Body.String(), "rust")
	assert.Contains(t, w.Body.String(), "java")
}

func TestDeleteSkills(t *testing.T) {
	payload := map[string][]string{
		"skills": {"rust"},
	}

	body, _ := json.Marshal(payload)

	req, _ := http.NewRequest(http.MethodDelete, "/api/user/delete-skills", bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}

func TestViewSubscriptions(t *testing.T) {
	req, _ := http.NewRequest(http.MethodGet, "/api/user/view-subs", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestDeleteUser(t *testing.T) {
	req, _ := http.NewRequest(http.MethodDelete, "/api/user/delete-user", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)

	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusNoContent, w.Code)
}
```

## File: handlers/post.go
```go
package handlers

import (
	"log"
	"net/http"
	"strconv"
	"strings"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

// GetProjects godoc
// @Summary    Retreive all current user projects
// @Description An endpoint for retreiving all current user projects
// @Tags  Project
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocAllProjectResponse "Fetched all projects"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/posts/all [get]
func (s *Service) GetProjects(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserProjects(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var reuslt []schema.ProjectResponse
	for _, project := range user.Projects {
		var tags []string
		for _, tag := range project.Tags {
			tags = append(tags, tag.Name)
		}
		reuslt = append(reuslt, schema.ProjectResponse{
			ID:          project.ID,
			Title:       project.Title,
			Description: project.Description,
			Tags:        tags,
			CreatedAt:   project.CreatedAt,
			UpdatedAt:   project.UpdatedAt,
			Views:       project.Views,
			Available:   project.Availability,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"project": reuslt})
}

// ViewProject godoc
// @Summary     View a single project with ID
// @Description An endpoint for viewing a single project in details by using the project ID
// @Tags   Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocDetailedProjectResponse "Fetched project"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/view [get]
func (s *Service) ViewProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProjectPreloadTU(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var tags []string
	for _, tag := range project.Tags {
		tags = append(tags, tag.Name)
	}
	result := schema.DetailedProjectResponse{
		ProjectResponse: schema.ProjectResponse{
			ID:          project.ID,
			Title:       project.Title,
			Description: project.Description,
			Tags:        tags,
			CreatedAt:   project.CreatedAt,
			UpdatedAt:   project.UpdatedAt,
			Views:       project.Views,
			Available:   project.Availability,
		},
		Username:   project.User.UserName,
		GitProject: project.GitProject,
		GitLink:    project.GitLink,
	}

	ctx.JSON(http.StatusOK, gin.H{"project": result})
}

// ViewSingleProjectApplication godoc
// @Summary   View all applications on a project
// @Description An endpoint for viewing all the applications on a single project
// @Tags   Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocViewProjectApplications "Project applications"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/view-application [get]
func (s *Service) ViewSingleProjectApplication(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	id := ctx.Query("id")
	if !model.IsValidUUID(id) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProjectPreloadA(&project, id); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to view the applicants on this project."})
		return
	}

	var applications []schema.ViewProjectApplication
	for _, req := range project.Applications {
		applications = append(applications, schema.ViewProjectApplication{
			ReqID:    req.ID,
			Status:   req.Status,
			Message:  req.Message,
			Username: req.FromUser.UserName,
		})
	}
	result := schema.ApplicationProjectResponse{
		Applications: applications,
	}

	ctx.JSON(http.StatusOK, gin.H{"req": result})
}

// SearchProject godoc
// @Summary   Search for a project with tags/skills
// @Description An endpoint for searching for project with tags associated with the project
// @Tags Project
// @Accept json
// @Produce json
// @Param payload body schema.SearchProjectWithTags true "Tags"
// @Security BearerAuth
// @Success 200 {object} schema.DocAllProjectResponse "Projects"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/tags [post]
func (s *Service) SearchProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.SearchProjectWithTags
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload."})
		return
	}

	for i := range payload.Tags {
		payload.Tags[i] = strings.ToLower(payload.Tags[i])
	}

	var projects []model.Project
	if err := s.DB.SearchProjectsBySKills(&projects, payload.Tags, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var projectResponse []schema.ProjectResponse
	for _, project := range projects {
		var tags []string
		for _, tag := range project.Tags {
			tags = append(tags, tag.Name)
		}
		projectResponse = append(projectResponse, schema.ProjectResponse{
			ID:          project.ID,
			Title:       project.Title,
			Description: project.Description,
			CreatedAt:   project.CreatedAt,
			UpdatedAt:   project.UpdatedAt,
			Available:   project.Availability,
			Views:       project.Views,
			Tags:        tags,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"project": projectResponse})
}

// CreateProject godoc
// @Summary     Create a new project
// @Description  An endpoint for creating a new project for the current user it internally calls a service to create a vector for the project
// @Tags   Project
// @Accept json
// @Produce json
// @Param payload body schema.NewProjectRequest true "Project payload"
// @Security BearerAuth
// @Success 201 {object} schema.DocProjectResponse "Project created"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/create [post]
func (s *Service) CreateProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.NewProjectRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload."})
		return
	}

	for i := range payload.Tags {
		payload.Tags[i] = strings.ToLower(payload.Tags[i])
	}
	allskills, err := s.CheckAndUpdateSkills(payload.Tags)
	if err != nil {
		log.Printf("An error occured while trying to add a new skill to db -> %v", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to create new project."})
		return
	}

	project := model.Project{
		Title:        payload.Title,
		Description:  payload.Description,
		Tags:         allskills,
		UserID:       uid,
		Views:        0,
		Availability: true,
	}

	if payload.Git {
		project.GitProject = true
		project.GitLink = payload.GitLink
	}

	if err := s.DB.AddProject(&project); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	result := schema.ProjectResponse{
		ID:          project.ID,
		Title:       project.Title,
		Description: project.Description,
		Available:   project.Availability,
		Tags:        payload.Tags,
		CreatedAt:   project.CreatedAt,
		UpdatedAt:   project.UpdatedAt,
		Views:       project.Views,
	}

	s.Emb.QueueProjectCreate(project.ID, project.Title, project.Description, uid, payload.Tags)

	ctx.JSON(http.StatusCreated, gin.H{"project": result})
}

// RecommendUsers godoc
// @Summary Recommends users to work on a project
// @Description An endpoint for recommending users for a project using ai
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocRecUsersResponse "Users Retrieved"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 402 {object} schema.DocNormalResponse "Payment Required"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/recommend [get]
func (s *Service) RecommendUsers(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	premium := ctx.GetBool("premium")
	if !premium {
		ctx.JSON(http.StatusPaymentRequired, gin.H{"msg": "You need to pay to use this service."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProject(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	res, err := s.Rec.GetRecommendation(project.ID, core.UserRecommendation)
	if err != nil || res == nil {
		log.Printf("[gRPC Recommendation] Failed to get recommendation for project -> %v, err -> %v", project.ID, err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to retrieve users for the project."})
		return
	}

	var users []model.User

	var ids []string
	for id := range res.Res {
		ids = append(ids, id)
	}

	if err := s.DB.FindUsers(&users, ids); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var profiles []schema.RecProfileResponse

	for _, user := range users {
		score := res.Res[user.ID]
		var skills []string
		for _, skill := range user.Skills {
			skills = append(skills, skill.Name)
		}
		profiles = append(profiles,
			schema.RecProfileResponse{
				User: schema.UserProfileResponse{
					ID:           user.ID,
					UserName:     user.UserName,
					GitUserName:  user.GitUserName,
					Gituser:      user.GitUser,
					Bio:          user.Bio,
					Availability: user.Availability,
					Skills:       skills,
					Interests:    user.Interests,
				},
				Score: score,
			},
		)
	}

	ctx.JSON(http.StatusOK, gin.H{"users": profiles})
}

// EditProject godoc
// @Summary    Editing details of a project
// @Description An endpoint for editing major details of a project it internally calls a service to update the vector for the project
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Param payload body schema.NewProjectRequest true "Project payload"
// @Security BearerAuth
// @Success 202 {object} schema.DocProjectResponse "Project Edited"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/edit [put]
func (s *Service) EditProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var payload schema.NewProjectRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProjectPreloadT(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You aren't authorized to edit this project."})
		return
	}

	for i := range payload.Tags {
		payload.Tags[i] = strings.ToLower(payload.Tags[i])
	}

	allskills, err := s.CheckAndUpdateSkills(payload.Tags)
	if err != nil {
		log.Printf("An error occured while trying to add a new skill to db %v", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to update project."})
		return
	}

	project.Title = payload.Title
	project.Description = payload.Description

	if payload.Git {
		project.GitProject = true
		project.GitLink = payload.GitLink
	}

	if err := s.DB.EditProject(&project, allskills); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	result := schema.ProjectResponse{
		ID:          project.ID,
		Title:       project.Title,
		Description: project.Description,
		Available:   project.Availability,
		Tags:        payload.Tags,
		CreatedAt:   project.CreatedAt,
		UpdatedAt:   project.UpdatedAt,
		Views:       project.Views,
	}

	s.Emb.QueueProjectUpdate(project.ID, project.Title, project.Description, payload.Tags)

	ctx.JSON(http.StatusAccepted, gin.H{"project": result})
}

// EditProjectView godoc
// @Summary    Editing the number of views on a project
// @Description An endpoint for editing the number of views on a project
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 202 {object} schema.DocProjectResponse "Project view edited"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/edit-view [patch]
func (s *Service) EditProjectView(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	id := ctx.Query("id")
	if !model.IsValidUUID(id) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProjectPreloadT(&project, id); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID != uid {
		project.Views++
		if err := s.DB.SaveProject(&project); err != nil {
			cm := err.(*core.CustomMessage)
			ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}
	}

	var tags []string
	for _, tag := range project.Tags {
		tags = append(tags, tag.Name)
	}
	result := schema.ProjectResponse{
		ID:          project.ID,
		Title:       project.Title,
		Description: project.Description,
		Available:   project.Availability,
		Tags:        tags,
		CreatedAt:   project.CreatedAt,
		UpdatedAt:   project.UpdatedAt,
		Views:       project.Views,
	}

	ctx.JSON(http.StatusAccepted, gin.H{"project": result})
}

// EditProjectAvailability godoc
// @Summary     Editing the availability of a project
// @Description An endpoint for editing the availability status of a project it internally calls a service to update the vector for the project
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Param staus query string true "Status"
// @Security BearerAuth
// @Success 202 {object} schema.DocProjectResponse "Project edited"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/edit-status [patch]
func (s *Service) EditProjectAvailability(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid, status := ctx.Query("id"), ctx.Query("status")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	stat, err := strconv.ParseBool(status)
	if err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Invalid status"})
		return
	}

	var project model.Project
	if err := s.DB.FetchProject(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You aren't authorized to edit this project."})
		return
	}

	project.Availability = stat
	if err := s.DB.SaveProject(&project); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var tags []string
	for _, tag := range project.Tags {
		tags = append(tags, tag.Name)
	}
	result := schema.ProjectResponse{
		ID:          project.ID,
		Title:       project.Title,
		Description: project.Description,
		Tags:        tags,
		Views:       project.Views,
		CreatedAt:   project.CreatedAt,
		UpdatedAt:   project.UpdatedAt,
		Available:   project.Availability,
	}

	s.Emb.QueueProjectUpdateStatus(project.ID, project.Availability)

	ctx.JSON(http.StatusAccepted, gin.H{"project": result})
}

// SaveProject godoc
// @Summary     Bookmark a project
// @Description An endpoint for adding a project to the current user bookmarks
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 202 {object} schema.DocProjectResponse "Bookmarked project"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/save-post [put]
func (s *Service) SaveProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"message": "Invalid project id."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var project model.Project
	if err := s.DB.FetchProject(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID == user.ID {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can't save a project created by you."})
		return
	}

	if err := s.DB.BookmarkProject(&user, &project); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var tags []string
	for _, tag := range project.Tags {
		tags = append(tags, tag.Name)
	}

	projectRes := schema.ProjectResponse{
		ID:          project.ID,
		Title:       project.Title,
		Description: project.Description,
		Available:   project.Availability,
		Tags:        tags,
		CreatedAt:   project.CreatedAt,
		UpdatedAt:   project.UpdatedAt,
		Views:       project.Views,
	}
	ctx.JSON(http.StatusAccepted, gin.H{"project": projectRes})
}

// ViewSavedProject godoc
// @Summary    View all current user bookmarked projects
// @Description An endpoint to view all of the bookmarked projects of the current user
// @Tags Project
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocAllProjectResponse "Bookmarked projects"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/view/saved-post [get]
func (s *Service) ViewSavedProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadB(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var savedProjects []schema.ProjectResponse
	for _, project := range user.SavedProjects {
		var tags []string
		for _, tag := range project.Tags {
			tags = append(tags, tag.Name)
		}
		savedProjects = append(savedProjects, schema.ProjectResponse{
			ID:          project.ID,
			Title:       project.Title,
			Description: project.Description,
			Available:   project.Availability,
			Tags:        tags,
			CreatedAt:   project.CreatedAt,
			UpdatedAt:   project.UpdatedAt,
		})
	}
	ctx.JSON(http.StatusOK, gin.H{"project": savedProjects})
}

// RemoveSavedProject godoc
// @Summary    Remove a project from bookmarked
// @Description An endpoint for removing a project from the current user bookmarked
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 204 {object} nil "Project removed"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
func (s *Service) RemoveSavedProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var project model.Project
	if err := s.DB.FetchProject(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.RemoveBookmarkedProject(&user, &project); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// ApplyForProject godoc
// @Summary   Apply for a project to work on
// @Description An endpoint for applying to a project to work on
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Param payload body schema.ProjectApplication true "Application payload"
// @Security BearerAuth
// @Success 200 {object} schema.DocProjectApplication "Applied successfully"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 409 {object} schema.DocNormalResponse "Existing record"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/apply [post]
func (s *Service) ApplyForProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var payload schema.ProjectApplication
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload"})
		return
	}

	var project model.Project
	if err := s.DB.FetchProjectPreloadU(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if !project.Availability {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "The owner of the project is no longer accepting applications."})
		return
	}

	if err, exists := s.DB.CheckExistingAppReq(pid, uid); err != nil || exists {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID == uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can't apply for your own project."})
		return
	}

	req := model.ProjectReq{
		ProjectID: project.ID,
		FromID:    user.ID,
		ToID:      project.User.ID,
	}

	if len(payload.Message) > 0 {
		req.Message = payload.Message
	}

	if err := s.DB.AddProjectApplicationReq(&req); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	application := schema.ViewProjectApplication{
		ReqID:    req.ID,
		Status:   req.Status,
		Message:  req.Message,
		Username: project.User.UserName,
	}

	s.Email.QueueProjectApplication(user.UserName, project.User.UserName, project.Description, "nil", project.User.Email)

	ctx.JSON(http.StatusOK, gin.H{"project_req": application})
}

// ViewProjectApplications godoc
// @Summary    View all project applications sent and received
// @Description An endpoint for viewing all sent and received project applications
// @Tags Project
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewAllProjectApplication "Fetched applications"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/view-applications [get]
func (s *Service) ViewProjectApplications(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.ViewProjectApplications(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var recReq, sentReq []schema.ViewProjectApplication
	for _, rq := range user.SentProjectReq {
		sentReq = append(sentReq, schema.ViewProjectApplication{
			ReqID:    rq.ID,
			Username: rq.ToUser.UserName,
			Message:  rq.Message,
			Status:   rq.Status,
			Sent:     rq.CreatedAt,
		})
	}

	for _, rq := range user.RecProjectReq {
		recReq = append(recReq, schema.ViewProjectApplication{
			ReqID:    rq.ID,
			Username: rq.FromUser.UserName,
			Message:  rq.Message,
			Status:   rq.Status,
			Sent:     rq.CreatedAt,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"project": gin.H{"rec_req": recReq, "sent_req": sentReq}})
}

// UpdateProjectApplication godoc
// @Summary     Updating a project application status
// @Description An endpoint for updating a project application status to accepted or rejected
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Request ID"
// @Param status query string true "Request status"
// @Param payload body schema.RejectApplication true "Payload"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "Status Updated"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/update-application [patch]
func (s *Service) UpdateProjectApplication(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}
	rid, status := ctx.Query("id"), ctx.Query("status")
	if !model.IsValidUUID(rid) || status == "" {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid req id."})
		return
	}

	var payload schema.RejectApplication
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, "Failed to parse the payload.")
		return
	}

	if payload.Reason == "" {
		payload.Reason = "The author of the project didn't add a reason."
	}

	var req model.ProjectReq
	if err := s.DB.FetchProjectApplication(&req, rid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if req.ToID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to update this application."})
		return
	}

	switch status {
	case model.StatusRejected:
		if err := s.DB.UpdateProjectAppliationReject(&req); err != nil {
			cm := err.(*core.CustomMessage)
			ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}

		s.Email.QueueProjectApplicationReject(req.ToUser.UserName, req.FromUser.UserName, req.Project.Description, payload.Reason, req.FromUser.Email)

	case model.StatusAccepted:
		var err error

		if req.Project.ChatID == nil {
			var chat model.Chat
			chat.Group = true
			chat.OwnerID = &uid
			err = s.DB.UpdateProjectApplicationAcceptF(&req, req.ToUser, req.FromUser, req.Project, &chat)
		} else {
			err = s.DB.UpdateProjectApplicationAccept(&req, req.FromUser, req.Project.Chat)
		}

		if err != nil {
			cm := err.(*core.CustomMessage)
			ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}

		s.Email.QueueProjectApplicationAccept(req.ToUser.UserName, req.FromUser.UserName, req.Project.Description, "", req.FromUser.Email)

	default:
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid status."})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Application status updated successfully."})
}

// DeleteProjectApplication godoc
// @Summary    Delete a send project application
// @Description An endpoint for deleting a sent project application for the current user
// @Tags Project
// @Accept json
// @Produce json
// @Param id query string true "Request ID"
// @Security BearerAuth
// @Success 204 {object} nil "Request deleted"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/delete-application [delete]
func (s *Service) DeleteProjectApplication(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	rid := ctx.Query("id")
	if !model.IsValidUUID(rid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid request id."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var req model.ProjectReq
	if err := s.DB.FetchProjectAppPreloadFU(&req, rid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if req.FromUser.ID != user.ID {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to delete this application."})
		return
	}

	if err := s.DB.DeleteProjectApplicationReq(&req); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// ClearProjectApplication godoc
// @Summary     Clear all applications on a project
// @Description An endpoint for clearing all applications on a project
// @Tags  Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Security BearerAuth
// @Success 204 {object} nil "Applications cleared"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/post/clear-application [delete]
func (s *Service) ClearProjectApplication(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProjectPreloadA(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to clear this project applications"})
		return
	}

	if len(project.Applications) == 0 {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "No request to clear!"})
		return
	}

	if err := s.DB.ClearProjectApplication(project.Applications); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// DeleteProject godoc
// @Summary    Delete a project
// @Description An endpoint for deleting the current user project it internally calls a service to delete the vector for the project
// @Tags   Project
// @Accept json
// @Produce json
// @Param id query string true "Project ID"
// @Success 204 {object} nil "Project deleted"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 403 {object} schema.DocNormalResponse "Permission denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
func (s *Service) DeleteProject(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	pid := ctx.Query("id")
	if !model.IsValidUUID(pid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid project id."})
		return
	}

	var project model.Project
	if err := s.DB.FetchProject(&project, pid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if project.UserID != uid {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You don't have permission to delete this project."})
		return
	}

	if err := s.DB.DeleteProject(&project); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Emb.QueueProjectDelete(project.ID)

	ctx.JSON(http.StatusNoContent, nil)
}
```

## File: handlers/handler.go
```go
package handlers

import (
	"net/http"

	"findme/core"

	"github.com/gin-gonic/gin"
)

type Service struct {
	DB     core.DB
	RDB    core.Cache
	Email  core.Email
	Git    Git
	Transc Transc
	Emb    core.Embedding
	Rec    core.Recommendation
	Chat   *core.ChatHub
	Client *http.Client
	Cron   core.CronWorker
}

func NewService(db core.DB, rdb core.Cache, email core.Email, git Git, transc Transc, embHub core.Embedding, recHub core.Recommendation, client *http.Client, chat *core.ChatHub, cron core.CronWorker) *Service {
	return &Service{DB: db, RDB: rdb, Email: email, Git: git, Transc: transc, Emb: embHub, Rec: recHub, Client: client, Chat: chat, Cron: cron}
}

func SetupHandler(router *gin.Engine, service *Service) {
	router.GET("/", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{"message": "APP is up and running"})
	})

	router.GET("/health", func(ctx *gin.Context) {
		ctx.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	router.GET("/health/detailed", service.DetailedHealth)

	router.POST("/signup", service.AddUser)
	router.POST("/login", service.VerifyUser)

	router.GET("/github-signup", service.Git.GitHubAddUser)
	router.GET("/api/v1/auth/github/callback", service.Git.SelectCallback)

	router.POST("/forgot-password", service.ForgotPassword)
	router.GET("/verify-otp", service.VerifyOTP)

	router.POST("/api/transc/webhook", service.Transc.VerifyTranscWebhook)

	protectedUserRoutes := router.Group("/api/user")
	protectedProjectRoutes := router.Group("/api/post")
	protectedMsgRoutes := router.Group("/api/msg")
	protectedTranscRoutes := router.Group("/api/transc")
	protectedUserRoutes.Use(service.Authentication())
	protectedProjectRoutes.Use(service.Authentication())
	protectedMsgRoutes.Use(service.Authentication())
	protectedTranscRoutes.Use(service.Authentication())

	protectedUserRoutes.GET("/profile", service.GetUserInfo)
	protectedUserRoutes.POST("/search", service.ViewUserbySkills)
	protectedUserRoutes.GET("/view", service.ViewUser)
	protectedUserRoutes.GET("/get-user", service.GetUser)
	protectedUserRoutes.GET("/view-git", service.ViewGitUser)
	protectedUserRoutes.GET("/view-user-req", service.ViewFriendReq)
	protectedUserRoutes.GET("/view-friend", service.ViewUserFriends)
	protectedUserRoutes.GET("/view-user-friend", service.ViewUserFriendsByID)
	protectedUserRoutes.GET("/view-repo", service.Git.ViewRepo)
	protectedUserRoutes.GET("/recommend", service.RecommendProjects)
	protectedUserRoutes.GET("/view-subs", service.ViewSubscriptions)
	protectedUserRoutes.GET("/payment-info", service.GetUserPaymentInfo)
	protectedUserRoutes.POST("/send-user-req", service.SendFriendReq)
	protectedUserRoutes.POST("/connect-github", service.Git.ConnectGitHub)
	protectedUserRoutes.PUT("/update-profile", service.UpdateUserInfo)
	protectedUserRoutes.PATCH("/update-user-req", service.UpdateFriendReqStatus)
	protectedUserRoutes.PATCH("/update-password", service.UpdateUserPassword)
	protectedUserRoutes.PATCH("/update-availability/:status", service.UpdateUserAvaibilityStatus)
	protectedUserRoutes.PATCH("/update-bio", service.UpdateUserBio)
	protectedUserRoutes.PATCH("/update-interest", service.UpdateUserInterests)
	protectedUserRoutes.PATCH("/update-skills", service.UpdateUserSkills)
	protectedUserRoutes.PATCH("/reset-password", service.ResetPassword)
	protectedUserRoutes.DELETE("/delete-skills", service.DeleteUserSkills)
	protectedUserRoutes.DELETE("/delete-user", service.DeleteUserAccount)
	protectedUserRoutes.DELETE("/delete-friend-req", service.DeleteSentReq)
	protectedUserRoutes.DELETE("/delete-user-friend", service.DeleteUserFriend)

	protectedTranscRoutes.GET("/view", service.Transc.GetTransactions)
	protectedTranscRoutes.GET("/initialize", service.Transc.InitializeTransaction)
	protectedTranscRoutes.GET("/view/plans", service.Transc.ViewPlans)
	protectedTranscRoutes.GET("/update-card", service.Transc.UpdateSubscriptionCard)
	protectedTranscRoutes.POST("/retry-payment", service.Transc.RetryFailedPayment)
	protectedTranscRoutes.PATCH("/cancel-sub", service.Transc.CancelSubscription)
	protectedTranscRoutes.PATCH("/enable-sub", service.Transc.EnableSubscription)

	protectedMsgRoutes.GET("/ws/chat", service.WSChat)

	protectedMsgRoutes.GET("/view-hist", service.ViewMessages)
	protectedMsgRoutes.GET("/view-chats", service.FetchUserChats)
	protectedMsgRoutes.GET("/open-chat", service.OpenChat)
	protectedMsgRoutes.POST("/send-message", service.CreateMessage)
	protectedMsgRoutes.PUT("/add-user", service.AddUserToChat)
	protectedMsgRoutes.PATCH("/edit-message", service.EditMessage)
	protectedMsgRoutes.PATCH("/rename-chat", service.RenameChat)
	protectedMsgRoutes.PATCH("/transfer-owner", service.TransferOwner)
	protectedMsgRoutes.DELETE("/delete-message", service.DeleteMessage)
	protectedMsgRoutes.DELETE("/remove-user", service.RemoveUserChat)
	protectedMsgRoutes.DELETE("/leave-chat", service.LeaveChat)
	protectedMsgRoutes.DELETE("/delete-chat", service.DeleteChat)

	protectedProjectRoutes.GET("/posts/all", service.GetProjects)
	protectedProjectRoutes.GET("/view", service.ViewProject)
	protectedProjectRoutes.GET("/view-applications", service.ViewProjectApplications)
	protectedProjectRoutes.GET("/view-application", service.ViewSingleProjectApplication)
	protectedProjectRoutes.GET("/view/saved-post", service.ViewSavedProject)
	protectedProjectRoutes.GET("/recommend", service.RecommendUsers)
	protectedProjectRoutes.POST("/tags", service.SearchProject)
	protectedProjectRoutes.POST("/create", service.CreateProject)
	protectedProjectRoutes.POST("/apply", service.ApplyForProject)
	protectedProjectRoutes.PUT("/save-post", service.SaveProject)
	protectedProjectRoutes.DELETE("/remove-post", service.RemoveSavedProject)
	protectedProjectRoutes.PUT("/edit", service.EditProject)
	protectedProjectRoutes.PATCH("/edit-view", service.EditProjectView)
	protectedProjectRoutes.PATCH("/edit-status", service.EditProjectAvailability)
	protectedProjectRoutes.PATCH("/update-application", service.UpdateProjectApplication)
	protectedProjectRoutes.DELETE("/delete-application", service.DeleteProjectApplication)
	protectedProjectRoutes.DELETE("/clear-application", service.ClearProjectApplication)
	protectedProjectRoutes.DELETE("/delete", service.DeleteProject)
}
```

## File: handlers/user.go
```go
package handlers

import (
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"findme/core"
	"findme/model"
	"findme/schema"

	"github.com/gin-gonic/gin"
)

// AddUser godoc
// @Summary			Register a new user
// @Description  Sign up endpoint for new users it internally calls a service to create a vector for the user
// @Tags	Auth
// @Accept  json
// @Produce json
// @Param payload body schema.SignupRequest true "User signup payload"
// @Success 201 {object} schema.DocTokenResponse "jwt token generated"
// @Failure 409 {object} schema.DocNormalResponse "Existing email or username"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /signup [post]
func (s *Service) AddUser(ctx *gin.Context) {
	var payload schema.SignupRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		log.Println(err)
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	// Checking for existing username | email
	var existingUser model.User
	if err := s.DB.CheckExistingUser(&existingUser, payload.Email, payload.UserName); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var err error
	var allskills []*model.Skill
	if len(payload.Skills) > 0 {
		for i := range payload.Skills {
			payload.Skills[i] = strings.ToLower(payload.Skills[i])
		}
		allskills, err = s.CheckAndUpdateSkills(payload.Skills)
		if err != nil {
			log.Printf("Failed to create skills for new user -> %s", err)
		}
	}

	hashedPassword, err := core.HashPassword(payload.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to encrypt the user password."})
		return
	}

	user := model.User{
		FullName:  payload.FullName,
		UserName:  payload.UserName,
		Email:     payload.Email,
		Password:  hashedPassword,
		Bio:       payload.Bio,
		Interests: payload.Interests,
		GitUser:   false,
		FreeTrial: time.Now().Add(7 * 24 * time.Hour),

		Skills:       allskills,
		Availability: true,
	}

	if err := s.DB.AddUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	jwtToken, err := GenerateJWT(user.ID, "login", true, JWTExpiry)
	if err != nil {
		log.Println("[APP] Failed to generate jwt token -> ", err.Error())
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to generate jwt token."})
		return
	}

	s.Emb.QueueUserCreate(user.ID, user.Bio, payload.Skills, user.Interests)

	ctx.JSON(http.StatusCreated, gin.H{"token": jwtToken})
}

// VerifyUser godoc
// @Summary			Log in a user
// @Description  Log in endpoint for existing users
// @Tags 	Auth
// @Accept  json
// @Produce json
// @Param payload body schema.LoginRequest true "User login payload"
// @Success 200 {object} schema.DocTokenResponse "jwt token generated"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /login [post]
func (s *Service) VerifyUser(ctx *gin.Context) {
	var payload schema.LoginRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var user model.User
	if err := s.DB.VerifyUser(&user, payload.UserName); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	jwtToken, err := Authorization(&user, payload.Password)
	if err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"token": jwtToken})
}

// GetUser godoc
// @Summary			 Get a user by their ID
// @Description  An endpoint for fetching a user by their ID
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "User ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocProjectUserResponse "user and projects fetched"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 400 {object} schema.DocNormalResponse "Invalid user id"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/get-user [get]
func (s *Service) GetUser(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	userID := ctx.Query("id")
	if !model.IsValidUUID(userID) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid user id."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadSP(&user, userID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var skills []string
	for _, skill := range user.Skills {
		skills = append(skills, skill.Name)
	}

	profile := schema.UserProfileResponse{
		ID:           user.ID,
		UserName:     user.UserName,
		FullName:     user.FullName,
		Country:      user.Country,
		GitUserName:  user.GitUserName,
		Gituser:      user.GitUser,
		Bio:          user.Bio,
		Availability: user.Availability,
		Skills:       skills,
		Interests:    user.Interests,
	}

	var posts []schema.ProjectResponse
	for _, post := range user.Projects {
		var tags []string
		for _, tag := range post.Tags {
			tags = append(tags, tag.Name)
		}
		posts = append(posts, schema.ProjectResponse{
			ID:          post.ID,
			Title:       post.Title,
			Description: post.Description,
			Available:   post.Availability,
			Tags:        tags,
			CreatedAt:   post.CreatedAt,
			UpdatedAt:   post.UpdatedAt,
			Views:       post.Views,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"user": profile, "posts": posts})
}

// GetUserInfo godoc
// @Summary			 Get the logged in user info
// @Description  An endpoint for fetching the currently logged in user profile details
// @Tags 		User
// @Accept  json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocUserResponse "user fetched"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/profile [get]
func (s *Service) GetUserInfo(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")

	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadS(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var skills []string
	for _, skill := range user.Skills {
		skills = append(skills, skill.Name)
	}

	profile := schema.UserProfileResponse{
		ID:           user.ID,
		UserName:     user.UserName,
		FullName:     user.FullName,
		Email:        user.Email,
		Country:      user.Country,
		GitUserName:  user.GitUserName,
		Gituser:      user.GitUser,
		Bio:          user.Bio,
		Availability: user.Availability,
		Skills:       skills,
		Interests:    user.Interests,
	}

	ctx.JSON(http.StatusOK, gin.H{"user": profile})
}

// GetUserPaymentInfo godoc
// @Summary Retreives a user saved payment info used for subscription
// @Description An endpoint for retreiving a user saved payment info used for subscription
// @Tags User
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewPaymentInfo "Success"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/payment-info [get]
func (s *Service) GetUserPaymentInfo(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")

	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if user.LastSub == nil {
		ctx.JSON(http.StatusNotFound, gin.H{"msg": "No payment info exists for this user."})
		return
	}

	info := schema.PaymentInfo{
		Last4: *user.Last4,
		Month: *user.ExpMonth,
		Year:  *user.ExpYear,
		Card:  *user.CardType,
	}

	if user.NextPaymentDate != nil {
		info.NextPaymentDate = *user.NextPaymentDate
	}

	ctx.JSON(http.StatusOK, gin.H{"info": info})
}

// RecommendProjects godoc
// @Summary  Recommends projects for a user to work on
// @Description An endpoint for recommending projects for a user to work on using ai
// @Tags User
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocRecProjectsResponse "Projects Retreived"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 402 {object} schema.DocNormalResponse "Payment Required"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/recommend [get]
func (s *Service) RecommendProjects(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	premium := ctx.GetBool("premium")
	if !premium {
		ctx.JSON(http.StatusPaymentRequired, gin.H{"msg": "You need to pay to use this service."})
		return
	}

	rec, err := s.Rec.GetRecommendation(uid, core.ProjectRecommendation)
	if err != nil || rec == nil {
		log.Printf("[gRPC Recommendation] Failed to get recommendation for user -> %v, err -> %v", uid, err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to retreive projects for the user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var ids []string

	for id := range rec.Res {
		ids = append(ids, id)
	}

	var projects []model.Project
	if err := s.DB.FindProjects(&projects, ids); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var result []schema.RecProjectResponse

	for _, project := range projects {
		score := rec.Res[project.ID]
		var tags []string
		for _, tag := range project.Tags {
			tags = append(tags, tag.Name)
		}
		result = append(result, schema.RecProjectResponse{
			Project: schema.ProjectResponse{
				ID:          project.ID,
				Title:       project.Title,
				Description: project.Description,
				Available:   project.Availability,
				Tags:        tags,
				CreatedAt:   project.CreatedAt,
				UpdatedAt:   project.UpdatedAt,
				Views:       project.Views,
			},
			Score: score,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"projects": result})
}

// ViewUser godoc
// @Summary			 Search for user with their username
// @Description  An endpoint for searching for a user with their username to show their projects and profile
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "Username"
// @Security BearerAuth
// @Success 200 {object} schema.DocProjectUserResponse "user and projects fetched"
// @Failure 400 {object} schema.DocNormalResponse "Invalid username"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/view [get]
func (s *Service) ViewUser(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	username := ctx.Query("id")
	if username == "" {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Username not in query."})
		return
	}
	var user model.User
	if err := s.DB.SearchUserPreloadSP(&user, username); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var skills []string
	for _, skill := range user.Skills {
		skills = append(skills, skill.Name)
	}
	userprofile := schema.UserProfileResponse{
		ID:           user.ID,
		UserName:     user.UserName,
		Country:      user.Country,
		GitUserName:  user.GitUserName,
		Gituser:      user.GitUser,
		Bio:          user.Bio,
		Skills:       skills,
		Interests:    user.Interests,
		Availability: user.Availability,
	}

	var posts []schema.ProjectResponse
	for _, post := range user.Projects {
		var tags []string
		for _, tag := range post.Tags {
			tags = append(tags, tag.Name)
		}
		posts = append(posts, schema.ProjectResponse{
			ID:          post.ID,
			Title:       post.Title,
			Description: post.Description,
			Available:   post.Availability,
			Tags:        tags,
			CreatedAt:   post.CreatedAt,
			UpdatedAt:   post.UpdatedAt,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"user": userprofile, "posts": posts})
}

// ViewGitUser godoc
// @Summary			 Search for user with their git username
// @Description  An endpoint for searching for a user with their git username to show their projects and profile
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "Git Username"
// @Security BearerAuth
// @Success 200 {object} schema.DocProjectUserResponse "user and projects fetched"
// @Failure 400 {object} schema.DocNormalResponse "Invalid git username"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/view-git [get]
func (s *Service) ViewGitUser(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	username := ctx.Query("id")
	if username == "" {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Git username not in query."})
		return
	}

	var user model.User
	if err := s.DB.SearchUserGitPreloadSP(&user, username); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var skills []string
	for _, skill := range user.Skills {
		skills = append(skills, skill.Name)
	}

	profile := schema.UserProfileResponse{
		ID:           user.ID,
		UserName:     user.UserName,
		GitUserName:  user.GitUserName,
		Gituser:      user.GitUser,
		Bio:          user.Bio,
		Email:        user.Email,
		Country:      user.Country,
		Skills:       skills,
		Interests:    user.Interests,
		Availability: user.Availability,
	}

	var posts []schema.ProjectResponse
	for _, post := range user.Projects {
		var tags []string
		for _, tag := range post.Tags {
			tags = append(tags, tag.Name)
		}
		posts = append(posts, schema.ProjectResponse{
			ID:          post.ID,
			Description: post.Description,
			Tags:        tags,
			CreatedAt:   post.CreatedAt,
			UpdatedAt:   post.UpdatedAt,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"user": profile, "posts": posts})
}

// ViewUserbySkills godoc
// @Summary			 Search for users by skills/tags
// @Description  An endpoint for searching for users with their skills to show their profiles
// @Tags 		User
// @Accept  json
// @Produce json
// @Param payload body schema.SearchUserbySkills true "Skills"
// @Security BearerAuth
// @Success 200 {object} schema.DocUsersSearch "users fetched"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/search [post]
func (s *Service) ViewUserbySkills(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.SearchUserbySkills
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var users []model.User
	if err := s.DB.SearchUsersBySKills(&users, payload.Skills, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var profiles []schema.SearchUser
	for _, user := range users {
		var skills []string
		for _, skill := range user.Skills {
			skills = append(skills, skill.Name)
		}
		profiles = append(profiles, schema.SearchUser{
			ID:           user.ID,
			UserName:     user.UserName,
			Bio:          user.Bio,
			Availability: user.Availability,
			GitUser:      user.GitUser,
			GitUserName:  user.GitUserName,
			Skills:       skills,
			Interests:    user.Interests,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"users": profiles})
}

// SendFriendReq godoc
// @Summary			 Send a Friend req to a user
// @Description  An endpoint for sending friend requests to users for connecting
// @Tags 		User
// @Accept  json
// @Produce json
// @Param payload body schema.SendFriendReq true "Request"
// @Security BearerAuth
// @Success 200 {object} schema.DocFriendReqStatus "Request sent"
// @Failure 422 {object} schema.DocNormalResponse "Failed to parse payload"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 409 {object} schema.DocNormalResponse "Existing Friend Req / Friend"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/send-user-req [post]
func (s *Service) SendFriendReq(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.SendFriendReq
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload.."})
		return
	}

	if err, friends := s.DB.CheckExistingFriends(uid, payload.ID); err != nil || friends {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err, exists := s.DB.CheckExistingFriendReq(uid, payload.ID); err != nil || exists {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var friend, user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.FetchUser(&friend, payload.ID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	req := model.FriendReq{
		UserFriend: model.UserFriend{
			UserID:   user.ID,
			FriendID: friend.ID,
		},
	}

	if len(payload.Message) > 0 {
		req.Message = payload.Message
	}

	if err := s.DB.AddFriendReq(&req); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Email.QueueFriendReqEmail(user.UserName, friend.UserName, req.Message, "", friend.Email)

	friendReq := schema.FriendReqStatus{
		ID:       req.ID,
		Username: friend.UserName,
		Message:  req.Message,
		Status:   req.Status,
	}

	ctx.JSON(http.StatusOK, gin.H{"req": friendReq})
}

// ViewFriendReq godoc
// @Summary			 View All friend reqs
// @Description  An endpoint for viewing all the looged in users friend reqs (sent and received)
// @Tags 		User
// @Accept  json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewFriendReqs "Fetched requests"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/view-user-req [get]
func (s *Service) ViewFriendReq(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.ViewFriendReq(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var sentRec, recReq []schema.FriendReqStatus
	for _, fr := range user.FriendReq {
		sentRec = append(sentRec, schema.FriendReqStatus{
			ID:       fr.ID,
			Status:   fr.Status,
			Username: fr.Friend.UserName,
			Message:  fr.Message,
			Sent:     fr.CreatedAt,
		})
	}

	for _, fr := range user.RecFriendReq {
		recReq = append(recReq, schema.FriendReqStatus{
			ID:       fr.ID,
			Status:   fr.Status,
			Username: fr.User.UserName,
			Message:  fr.Message,
			Sent:     fr.CreatedAt,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"sent_req": sentRec, "rec_req": recReq})
}

// UpdateFriendReqStatus godoc
// @Summary			 Update a friend req status
// @Description  An endpoint for updating the status of received friend req to rejected / accepted
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "Request ID"
// @Security BearerAuth
// @Success 202 {object} schema.DocFriendReqAccept "Request status updated"
// @Failure 400 {object} schema.DocNormalResponse "Invalid status / id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 403 {object} schema.DocNormalResponse "Permission Denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/update-user-req [patch]
func (s *Service) UpdateFriendReqStatus(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	reqID, status := ctx.Query("id"), ctx.Query("status")
	if !model.IsValidUUID(reqID) || status == "" {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid req ID or status"})
		return
	}

	var req model.FriendReq
	if err := s.DB.FetchFriendReq(&req, reqID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if req.FriendID != user.ID {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can't update the status of this request."})
		return
	}

	var friend model.User
	var chat model.Chat
	if err := s.DB.FetchUser(&friend, req.UserID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	switch status {
	case model.StatusRejected:
		if err := s.DB.UpdateFriendReqReject(&req); err != nil {
			cm := err.(*core.CustomMessage)
			ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}
	case model.StatusAccepted:
		if err := s.DB.UpdateFriendReqAccept(&req, &user, &friend, &chat); err != nil {
			cm := err.(*core.CustomMessage)
			ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
			return
		}
	default:
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid status."})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Status updated successfully.", "chat_id": chat.ID})
}

// DeleteSentReq godoc
// @Summary			 Delete a sent friend req
// @Description  An endpoint for deleting a sent friend request
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "Request id"
// @Security BearerAuth
// @Success 204 {object} nil "Request deleted"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 403 {object} schema.DocNormalResponse "Permission Denied"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/delete-friend-req [delete]
func (s *Service) DeleteSentReq(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	reqID := ctx.Query("id")
	if !model.IsValidUUID(reqID) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid request id."})
		return
	}

	var req model.FriendReq
	if err := s.DB.FetchFriendReq(&req, reqID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if req.UserID != user.ID {
		ctx.JSON(http.StatusForbidden, gin.H{"msg": "You can't delete this request."})
		return
	}

	if err := s.DB.DeleteFriendReq(&req); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// ViewUserFriends godoc
// @Summary			 View all friends for the logged in user
// @Description  An endpoint for viewing all the friends for the currently logged in user
// @Tags 		User
// @Accept  json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewFriends "User friends fetched"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/view-friend [get]
func (s *Service) ViewUserFriends(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadF(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var friends []schema.ViewFriends
	for _, fr := range user.Friends {
		friends = append(friends, schema.ViewFriends{
			ID:       fr.ID,
			Username: fr.UserName,
			Bio:      fr.Bio,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"friends": friends})
}

// ViewUserFriendsByID godoc
// @Summary			 View all friends of a user
// @Description  An endpoint for viewing all the friends of a user
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "User ID"
// @Security BearerAuth
// @Success 200 {object} schema.DocViewFriends "User friends fetched"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/view-user-friend [get]
func (s *Service) ViewUserFriendsByID(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	id := ctx.Query("id")
	if !model.IsValidUUID(id) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid user id."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadF(&user, id); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var friends []schema.ViewFriends
	for _, fr := range user.Friends {
		friends = append(friends, schema.ViewFriends{
			ID:       fr.ID,
			Username: fr.UserName,
			Bio:      fr.Bio,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"friends": friends})
}

// DeleteUserFriend godoc
// @Summary			 Delete a existing friendship
// @Description  An endpoint for deleting a friend from the users friend list
// @Tags 		User
// @Accept  json
// @Produce json
// @Param id query string true "User id"
// @Param chat_id query string true "Chat id"
// @Security BearerAuth
// @Success 204 {object} nil "Friend deleted"
// @Failure 400 {object} schema.DocNormalResponse "Invalid id"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized user"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/delete-user-friend [delete]
func (s *Service) DeleteUserFriend(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	id, cid := ctx.Query("id"), ctx.Query("chat_id")
	if !model.IsValidUUID(id) || !model.IsValidUUID(cid) {
		ctx.JSON(http.StatusBadRequest, gin.H{"msg": "Invalid friend or chat id."})
		return
	}

	var user, friend model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.FetchUser(&friend, id); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var chat model.Chat
	if err := s.DB.FetchChat(cid, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.DeleteFriend(&user, &friend, &chat); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusNoContent, nil)
}

// ForgotPassword godoc
// @Summary    Get a OTP for reseting user password
// @Description    An endpoint for getting an otp for reseting the user password
// @Tags  User
// @Accept json
// @Produce json
// @Param payload body schema.ForgotPasswordEmail true "User email"
// @Success 200 {object} schema.DocNormalResponse "Email sent to user"
// @Failure 422 {object} schema.DocNormalResponse "Invalid Email"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /forgot-password [post]
func (s *Service) ForgotPassword(ctx *gin.Context) {
	var payload schema.ForgotPasswordEmail
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var user model.User
	if err := s.DB.SearchUserEmail(&user, payload.Email); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	token := core.GenerateOTP()
	if err := s.RDB.SetOTP(token, user.ID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Email.QueueForgotPassEmail(user.Email, user.UserName, token)

	ctx.JSON(http.StatusOK, gin.H{"msg": "Check email for otp."})
}

// VerifyOTP godoc
// @Summary     Verify Sent otp to reset password
// @Description   An endpoint to verify sent otp to create reset jwt token for reseting user password
// @Tags  User
// @Accept json
// @Produce json
// @Param id query string true "otp"
// @Success 200 {object} schema.DocTokenResponse "reset token"
// @Failure 404 {object} schema.DocNormalResponse "invalid otp"
// @Failure 400 {object} schema.DocNormalResponse "invalid otp"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /verify-otp [get]
func (s *Service) VerifyOTP(ctx *gin.Context) {
	id := ctx.Query("id")
	if id == "" || len(id) != 6 {
		ctx.JSON(http.StatusBadRequest, "Invalid otp.")
		return
	}

	uid, err := s.RDB.GetOTP(id)
	if err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	jwt, err := GenerateJWT(uid, "reset", false, JWTRExpiry)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to create jwt token."})
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"token": jwt})
}

// ResetPassword godoc
// @Summary  Reset user password through forgot password route
// @Description  An endpoint for reseting the user password with a reset jwt token gotten from the verify-otp route
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.ResetPassword true "new password"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "reset successful"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid password"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/user/reset-password [patch]
func (s *Service) ResetPassword(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "reset" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.ResetPassword
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	hashed, err := core.HashPassword(payload.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Unable to hash password."})
		return
	}

	user.Password = hashed

	if err := s.DB.SaveUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "password reset successfully."})
}

// UpdateUserInfo godoc
// @Summary     Update the current user profile details
// @Description An endpoint for updating the logged-in user profile details
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.UserProfileRequest true "new details"
// @Security BearerAuth
// @Success 202 {object} schema.DocUserResponse "User updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 409 {object} schema.DocNormalResponse "Existing username / email"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/update-profile [put]
func (s *Service) UpdateUserInfo(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user, existingUser model.User
	var payload schema.UserProfileRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.CheckExistingUserUpdate(&existingUser, payload.Email, payload.UserName, user.ID); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	user.Email = payload.Email
	user.FullName = payload.FullName
	user.UserName = payload.UserName
	user.Country = payload.Country

	if err := s.DB.SaveUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	profile := schema.UserProfileResponse{
		ID:           user.ID,
		UserName:     user.UserName,
		FullName:     user.FullName,
		Email:        user.Email,
		Bio:          user.Bio,
		Country:      user.Country,
		GitUserName:  user.GitUserName,
		Gituser:      user.GitUser,
		Availability: user.Availability,
	}

	ctx.JSON(http.StatusAccepted, gin.H{"user": profile})
}

// UpdateUserBio godoc
// @Summary     Update the current user bio
// @Description An endpoint for updating the logged-in user bio information it internally calls a service to update the vector for the user.
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.UpdateUserBio true "new details"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "User updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/update-bio [patch]
func (s *Service) UpdateUserBio(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.UpdateUserBio
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadS(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	user.Bio = payload.Bio
	if err := s.DB.SaveUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var skills []string
	for _, skill := range user.Skills {
		skills = append(skills, skill.Name)
	}

	s.Emb.QueueUserUpdate(user.ID, user.Bio, skills, user.Interests)

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Bio updated successfully."})
}

// UpdateUserInterests godoc
// @Summary     Update the current user interests
// @Description An endpoint for updating the logged-in user interests it internally calls a service to update the vector for the user.
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.UpdateUserInterests true "new details"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "User updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/update-interest [patch]
func (s *Service) UpdateUserInterests(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Failed to parse payload."})
		return
	}

	var payload schema.UpdateUserInterests
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse payload."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadS(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	user.Interests = payload.Interest
	if err := s.DB.SaveUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var skills []string
	for _, skill := range user.Skills {
		skills = append(skills, skill.Name)
	}

	s.Emb.QueueUserUpdate(user.ID, user.Bio, skills, user.Interests)

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Interests updated successfully."})
}

// UpdateUserPassword godoc
// @Summary   Update the current user password
// @Description An endpoint for updating the logged-in user password
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.UpdatePassword true "new password"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "password updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/user/update-password [patch]
func (s *Service) UpdateUserPassword(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.UpdatePassword
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if user.Password != "" {
		if err := core.VerifyHashedPassword(payload.FormerPassword, user.Password); err != nil {
			ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Invalid Password."})
			return
		}
	}

	hashed, err := core.HashPassword(payload.Password)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to generate hash for user password."})
		return
	}
	user.Password = hashed

	if err := s.DB.SaveUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Password updated successfully."})
}

// UpdateUserAvaibilityStatus godoc
// @Summary    Update Availability status
// @Description An endpoint for updating the Availability status of the current user to either true or false it internally calls a service to update the user vector payload
// @Tags User
// @Accept json
// @Produce json
// @Param status path string true "Availability status"
// @Security BearerAuth
// @Success 202 {object} schema.DocNormalResponse "Status updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/user/update-availability/{status} [patch]
func (s *Service) UpdateUserAvaibilityStatus(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	status := ctx.Param("status")
	statusbool, err := strconv.ParseBool(status)
	if err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Availability status can only be true or false."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	user.Availability = statusbool

	if err := s.DB.SaveUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Emb.QueueUserUpdateStatus(user.ID, user.Availability)

	ctx.JSON(http.StatusAccepted, gin.H{"msg": "Availability updated successfully."})
}

// UpdateUserSkills godoc
// @Summary     Update User skills
// @Description An endpoint for updating the skills of the current user it internally calls a service to update the user vector
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.UpdateUserSkillsRequest true "Skills"
// @Security BearerAuth
// @Success 202 {object} schema.DocSkillsResponse "Skills updated"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "record not found"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/user/update-skills [patch]
func (s *Service) UpdateUserSkills(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.UpdateUserSkillsRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	for i := range payload.Skills {
		payload.Skills[i] = strings.ToLower(payload.Skills[i])
	}

	allskills, err := s.CheckAndUpdateSkills(payload.Skills)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"msg": "Failed to update user skills."})
		return
	}

	if err := s.DB.UpdateSkills(&user, allskills); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Emb.QueueUserUpdate(user.ID, user.Bio, payload.Skills, user.Interests)

	ctx.JSON(http.StatusAccepted, gin.H{"skills": payload.Skills})
}

// DeleteUserSkills godoc
// @Summary    Delete skills from the user skills
// @Description An endpoint to delete some skills from the current user skills it internally calls a service to update the user vector
// @Tags User
// @Accept json
// @Produce json
// @Param payload body schema.DeleteUserSkillsRequest true "Skills"
// @Security BearerAuth
// @Success 204 {object} nil "Skills Deleted"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 422 {object} schema.DocNormalResponse "Invalid payload"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/user/delete-skills [delete]
func (s *Service) DeleteUserSkills(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var payload schema.DeleteUserSkillsRequest
	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusUnprocessableEntity, gin.H{"msg": "Failed to parse the payload."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadS(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	userSkillSet := make(map[string]*model.Skill)
	for _, skill := range user.Skills {
		userSkillSet[skill.Name] = skill
	}

	var skillsToDelete []*model.Skill
	var skills []string
	for _, skill := range payload.Skills {
		if delete, exists := userSkillSet[strings.ToLower(skill)]; exists {
			skillsToDelete = append(skillsToDelete, delete)
		} else {
			skills = append(skills, skill)
		}
	}

	if err := s.DB.DeleteSkills(&user, skillsToDelete); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Emb.QueueUserUpdate(user.ID, user.Bio, skills, user.Interests)

	ctx.JSON(http.StatusNoContent, nil)
}

// ViewSubscriptions godoc
// @Summary  Views a user subscription history
// @Description An endpoint for viewing the history of a user's subsciption
// @Tags User
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} schema.DocViewSubscriptions "Subscriptions"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "Server error"
// @Router /api/user/view-subs [get]
func (s *Service) ViewSubscriptions(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUserPreloadSub(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	var response []schema.ViewSubscriptions

	for _, sub := range user.Subscriptions {
		response = append(response, schema.ViewSubscriptions{
			ID:    sub.ID,
			Start: sub.StartDate,
			End:   sub.EndDate,
		})
	}

	ctx.JSON(http.StatusOK, gin.H{"subs": response})
}

// DeleteUserAccount godoc
// @Summary    Delete a user account
// @Description An endpoint for deleting the current user account it internally calls a service to delete the vector of the user
// @Tags User
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 204 {object} nil "Account deleted"
// @Failure 401 {object} schema.DocNormalResponse "Unauthorized"
// @Failure 404 {object} schema.DocNormalResponse "Record not found"
// @Failure 500 {object} schema.DocNormalResponse "server error"
// @Router /api/user/delete-user [delete]
func (s *Service) DeleteUserAccount(ctx *gin.Context) {
	uid, tp := ctx.GetString("userID"), ctx.GetString("purpose")
	if !model.IsValidUUID(uid) || tp != "login" {
		ctx.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorized user."})
		return
	}

	var user model.User
	if err := s.DB.FetchUser(&user, uid); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	if err := s.DB.DeleteUser(&user); err != nil {
		cm := err.(*core.CustomMessage)
		ctx.JSON(cm.Code, gin.H{"msg": cm.Message})
		return
	}

	s.Emb.QueueUserDelete(user.ID)

	ctx.JSON(http.StatusNoContent, nil)
}
```
