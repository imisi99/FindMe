// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.12.4
// source: emb.proto

package emb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserEmbeddingService_CreateUserEmbedding_FullMethodName = "/emb.UserEmbeddingService/CreateUserEmbedding"
	UserEmbeddingService_UpdateUserEmbedding_FullMethodName = "/emb.UserEmbeddingService/UpdateUserEmbedding"
	UserEmbeddingService_UpdateUserStatus_FullMethodName    = "/emb.UserEmbeddingService/UpdateUserStatus"
	UserEmbeddingService_DeleteUserEmbedding_FullMethodName = "/emb.UserEmbeddingService/DeleteUserEmbedding"
)

// UserEmbeddingServiceClient is the client API for UserEmbeddingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserEmbeddingServiceClient interface {
	CreateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateUserStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	DeleteUserEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
}

type userEmbeddingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserEmbeddingServiceClient(cc grpc.ClientConnInterface) UserEmbeddingServiceClient {
	return &userEmbeddingServiceClient{cc}
}

func (c *userEmbeddingServiceClient) CreateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_CreateUserEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmbeddingServiceClient) UpdateUserEmbedding(ctx context.Context, in *UserEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_UpdateUserEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmbeddingServiceClient) UpdateUserStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_UpdateUserStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEmbeddingServiceClient) DeleteUserEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, UserEmbeddingService_DeleteUserEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserEmbeddingServiceServer is the server API for UserEmbeddingService service.
// All implementations must embed UnimplementedUserEmbeddingServiceServer
// for forward compatibility.
type UserEmbeddingServiceServer interface {
	CreateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateUserStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error)
	DeleteUserEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error)
	mustEmbedUnimplementedUserEmbeddingServiceServer()
}

// UnimplementedUserEmbeddingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserEmbeddingServiceServer struct{}

func (UnimplementedUserEmbeddingServiceServer) CreateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateUserEmbedding not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) UpdateUserEmbedding(context.Context, *UserEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserEmbedding not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) UpdateUserStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserStatus not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) DeleteUserEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteUserEmbedding not implemented")
}
func (UnimplementedUserEmbeddingServiceServer) mustEmbedUnimplementedUserEmbeddingServiceServer() {}
func (UnimplementedUserEmbeddingServiceServer) testEmbeddedByValue()                              {}

// UnsafeUserEmbeddingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserEmbeddingServiceServer will
// result in compilation errors.
type UnsafeUserEmbeddingServiceServer interface {
	mustEmbedUnimplementedUserEmbeddingServiceServer()
}

func RegisterUserEmbeddingServiceServer(s grpc.ServiceRegistrar, srv UserEmbeddingServiceServer) {
	// If the following call panics, it indicates UnimplementedUserEmbeddingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserEmbeddingService_ServiceDesc, srv)
}

func _UserEmbeddingService_CreateUserEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).CreateUserEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_CreateUserEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).CreateUserEmbedding(ctx, req.(*UserEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmbeddingService_UpdateUserEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).UpdateUserEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_UpdateUserEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).UpdateUserEmbedding(ctx, req.(*UserEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmbeddingService_UpdateUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).UpdateUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_UpdateUserStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).UpdateUserStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEmbeddingService_DeleteUserEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEmbeddingServiceServer).DeleteUserEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEmbeddingService_DeleteUserEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEmbeddingServiceServer).DeleteUserEmbedding(ctx, req.(*DeleteEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserEmbeddingService_ServiceDesc is the grpc.ServiceDesc for UserEmbeddingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserEmbeddingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emb.UserEmbeddingService",
	HandlerType: (*UserEmbeddingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUserEmbedding",
			Handler:    _UserEmbeddingService_CreateUserEmbedding_Handler,
		},
		{
			MethodName: "UpdateUserEmbedding",
			Handler:    _UserEmbeddingService_UpdateUserEmbedding_Handler,
		},
		{
			MethodName: "UpdateUserStatus",
			Handler:    _UserEmbeddingService_UpdateUserStatus_Handler,
		},
		{
			MethodName: "DeleteUserEmbedding",
			Handler:    _UserEmbeddingService_DeleteUserEmbedding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "emb.proto",
}

const (
	ProjectEmbeddingService_CreateProjectEmbedding_FullMethodName = "/emb.ProjectEmbeddingService/CreateProjectEmbedding"
	ProjectEmbeddingService_UpdateProjectEmbedding_FullMethodName = "/emb.ProjectEmbeddingService/UpdateProjectEmbedding"
	ProjectEmbeddingService_UpdateProjectStatus_FullMethodName    = "/emb.ProjectEmbeddingService/UpdateProjectStatus"
	ProjectEmbeddingService_DeleteProjectEmbedding_FullMethodName = "/emb.ProjectEmbeddingService/DeleteProjectEmbedding"
)

// ProjectEmbeddingServiceClient is the client API for ProjectEmbeddingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectEmbeddingServiceClient interface {
	CreateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	UpdateProjectStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
	DeleteProjectEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error)
}

type projectEmbeddingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectEmbeddingServiceClient(cc grpc.ClientConnInterface) ProjectEmbeddingServiceClient {
	return &projectEmbeddingServiceClient{cc}
}

func (c *projectEmbeddingServiceClient) CreateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_CreateProjectEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectEmbeddingServiceClient) UpdateProjectEmbedding(ctx context.Context, in *ProjectEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_UpdateProjectEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectEmbeddingServiceClient) UpdateProjectStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_UpdateProjectStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectEmbeddingServiceClient) DeleteProjectEmbedding(ctx context.Context, in *DeleteEmbeddingRequest, opts ...grpc.CallOption) (*EmbeddingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmbeddingResponse)
	err := c.cc.Invoke(ctx, ProjectEmbeddingService_DeleteProjectEmbedding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectEmbeddingServiceServer is the server API for ProjectEmbeddingService service.
// All implementations must embed UnimplementedProjectEmbeddingServiceServer
// for forward compatibility.
type ProjectEmbeddingServiceServer interface {
	CreateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error)
	UpdateProjectStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error)
	DeleteProjectEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error)
	mustEmbedUnimplementedProjectEmbeddingServiceServer()
}

// UnimplementedProjectEmbeddingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProjectEmbeddingServiceServer struct{}

func (UnimplementedProjectEmbeddingServiceServer) CreateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateProjectEmbedding not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) UpdateProjectEmbedding(context.Context, *ProjectEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProjectEmbedding not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) UpdateProjectStatus(context.Context, *UpdateStatusRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProjectStatus not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) DeleteProjectEmbedding(context.Context, *DeleteEmbeddingRequest) (*EmbeddingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProjectEmbedding not implemented")
}
func (UnimplementedProjectEmbeddingServiceServer) mustEmbedUnimplementedProjectEmbeddingServiceServer() {
}
func (UnimplementedProjectEmbeddingServiceServer) testEmbeddedByValue() {}

// UnsafeProjectEmbeddingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectEmbeddingServiceServer will
// result in compilation errors.
type UnsafeProjectEmbeddingServiceServer interface {
	mustEmbedUnimplementedProjectEmbeddingServiceServer()
}

func RegisterProjectEmbeddingServiceServer(s grpc.ServiceRegistrar, srv ProjectEmbeddingServiceServer) {
	// If the following call panics, it indicates UnimplementedProjectEmbeddingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProjectEmbeddingService_ServiceDesc, srv)
}

func _ProjectEmbeddingService_CreateProjectEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).CreateProjectEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_CreateProjectEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).CreateProjectEmbedding(ctx, req.(*ProjectEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectEmbeddingService_UpdateProjectEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_UpdateProjectEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectEmbedding(ctx, req.(*ProjectEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectEmbeddingService_UpdateProjectStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_UpdateProjectStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).UpdateProjectStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectEmbeddingService_DeleteProjectEmbedding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEmbeddingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectEmbeddingServiceServer).DeleteProjectEmbedding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectEmbeddingService_DeleteProjectEmbedding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectEmbeddingServiceServer).DeleteProjectEmbedding(ctx, req.(*DeleteEmbeddingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectEmbeddingService_ServiceDesc is the grpc.ServiceDesc for ProjectEmbeddingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectEmbeddingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emb.ProjectEmbeddingService",
	HandlerType: (*ProjectEmbeddingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProjectEmbedding",
			Handler:    _ProjectEmbeddingService_CreateProjectEmbedding_Handler,
		},
		{
			MethodName: "UpdateProjectEmbedding",
			Handler:    _ProjectEmbeddingService_UpdateProjectEmbedding_Handler,
		},
		{
			MethodName: "UpdateProjectStatus",
			Handler:    _ProjectEmbeddingService_UpdateProjectStatus_Handler,
		},
		{
			MethodName: "DeleteProjectEmbedding",
			Handler:    _ProjectEmbeddingService_DeleteProjectEmbedding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "emb.proto",
}
